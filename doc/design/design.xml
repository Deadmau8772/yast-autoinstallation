<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/xml/db41xml/docbookx.dtd"[]>

  <article>
    <articleinfo>    
      <title>AutoYaST Configuration Management System (CMS)</title>
      <author>
	<firstname>Anas</firstname>
	<surname>Nashif</surname>
      </author>    
    </articleinfo>
    <para>
      AutoYaST2 CMS now has a new interface which enables adding modules in
      execution time, depending on what modules are installed on the
      System. To enable this functionality, the various YaST2 run-time modules
      have to be adapted. CMS code that dealt with the different modules has
      moved to the run-time modules to keep such parts of the code in sync with
      the development being done on these modules.
    </para>
    <section>
      <title>Introduction</title>
      <para>
	The new plugin-like design has the following advantages:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    New Run-time module can be integrated automatically in the CMS,
	    thus new features in YaST2 mean new features in the auto-installer.
	  </para>		  
	</listitem> 
	<listitem>

	  <para>
	    Only installed run-time modules are being offered in the CMS. This
	    allows the integration of speciality run-time modules which are
	    only present on business products for example.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    Code which is relevant to one run-time configuration module is kept in one place
	    instead of maintaining it in different modules.
	  </para>
	</listitem>
      </itemizedlist>      
    </section>
  <section>
    <title>The run-time module interface in CMS</title>
    <para>The new interface (AKA _auto.ycp client) is now similar to the proposal
      structure and consists of functions. All the dialog code has been moved to
      autoyast to simplify the interface and to provide  a common user interface for
      all modules appearing in the autoyast configuration system.
    </para>
      <para>
	The interface of a run-time configuration module in the CMS has the follwoing
	components:	
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>Summary Area,</emphasis>: Contains a summary of the consifguration with the
	    values if available. If values where not configured, the phrase
	  <emphasis>'Not configured yet'</emphasis> is used, which is available from the summary module.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Configuration Button</emphasis>: A button which calls the module in auto mode
	    (<emphasis>&lt;module name&gt;_auto.ycp</emphasis>).
	  </para>	  
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Reset Button</emphasis>: A button for resetting the
	  configuration data. This will delete only data in the running module.
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	The summary area is filled with data from the <emphasis>Summary</emphasis> function in the
	module controling the configuration. (i.e
	<emphasis>NIS::Summary()</emphasis> in the NIS package).
      </para>      
    </section>
    <section>
      <title>Run-time modules in <emphasis>auto</emphasis> mode</title>
      <para>
	The &lt;module name&gt;_auto.ycp client accepts 2 argument:
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  Function
	</para>
      </listitem>
      <listitem>
	<para>
	  Configuration Data
	</para>
      </listitem>      
    </itemizedlist>
    <para>The following functions are needed to make any module work in autoyast:</para>
  <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Summary:</emphasis></para>
	<para>
    To provide  a brief summary of the configuration.
    Calls &gt;Module&lt;::Summary()
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Reset:</emphasis></para>
	<para>
    Resets the configuration. It returns empty values but it also can return
    default values, depending on the module.
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Change:</emphasis></para>
	<para>
    This function starts the widget sequence
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Write</emphasis></para>
	<para>
    Write the configuration without displaying any widgets and popups and
    without restarting any services etc.
    Calls &lt;Module&gt;::Write (and sets &lt;Module&gt;::write_only true)
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Result:</emphasis></para>
	<para>
    Returns the current configuration
    Calls &lt;Module&gt;::Export
	</para>
      </listitem>      
    </itemizedlist>
  
    <para>
      The following example shows &lt;module name&gt;_auto.ycp with the changes
      needed for the new behaviour. 
    </para>
    <example>
      <title>XXpkgXX_auto.ycp (XXpkgXX = module name)</title>
      <programlisting>
<![CDATA[
/**
 * @param function to execute
 * @param map/list of XXpkgXX settings
 * @return map edited settings, Summary or boolean on success depending on called function
 * @example map mm = $[ "FAIL_DELAY" : "77" ];
 * @example map ret = WFM::CallFunction ("XXpkgXX_auto", [ "Summary", mm ]);
 */

{

textdomain "XXpkgXX";

y2milestone("----------------------------------------");
y2milestone("XXPkgXX auto started");

import "XXPkgXX";
include "XXpkgXX/wizards.ycp";

any ret = nil;
string func = "";
map param = $[];

/* Check arguments */
if(size(Args()) > 0 && is(Args(0), string)) {
    func = WFM::Args(0);
    if(size(Args()) > 1 && is(Args(1), map))
	param = WFM::Args(1);
}
y2debug("func=%1", func);
y2debug("param=%1", param);

/* Create a  summary*/
if(func == "Summary") {
    XXPkgXX::Import(param);
    ret = select(XXPkgXX::Summary(), 0, "");
}
/* Reset configuration */
else if (func == "Reset") {
    XXPkgXX::Import($[]);
    ret = $[];
}
/* Change configuration (run AutoSequence) */
else if (func == "Change") {
    XXPkgXX::Import(param);
    ret = XXPkgXXAutoSequence();
}
/* Return actual state */
else if (func == "Result") {
    ret = XXPkgXX::Export();
}
/* Write givven settings */
else if (func == "Write") {
    import "Progress";
    XXPkgXX::write_only = true;
    XXPkgXX::Import(param);
    Progress::off();
    ret = XXPkgXX::Write();
    Progress::on();
    return ret;
}
/* Unknown function */
else {
    y2error("Unknown function: %1", func);
    ret = false;
}

y2debug("ret=%1", ret);
y2milestone("XXPkgXX auto finished");
y2milestone("----------------------------------------");

return ret;

/* EOF */
}




]]>
      </programlisting>
    </example>
  </section>
  <section>
    <title>Module functions needed for Auto-Install</title>
    <para>The follwoing is the list of function that should be available with
      the modules to provide the functionality needed in the CMS.
    </para>
    <refentry>
      <refnamediv>
	<refname>Import()</refname>
	<refpurpose>Imports settings from arguments</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Description</title>
	<para>This function imports settings from arguments and sets the module
	  variables. The <emphasis>Import</emphasis> function should bring the
	  module to a state where the data imported is enough for the module to
	  write (See Write()) a usable configuration.
	</para>

      </refsect1>
         
      <refsect1>
	<title>Returns</title>
	<para>Import() return false if some of the required keys are missing in the
	  imported map. If the imported data is empty, it returns true and
	  starts the module using default values.
	</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>Export()</refname>
	<refpurpose>Exports configured data to calling module</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Description</title>
	<para>Exports configured data to calling module. This function also
	  converts the internal variables to unique and human readable
	  variables which can be used in the control file needed for the
	  auto-installation. It is not allowed to export <emphasis>maps</emphasis> with configured
	  data as the keys. Configured data must be the value of a variable.</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<example>
	  <title>Export()</title>
	  <programlisting>
<![CDATA[
    global define map Export () ``{
	return $[
	    "start_nis": start,
	    "nis_servers": servers,
	    "nis_domain": domain,
	    "start_autofs": _start_autofs,
	    ];
    }
]]>
</programlisting>
	</example>
      </refsect1>
      <refsect1>
	<title>Returns</title>
	<para>This function returns a map of the configuration data.</para>
      </refsect1>
    </refentry>

    <refentry>
      <refnamediv>
	<refname>Write()</refname>
	<refpurpose>Write or commit configured or imported data</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Description</title>
	<para>Commit configured data. This function is also used in normal
	  operation mode and should not be used to write configuration in
	  auto-installation mode. Instead, use<emphasis> WriteOnly()</emphasis>
	  or set the global variable <emphasis>write_only</emphasis> to true
	  before writing.</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>WriteOnly()</refname>
	<refpurpose>Only write/commit data, do not restart any services yet</refpurpose>
      </refnamediv>
      <refsect1>
	<title></title>
	<para>Write configuration only without restarting services or make the
	  system use the new configuration. This is important in the so called
	  <emphasis>continue mode</emphasis>, as services are started directly
	  after the YaST2 has finished installation anyways.</para>
      </refsect1>
    </refentry>
  </section>
  <section>
    <title>Configuration file</title>
    
    <para>
      When the CMS is invloked, it  checks for the configuration files in
      <filename>/usr/share/YaST2/config</filename> and evaluates them to
      later include them in the configuration interface.
    </para>
    <para>AutoYaST2 CMs uses the same configuration file used for the YaST2
      Control Center with some additions and modifications.
    </para>
    <para>
      The following is an example of the configuration file for the NIS module:
    </para>
    <example>
      <title>Auto-Install Configuration file for NIS</title>
      <programlisting>
;
; Menuentry file used by
;  YaST2 Control Center
;
; $Id$
;

[Y2Module nis]

; name of the entry, shown in y2cc
Name = _("NIS client")

; "raw" group name to which this module belongs
; see /usr/lib/YaST2/etc/y2controlcentericons.y2cc for valid values
Group = Net_advanced

; icon displayed in y2cc
Icon = nis_client.png

; *one* *short* descriptive line for y2cc
Helptext = _("Configure NIS client")

; arguments, seperated by space
Arguments = 

; whether root privileges are required to run this module
RequiresRoot = true

; default size for window, Y2CC will set $Y2_GEOMETRY to this value
Geometry = 

; string to use for sorting instead of Name
SortKey = 

; which textdomain to use for translations (important!)
Textdomain = nis

; vim:syntax=dosini

      </programlisting>
    </example>
    <para>In addition to the keywords from the last example, the CMS also evaluates
      the following keywords:</para>

    <refentry>
      <refnamediv>
	<refname>Autoinst</refname>
	<refpurpose>Is the module compatible with the
	  CMS and can Import/Export configurations?</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values:</title>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para><emphasis>all</emphasis>: Full auto-installation support,
		including configuration (_auto) and writing (_write) </para>	
	    </listitem>
	    <listitem>
	      <para><emphasis>write</emphasis>: Write only support </para>	
	    </listitem>     
	    <listitem>
	      <para><emphasis>configure</emphasis>: Configuration only support.
		Normally used only with parts related to installation like
		partitioning and general options which have no run-time module
		with support for auto-installation. Data is written using the
		common installation process and modules available in YaST2</para>
	    </listitem>    

	  </itemizedlist>  
	</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>AutoinstPath</refname>
	<refpurpose>Path in the control file</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values:</title>
	<para>	configure or install: All run-time configuration modules are
	  contained in the <emphasis>configure</emphasis> resource. Only
	  configuration data directly touching the installation of a system are
	  contained in the <emphasis>install</emphasis> resource.</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>AutoClient</refname>
	<refpurpose>NAme of the client to call</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>	Name of the client to be called by the CMS.</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para>&lt;module name&gt;_auto</para>
      </refsect1>
    </refentry>
 
  </section>
  <section>
    <title>Conventions for module Writers</title>
    <section>
      <title>Exported Data</title>
      <itemizedlist>
	<listitem>
	  <para><emphasis>Type of exported data</emphasis>: </para>
	  <para>Modules should only export data which is normally selected or
	entered by the user in normal module operation. No computed or
	automatically probed data should be exported.</para>
	</listitem>
	<listitem>	  
	  <para><emphasis>Use Namespaces</emphasis></para>
	  <para>Exported variables should have a unique name when possible and
	    when  general terminology is being used. To avoid conflicts and confusion,
	    use a name space identifier with common words. For example, if  a
	    module should export the variable name
	    <emphasis>options</emphasis>, it is better to export<emphasis> &lt;module
	    name&gt;.options</emphasis> to avoid confusion with other modules using
	    <emphasis>options</emphasis>, which is very common in configurations.	    
	  </para>	  
	</listitem>
	<listitem>
	  <para><emphasis>Lower case variables</emphasis></para>
	  <para>To have a common and unified look of the control file, please
	    use lower case variables when exporting the configuration data.</para>
	</listitem>
	<listitem>
	  <para>The structure of the exported data should be readable and not
	    unnecessarly complex.</para>
	</listitem>
	<listitem>
	  <para>Avoid using configuration data as the key in a map key/value
	    pair. The key of the pair must always contain the variable name,
	    rather than it's contents</para>
	</listitem>
      </itemizedlist>
     
    </section>    

    <section>
      <title>YaST2 Module Types</title>
      <para>
	YaST2 configuration modules and in relation with AutoYaST can be put
	into three categories:	
      </para>      
      <orderedlist>
	<listitem>
	  <para>Simple modules which mormally only change sysconfig variable
	    and have simple configuration data structure. (i.e. mail, nis,
	    ldap, etc.)
	  </para>
	  <para>
	    This category needs no special attention and is easy to integrate with
	    the AutoYaST. 
	</para>
	</listitem>
	<listitem>
	  <para>Simple modules dealing with hardware configuration (i.e. network,
	    sound, printer etc.)
	  </para>
	  <para>
	    These modules need to be able to
	    read and autodetect hardware data during installation if no hardware
	    data is specified in the control file. The behaviour of this type of
	    modules up to 8.1 was to import data and write it wihtout actually
	    reading anything from the system.
	  </para>
	  <para>
	    An additional step has to be added between the import and the
	    write, where hardware data is read and imported into the module. In
	    some case this is simply done by calling the Read function the module.
	  </para>
	</listitem>
	<listitem>
	  <para>Modules for management of complex configuration files
	    (i.e. inetd, sysconfig, runlevel, users, bootloader)
	  </para>
	  <para>
	    This class of modules is much more complex and requires adaptation
	    and special attention. AutoYaST expects that only new and modified
	    entries will be exported and not the whole configuration tree. For
	    example when a user enables a service in inetd, only this service
	    is exported. A user should be able to add new services which are
	    not available in the default configuration file too.
	  </para>
	</listitem>
      </orderedlist>           	
    </section>
    <section>
      <title>Module behaviour</title>
      <para>
	In configuration mode for auto-installation, modules <emphasis>should
	  not</emphasis>(configuration system is the machine where the control
	file is being created):
	<itemizedlist>
	  <listitem>
	    <para>Read any data from the configuration system</para>
	  </listitem>
	  <listitem>
	    <para>Probe or detect hardware on the configuration system</para>
	  </listitem>
	  <listitem>
	    <para>Change configuration data on the configuration system</para>
	  </listitem>
	  <listitem>
	    <para>Offer a link to other modules (i.e. calling the NIS module
	      from the users module)</para>
	  </listitem>

	  <listitem>
	    <para>Check if a needed package is installed on the configuration system.</para>
	  </listitem>
	  
	</itemizedlist>
      </para>
    </section>
  </section>
  </article>

