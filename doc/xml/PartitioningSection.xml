<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd"[

<!ENTITY % daps-entities SYSTEM "entity-decl.ent">
<!ENTITY % daps-network-entities SYSTEM "network-decl.ent">
%daps-entities;
%daps-network-entities;
<!ENTITY % images SYSTEM "images.ent">
%images;

<!ENTITY % entities SYSTEM "entities/en.ent">
%entities;

<!-- Examples -->
<!ENTITY % examples SYSTEM "examples.ent">
%examples;

<!-- components -->
<!ENTITY % components SYSTEM "components.ent">
%components;

]>

  <section id="CreateProfile.Partitioning">
    <title>Partitioning</title>

    <section>
        <title>Drive Configuration</title>
    <warning>
      <title>
    EVMS Support Dropped in openSUSE 11.1 and SLES11	
      </title>
      <para>
	Since openSUSE 11.1 and SLES11, EVMS is no longer supported in the
	installation system. That means all support for EVMS in &ay; was
	dropped as well. All EVMS documentation here is only valid for SLES10
	(all service packs)
      </para>
    </warning>
          <para>
          The following elements must be between the &lt;partitioning config:type="list"&gt;&lt;drive&gt; ... &lt;/drive&gt;&lt;/partitioning&gt; tags in the &lt;profile&gt; section.
          </para>
          <informaltable frame='top'>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Attribute</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>device</entry>
                <entry><para>The device you want to configure in this &lt;drive&gt; section. You can use persistent device names via id, like <emphasis>/dev/disk/by-id/ata-WDC_WD3200AAKS-75L9A0_WD-WMAV27368122</emphasis> or <emphasis>by-path</emphasis>,like <emphasis>/dev/disk/by-path/pci-0001:00:03.0-scsi-0:0:0:0</emphasis>.</para>
                  <screen>&lt;device&gt;/dev/hda&lt;/device&gt;</screen>
                </entry>
                <entry>Optional. If left out, &ay; tries to guess the device (on openSUSE 12.2 and SLES11 SP2 you can influess the guessing - see below this table for instructions on how to do that). A RAID must always have "/dev/md" as device.</entry>
              </row>
              <row>
                <entry>initialize</entry>
                <entry><para>If set to "true", the partition table gets wiped out before &ay; starts the partition calculation.</para>
<screen>&lt;initialize config:type="boolean"
&gt;true&lt;/initialize&gt;</screen>
</entry>
                <entry>Optional. The default is "false".</entry>
              </row>
<!--
              <row>
                <entry>is_lvm_vg</entry>
                <entry><para>Specifies if a device is not a physical device but a LVM volume group (see LVM configuration below).</para>
<screen>&lt;is_lvm_vg config:type="boolean"
&gt;true&lt;/is_lvm_vg&gt;</screen>
</entry>
                <entry><para><emphasis>Deprecated</emphasis> since SLES10SP1 and SL10.2. Use <emphasis>type</emphasis> instead. Must be "true" if this device is a LVM volume group. The default is "false".</para></entry>
              </row>
              <row>
                <entry>is_evms_vg</entry>
                <entry><para>Specifies if a device is not a physical device but an EVMS volume group (see EVMS configuration below).</para>
<screen>&lt;is_evms_vg config:type="boolean"
&gt;true&lt;/is_evms_vg&gt;</screen>
</entry>
                <entry><para><emphasis>Deprecated</emphasis> since SLES10SP1 and SL10.2. Use <emphasis>type</emphasis> instead. Must be "true" if this device is an EVMS volume group. The default is "false".</para></entry>
              </row>
-->
              <row>
                <entry>partitions</entry>
                <entry><para>A list of &lt;partition&gt; entries (see table below).</para>
<screen>&lt;partitions config:type="list"&gt;
  &lt;partition&gt;...&lt;/partition&gt;
  ...
&lt;/partitions&gt;</screen>
</entry>
                <entry>Optional. If no partitions are specified, &ay; will create a reasonable partitioning (see Automated Partitioning below).</entry>
              </row>
              <row>
                <entry>pesize</entry>
                <entry><para>This value makes only sense with LVM/EVMS.</para>
<screen>&lt;pesize&gt;8M&lt;/pesize&gt;</screen>
</entry>
                <entry>Optional. Default is 4M for EVMS/LVM volume groups.</entry>
              </row>
              <row>
                <entry>use</entry>
                <entry><para>Specifies the strategy &ay; will use to partition the hard disk.</para>
<para>Choose between:</para>
<itemizedlist>
<listitem>
<para>all (uses the whole device while calculating the new partitioning),</para>
</listitem>
<listitem>
<para>linux (only existing linux partitions are used),</para>
</listitem>
<listitem>
<para>free (only unused space on the device is used, no other partitions are touched),</para>
</listitem>
<listitem>
<para>1,2,3 (a list of comma separated partition numbers to use).</para>
</listitem>
</itemizedlist>
</entry>
                <entry>This parameter should be provided.</entry>
              </row>
              <row>
                <entry>type</entry>
                <entry><para>Specify the type of the <emphasis>drive</emphasis></para>
<para>Choose between:</para>
<itemizedlist>
<listitem>
<para>CT_DISK for physical hard disks (default),</para>
</listitem>
<listitem>
<para>CT_LVM for LVM volume groups,</para>
</listitem>
<listitem>
<para>CT_EVMS for EVMS volume groups.</para>
</listitem>
</itemizedlist>

<screen>&lt;type config:type="symbol"&gt;CT_LVM&lt;/type&gt;</screen>
</entry>
                <entry>Optional. Default is CT_DISK for a normal physical hard disk.</entry>
              </row>
              <row>
                <entry>disklabel</entry>
                <entry><para>Describes the type of the partition table.</para>
<para>Choose between:</para>
<itemizedlist>
<listitem>
<para>msdos,</para>
</listitem>
<listitem>
<para>gpt.</para>
</listitem>
</itemizedlist>

<screen>&lt;disklabel&gt;gpt&lt;/disklabel&gt;</screen>
</entry>
                <entry>Optional and available since openSUSE 12.1 and SLES11 SP2. By default &yast; decides what makes sense (msdos in most cases).</entry>
              </row>
              <row>
                <entry>keep_unknown_lv</entry>
                <entry><para>This value only makes sense for type=CT_LVM drives. If you are reusing a LVG and you set this to "true", all existing LVs in that VG will not be touched unless they are specified in the &lt;partitioning&gt; section. So you can keep existing LVs without specifying them.</para>
<screen>&lt;keep_unknown_lv config:type="boolean"
&gt;false&lt;/keep_unknown_lv&gt;</screen>
</entry>
                <entry>Optional and available since openSUSE 12.1 and SLES11 SP2. The default is "false".</entry>
              </row>
            </tbody>
          </tgroup>
          </informaltable>
    <para>Since openSUSE 12.2 and SLES11 SP2 you can influence the device-guessing of AutoYaST for the case that you don't specify a &lt;device&gt; entry on your own. Usually AutoYaST would use the first device it can find and that looks reasonable but you can configure to skip some devices like this:
</para>
<screen>
&lt;partitioning config:type=&quot;list&quot;&gt;
  &lt;drive&gt;
    &lt;initialize config:type=&quot;boolean&quot;&gt;true&lt;/initialize&gt;
    &lt;!-- the skip_list is optional and available since openSUSE 12.2 and SLES11 SP2 --&gt;
    &lt;skip_list config:type=&quot;list&quot;&gt;
      &lt;listentry&gt;
        &lt;!-- skip devices that use the usb-storage driver --&gt;
        &lt;skip_key&gt;driver&lt;/skip_key&gt;
        &lt;skip_value&gt;usb-storage&lt;/skip_value&gt;
      &lt;/listentry&gt;
      &lt;listentry&gt;
        &lt;!-- skip devices that are smaller than 1GB --&gt;
        &lt;skip_key&gt;size_k&lt;/skip_key&gt;
        &lt;skip_value&gt;1048576&lt;/skip_value&gt;
        &lt;skip_if_less_than config:type=&quot;boolean&quot;&gt;true&lt;/skip_if_less_than&gt;
      &lt;/listentry&gt;
      &lt;listentry&gt;
        &lt;!-- skip devices that are larger than 100GB --&gt;
        &lt;skip_key&gt;size_k&lt;/skip_key&gt;
        &lt;skip_value&gt;104857600&lt;/skip_value&gt;
        &lt;skip_if_more_than config:type=&quot;boolean&quot;&gt;true&lt;/skip_if_more_than&gt;
      &lt;/listentry&gt;
    &lt;/skip_list&gt;
    ...
</screen><para>
For a list of all possible &lt;skip_key&gt;, run "yast2 ayast_probe" on openSUSE 12.2 or SLES11SP2
    </para>
</section>
    <section>
        <title>Partition Configuration</title>
          <para>
          The following elements must be between the &lt;partitions config:type="list"&gt;&lt;partition&gt; ... &lt;/partition&gt;&lt;/partitions&gt; tags in the &lt;drive&gt; section.
          </para>
          <informaltable frame='top'>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Attribute</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>create</entry>
                <entry>
                  <para>
                    Specify if this partition must be created or if it already exists.
                  </para>
                  <screen>&lt;create config:type="boolean"
&gt;false&lt;/create&gt;</screen>
                </entry>
                <entry>If set to "false", provide information for &ay; which partition this is (like with partition_nr).</entry>
              </row>
              <row>
                <entry>mount</entry>
                <entry>
                  <para>
                    The mountpoint of this partition.
                  </para>
                  <screen>&lt;mount&gt;/&lt;/mount&gt;</screen>
                  <screen>&lt;mount&gt;swap&lt;/mount&gt;</screen>
                </entry>
                <entry>You should have at least a root partition (/) and a swap partition.</entry>
              </row>
              <row>
                <entry>fstopt</entry>
                <entry>
                  <para>
                    Mount options for this partition.
                  </para>
                  <screen>&lt;fstopt
&gt;ro,noatime,user,data=ordered,acl,user_xattr&lt;/fstopt&gt;</screen>
                </entry>
                <entry>See <command>man mount</command> for available mount options.</entry>
              </row>
              <row>
                <entry>label</entry>
                <entry>
                  <para>
                    The label of the partition (useful for the "mountby" parameter; see below).
                  </para>
                  <screen>&lt;label&gt;mydata&lt;/label&gt;</screen>
                </entry>
                <entry>See <command>man e2label</command> for an example.</entry>
              </row>
              <row>
                <entry>uuid</entry>
                <entry>
                  <para>
                    The uuid of the partition (only useful for the "mountby" parameter; see below).
                  </para>
                  <screen>&lt;uuid
&gt;1b4e28ba-2fa1-11d2-883f-b9a761bde3fb&lt;/uuid&gt;</screen>
                </entry>
                <entry>See <command>man uuidgen</command>.</entry>
              </row>
              <row>
                <entry>size</entry>
                <entry>
                  <para>
                    The size of the partition, e.g. 4G, 4500M, etc. The /boot partition and the swap partition can have "auto" as
                    size. Then &ay; calculates a reasonable size. One partition can have the value "max" to use all remaining space.
                  </para>
                  <para>
                    You can specify the the size in percentage. So 10% will use 10% of the size
                    of the hard disk or VG. You can mix auto, max, size, and percentage as you like.
                  </para>
                  <screen>&lt;size&gt;10G&lt;/size&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>format</entry>
                <entry>
                  <para>
                    Specify if &ay; should format the partition.
                  </para>
                  <screen>&lt;format config:type="boolean"&gt;false&lt;/format&gt;</screen>
                </entry>
                <entry>If you set "create" to "true", then you likely want this is option set to "true" as well.</entry>
              </row>
              <row>
                <entry>filesystem</entry>
                <entry>
                  <para>
                    Specify the filesystem to use on this partition:
                  </para>
<itemizedlist>
<listitem>
<para>ext2,</para>
</listitem>
<listitem>
<para>ext3,</para>
</listitem>
<listitem>
<para>ext4,</para>
</listitem>
<listitem>
<para>xfs,</para>
</listitem>
<listitem>
<para>reiser,</para>
</listitem>
<listitem>
<para>swap.</para>
</listitem>
</itemizedlist>

                  <screen>&lt;filesystem config:type="symbol"
&gt;ext3&lt;/filesystem&gt;</screen>
                </entry>
                <entry><para>Optional. The default is ext3 for SLES11 and ext4 for openSuSE 12.x</para></entry>
              </row>
              <row>
                <entry>mkfs_options</entry>
                <entry>
                  <para>
                    Specifiy an option string that is added to the mkfs command.
                  </para>
                  <screen>&lt;mkfs_options&gt;-I 128&lt;/mkfs_options&gt;</screen>
                </entry>
                <entry><para>Optional. Only use this when you know what you ar doing.</para></entry>
              </row>
              <row>
                <entry>partition_nr</entry>
                <entry>
                  <para>
                    The partition number of this partition. If you have set
                    create=false or if you use LVM, then you can specify the
                    partition via partition_nr. You can force &ay; to only
                    create primary partitions by assigning numbers below 5.
                  </para>
                  <screen>&lt;partition_nr config:type="integer"
&gt;2&lt;/partition_nr&gt;</screen>
                </entry>
                <entry>In most cases, numbers 1 to 4 are primary partitions
                while 5 and higher are logical partitions.</entry>
              </row>
              <row>
                <entry>partition_id</entry>
                <entry>
                  <para>
                   The partition_id sets the id of the partition. If you want different identifiers than 131
                        for Linux partition or 130 for swap, configure them with partition_id.
                  </para>
                  <screen>&lt;partition_id config:type="integer"
&gt;131&lt;/partition_id&gt;</screen>
                </entry>
                <entry>The default is 131 for linux partition and 130 for swap.</entry>
              </row>
<!--
              <row>
                <entry>filesystem_id</entry>
                <entry>
                  <para>
                   See partition_id above. For historical reasons they represent the same.
                  </para>
                  <screen>&lt;filesystem_id config:type="integer"
&gt;131&lt;/filesystem_id&gt;</screen>
                </entry>
                <entry>Since 10.1 and SLES10 it is recommended to use partition_id instead.</entry>
              </row>
-->
              <row>
                <entry>mountby</entry>
                <entry>
                  <para>
                   Instead of a partition number, you can tell &ay; to mount a partition by device, label, uuid, path or id, which are the udev path and udev id (see /dev/disk/...).
                  </para>
                  <screen>&lt;mountby config:type="symbol"
&gt;label&lt;/mountby&gt;</screen>
                </entry>
                <entry>See "label" and "uuid" documentation above. The default depends on YaST and is id in most cases. It was device in the past.</entry>
              </row>
              <row>
                <entry>subvolumes</entry>
                <entry>
                  <para>
                   List of subvolumes to create for a filesystem of type btrfs. This key only make sense for filesystems of type btrfs. If there is a default subvolume used for the distribution (like e.g. "@" in SLES11 SP2) the name of
this default subvolume is automatically prepended to the names in this list.
                  </para>
                  <screen>&lt;subvolumes config:type="list"&gt;
    &lt;path&gt;tmp&lt;/path&gt;
    &lt;path&gt;opt&lt;/path&gt;
    &lt;path&gt;srv&lt;/path&gt;
    &lt;path&gt;var/crash&lt;/path&gt;
    &lt;path&gt;var/lock&lt;/path&gt;
    &lt;path&gt;var/run&lt;/path&gt;
    &lt;path&gt;var/tmp&lt;/path&gt;
    &lt;path&gt;var/spool&lt;/path&gt;
    ...
&lt;/subvolumes&gt;</screen>
                </entry>
                <entry>this key is available since openSUSE 12.3 and SLES11 SP3</entry>
              </row>
              <row>
                <entry>lv_name</entry>
                <entry>
                  <para>
                    If this partition is in a logical volume in a volume group
                    (LVM or EVMS) specify the logical volume name here (see
                    is_lvm_vg or is_evms_vg parameter in drive configuration).
                   </para>
                  <screen>&lt;lv_name&gt;opt_lv&lt;/lv_name&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>stripes</entry>
                <entry>
                  <para>
                    An integer that configures LVM striping. Specify across how many devices you want to stripe (spread data).
                  </para>
                  <screen>&lt;stripes config:type="integer"&gt;2&lt;/stripes&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>stripesize</entry>
                <entry>
                  <para>
                    Specify the size of each block in kb.
                  </para>
                  <screen>&lt;stripesize config:type="integer"
&gt;4&lt;/stripesize&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>lvm_group</entry>
                <entry>
                  <para>
                    If this is a physical partition used by (part of) a volume
                    group (LVM), you have to specify the name of the volume
                    group here.
                  </para>
                  <screen>&lt;lvm_group&gt;system&lt;/lvm_group&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>pool</entry>
                <entry>
                  <para>
                   Boolean must be set to true if the LVM logical volume should be a LVM thin pool.
                  </para>
                  <screen>&lt;pool config:type="boolean"&gt;false&lt;/pool&gt;</screen>
                </entry>
                <entry>this key is available since openSUSE 12.3 and SLES11 SP3</entry>
              </row>
              <row>
                <entry>used_pool</entry>
                <entry>
                  <para>
                   The name of the LVM thin pool that is used as data store for this thin logical volume.
		   If this is set to something nonempty, it implies that the volume is a so called thin logical volume.
                  </para>
                  <screen>&lt;used_pool&gt;my_thin_pool&lt;/used_pool&gt;</screen>
                </entry>
                <entry>this key is available since openSUSE 12.3 and SLES11 SP3</entry>
              </row>
              <row>
                <entry>evms_group</entry>
                <entry>
                  <para>
                    If this physical partition is used by a volume group
                    (EVMS), you have to specify the name of the volume group
                    here.
                  </para>
                  <screen>&lt;evms_group&gt;system&lt;/evms_group&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>raid_name</entry>
                <entry>
                  <para>
                    If this physical volume is part of a RAID, specify the
                    name of the RAID.
                  </para>
                  <screen>&lt;raid_name&gt;/dev/md0&lt;/raid_name&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>raid_type</entry>
                <entry>
                  <para>
                    Specify the type of the RAID.
                  </para>
                  <screen>&lt;raid_type&gt;raid1&lt;/raid_type&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>raid_options</entry>
                <entry>
                  <para>
                    Specify RAID options, see below.
                  </para>
                  <screen>&lt;raid_options&gt;...&lt;/raid_options&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>resize</entry>
                <entry>
                  <para>
                    This boolean must be "true" if an existing partition should be resized. In this case,
                    you want to set <emphasis>create</emphasis> to <emphasis>false</emphasis> and in
                    most cases you don't want to <emphasis>format</emphasis> the partition. You need to
                    tell &ay; the <emphasis>partition_nr</emphasis> and the <emphasis>size</emphasis>.
                    The size can be in percentage of the original size or a number, like
                    <emphasis>800M</emphasis>. <emphasis>max</emphasis> and <emphasis>auto</emphasis> do not
                    work as size here.
                  </para>
                  <screen>&lt;resize config:type="boolean"
&gt;false&lt;/resize&gt;</screen>
                </entry>
                <entry>The resize only works with physical disks. Not with LVM/EVMS volumes.</entry>
              </row>
            </tbody>
          </tgroup>
          </informaltable>
        </section>
    <section>
        <title>RAID Options</title>
          <para>
          The following elements must be between the &lt;partition&gt;&lt;raid_options&gt; ... &lt;/raid_options&gt;&lt;/partition&gt; tags.
          </para>
          <informaltable frame='top'>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Attribute</entry>
                <entry>Values</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>chunk_size</entry>
                <entry>
                  <para>
                  </para>
                  <screen>&lt;chunk_size&gt;4&lt;/chunk_size&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>parity_algorithm</entry>
                <entry>
                  <para>
                    Possible values are: left_asymmetric, left_symmetric, right_asymmetric, right_symmetric. Since SLES11 SP2 and openSUSE 12.1 you can use: parity_first, parity_last, left_asymmetric_6, left_symmetric_6, right_asymmetric_6, right_symmetric_6, parity_first_6, n2, o2, f2, n3, o3, f3 for RAID6 and RAID10
                  </para>
                  <screen>&lt;parity_algorithm
&gt;left_asymmetric&lt;/parity_algorithm&gt;</screen>
                </entry>
                <entry></entry>
              </row>
              <row>
                <entry>raid_type</entry>
                <entry>
                  <para>
                    Possible values are: raid0,raid1 and raid5.
                  </para>
                  <screen>&lt;raid_type&gt;raid1&lt;/raid_type&gt;</screen>
                </entry>
                <entry>The default is raid1.</entry>
              </row>
              <row>
                <entry>device_order</entry>
                <entry>
                  <para>
                    this list contains the optional order of the physical devices
                  </para>
                  <screen>&lt;device_order config:type="list"&gt;
   &lt;device&gt;/dev/sdb2&lt;/device&gt;
   &lt;device&gt;/dev/sda1&lt;/device&gt;
   ...
&lt;/device_order&gt;</screen>
                </entry>
                <entry>this is optional and the default is alphabetical order</entry>
                <entry>this key is available since openSUSE 12.2 and SLES11 SP3</entry>
              </row>
            </tbody>
          </tgroup>
         </informaltable>
        </section>
    <section>
      <title>
	Automated Partitioning
      </title>

      <para>
	For automated partitioning, you only need to provide the sizes and
	mount points of partitions. All other data needed for successful partitioning is calculated during installation&mdash;unless provided in the control file.
      </para>
      <para>
	If no partitions are defined and the specified drive is also the drive
	where the root partition should be created, the following partitions
	are created automatically:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>/boot</emphasis>
	  </para>
	  <para>
	    The size of the <emphasis>/boot</emphasis> partition is determined
	    by the architecture of the target system.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>swap</emphasis>
	  </para>
	  <para>
	    The size of the <emphasis>swap</emphasis> partition is determined
	    by the amount of memory available in the system.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>/</emphasis> (root partition)
	  </para>
	  <para>
	    The size of the root partition is determined by the space left
	    after creating <emphasis>swap</emphasis> and
	    <emphasis>/boot</emphasis>.
	  </para>
	</listitem>
      </itemizedlist>
      
      <para>
	Depending on the initial status of the drive and how it was
	previously partitioned, it is possible to create the <emphasis>default</emphasis>
	partitioning in the following ways:
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    <emphasis>Use free space</emphasis>
	  </para>
	  <para>
	    If the drive is already partitioned, it is possible to create the
	    new partitions using the free space on the hard drive. This
	    requires the availability of enough space for all selected
	    packages in addition to swap.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Reuse all available space</emphasis>
	  </para>
	  <para>
	    Use this option to delete all existing
	    partitions (Linux and non-Linux).

	  </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Reuse all available Linux partitions</emphasis>
	  </para>
	  <para>
	    This option deletes all existing Linux partitions. Other
	    partitions (i.e. Windows) remain untouched. Note that this works
	    only if the Linux partitions are at the end of the device.
	   </para>
	</listitem>

	<listitem>
	  <para>
	    <emphasis>Reuse only specified partitions</emphasis>
	  </para>
	  <para>
	    This option allows you to select specific partitions to delete.
	    Start the selection with the last available partition.
	  </para>
	</listitem>
      </itemizedlist>
      <para>
	Repartitioning only works if the selected partitions are neighbors and
	located at the end of the device.
      </para>

      <caution>
	<title>Important Notice</title>
	<para>
	  The value provided in the <emphasis>use</emphasis> property
	  determines how existing data and partitions are treated. The value
	  <emphasis>all</emphasis> means that <emphasis>ALL</emphasis> data on
	  the disk will be erased. Make backups and use the
	  <emphasis>confirm</emphasis> property if you are going to keep some
	  partitions with important data. During automated installation,
	  no popups will notify you about partitions being deleted.
	</para>
      </caution>
      <para>	
	If multiple drives are present in the target system, identify all
	drives with their device names and specify how the partitioning should
	be performed.
      </para>

      <para>
	Partition sizes can be given in gigabytes, megabytes or can be set to
	a flexible value using the keywords <emphasis>auto</emphasis> and
	<emphasis>max</emphasis>. <emphasis>max</emphasis> uses all available
	space on a drive, therefore should only be set for the last partition
	on the drive. With <emphasis>auto</emphasis> the size of a
	<emphasis>swap</emphasis> or <emphasis>boot</emphasis> partition is
	determined automatically, depending on the memory available and the
	type of the system.
      </para>
      <para>A fixed size can be given as shown below:</para>
      <para>
	<emphasis>1GB</emphasis> will create a partition of the size 1 GB.
	<emphasis>1500MB</emphasis> will create a partition of the size 1.5 GB.
      </para>
      <example>
	<title>Automated Partitioning</title>
	<para>
	  The following is an example of a single drive system, which is not
	  pre-partitioned and should be automatically partitioned according to
	  the described pre-defined partition plan. If you do not specify the
	  device, it will be automatically detected. You do not have to create
	  different profiles for /dev/sda or /dev/hda systems.
	</para>
	<screen><xi:include href="examples/example.partitioning.xml" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
	</example>
  <para>
    A more detailed example shows how existing partitions and
    multiple drives are handled.
  </para>
  <example>
    <title>Detailed Automated Partitioning</title>
    <screen><xi:include href="examples/example.partitioning2.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
	</example>
    </section>

  <section>
    <title>Advanced Partitioning Features</title>
    <section>
      <title>Wipe out Partition Table</title>
      <para>
        In most cases this is not needed because &ay; can delete partitions
        one by one automatically, but you have the option to let &ay; clear
        the partition table instead of deleting partitions individually.
      </para>
      <para>
        Go to the "drive" section and add:
      </para>
        <screen><![CDATA[<initialize config:type="boolean">true</initialize>]]></screen>
<para> With this setting &ay; will delete the partition table before it starts
to analyse the actual partitioning and calculates its partition plan. Of
course this means, that you cannot keep any of your existing
partitions.</para>
    </section>
    <section>
      <title>Mount Options</title>
      <para>
	By default a file system to be mounted is identified in
	<filename>/etc/fstab</filename> by the device name. This
	identification can be changed so the file system is found by searching
	for a <acronym>UUID</acronym> or a volume label. Note that not all
	file systems can be mounted by <acronym>UUID</acronym> or a volume
	label. To specify how a partition is to be mounted, use the
	<emphasis>mountby</emphasis> property which has the
	<emphasis>symbol</emphasis> type. Possible options are:
      </para>
      <itemizedlist>
	<listitem>
	  <para>device (default),</para>
	</listitem>
	<listitem>
	  <para>label,</para>
	</listitem>
	<listitem>
	  <para>UUID.</para>
	</listitem>
      </itemizedlist>
      <para>
	If you choose to mount the partition using a label, the name
	entered for the <emphasis>label</emphasis> property is used as the
	volume label. 
      </para>
      <para>
	Add any legal mount option in the fourth field of
	<filename>/etc/fstab</filename>. Multiple options are separated by commas. Possible fstab options:
      </para>
      <itemizedlist>
	<listitem>
	  <para><emphasis>Mount read-only (ro):</emphasis> No write
	    access to the file system. Default is "false".</para>
	</listitem>
	<listitem>
	  <para><emphasis>No access time (noatime):</emphasis> Access times
	    are not updated when a file is read. Default is "false".</para>
	</listitem>
	<listitem>
	  <para><emphasis>Mountable by User (user):</emphasis> The file
	    system can be mounted by a normal user. Default is
	    "false".</para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Data Journaling Mode (ordered, journal,
	    writeback):</emphasis> Specifies the journaling mode for file
	    data. </para> 
	 <variablelist>
          <varlistentry>
           <term>journal</term>
	<listitem><para>All data is committed to the
	journal prior to being written to the main file system.
</para>	</listitem>
          </varlistentry>
	<varlistentry>
         <term>ordered</term>
         <listitem><para>All data is
	    directly written to the main file system before its meta data is
	    committed to the journal.</para>
	</listitem>
        </varlistentry>
        <varlistentry>
         <term>writeback</term>
         
         <listitem>
          <para>Data ordering is not
          preserved.</para>
         </listitem>
	</varlistentry>
         </variablelist>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Access Control List (acl):</emphasis> Enable access
	    control lists on the file system.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Extended User Attributes (user_xattr):</emphasis> Allow
	    extended user attributes on the file system.
	  </para>
	</listitem>
	
      </itemizedlist>
      <example>
	<title>Mount Options</title>

	<screen><xi:include href="examples/example.mountoptions.xml" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
      </example>
    </section>
    
    <section>
      <title>Keeping Specific Partitions</title>
      <para>
	In some cases you may want to leave partitions untouched and only
	format specific target partitions, rather than creating them from
	scratch. For example, if different Linux installations coexist, or you
	have another operating system installed, likely you do not want to
	wipe these out. Or you may want to leave data partitions untouched.
      </para>
      <para>
	Such scenarios require certain knowledge about the target systems
	and hard drives. Depending on the scenario, you might need to know
	the exact partition table of the target hard drive with partition
	ids, sizes and numbers. With this data you can tell &ay; to
	keep certain partitions, format others and create new partitions if 
	needed.
      </para>
      <para>
	The following example will keep partitions 1, 2 and 5 and delete
	partition 6 to create two new partitions. All remaining partitions will
	only be formatted.<remark>emap 2011-11-05: Not the best example for the scenarios two paras up with coexisting operating systems or data partitions. Who'd want to format those?</remark>
      </para>
    <example>
      <title>
	Keeping partitions
      </title>	   	    
      <screen><xi:include href="examples/example.keepingpart.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
    </example>
    <para>
	The last example requires exact knowledge of the existing partition
	table and the partition numbers of those partitions that
	should be kept. In some cases however, such data may not be
	available, especially in a mixed hardware environment with
	different hard drive types and configurations. The following
	scenario is for a system with a non-Linux OS with a designated
	area for a Linux installation.     
      </para>
      <figure id="partitioning-keep1">
	<title id="partitioning-keep1.title" >Keeping partitions</title>
	<mediaobject>&partitioning-keep1;</mediaobject>
      </figure>

      <para>
	In this scenario, shown in  figure <quote><xref
	    linkend='partitioning-keep1'
	    endterm="partitioning-keep1.title"/></quote>, &ay;
	will not create new partitions. Instead it searches for certain partition types on the system and uses
	them according to the partitioning plan in the control file. No
	partition numbers are given in this case, only the mount points and
	the partition types (additional configuration data can be provided,
	for example file system options, encryption and filesystem type).
      </para>
  <example>
    <title> Auto-detection of partitions to be kept.</title>
    <screen><xi:include href="examples/example.autodetectpart.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
  </example>
    </section>	
  </section>

  <section>
    <title>Using Existing Mount Table (fstab)</title>
    <note>
      <title>New Feature</title>
    <para>
      This option will allow &ay; to use an existing
      <filename>/etc/fstab</filename> and use the partition data from
      a previous installation. All partitions are kept and no new
      partitions are created. The partitions will be formatted and
      mounted as specified in <filename>/etc/fstab</filename> on a
      Linux root partition.
    </para>
      </note>
    <para>
      Although the default behaviour is to format all partitions, it is
      also possible to leave some partitions untouched and only mount them,
      for example data partitions. If multiple installations are found on
      the system (multiple root partitions with different
      <emphasis>fstab</emphasis> files, the installation will abort, unless
      the root partition is configured in the control file. The
      following example illustrates how this option can be used:
    </para>
    <example>
      <title>
	Reading existing <filename>/etc/fstab</filename>
      </title>
      <screen><xi:include href="examples/example.fstab.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
	</example>
  </section>

  <section>
    <title>
      Logical Volume Manager (LVM)
    </title>
    <para>
      To configure LVM, first create a <emphasis>physical volume</emphasis> using the
      normal partitioning method described above. 
    </para>
    <example>
      <title>
	Create LVM Physical Volume
      </title>
      <para>
	The following example shows how to prepare for LVM in the
	<emphasis>partitioning</emphasis> resource:
      </para>
      <screen><xi:include href="examples/example.lvmvolume.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>

    </example>
    <para>
      In the last example, a non-formatted partition is created on device
      <filename>/dev/sda1</filename> of the type <emphasis>LVM</emphasis> and
      with the volume group <emphasis>system</emphasis>. This partition
      will use all space available on the drive.
    </para>
	<example>
	  <title>
	    LVM Logical Volumes (New syntax)
	  </title>
	  <screen><xi:include href="examples/example.lvmnew.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
	</example>
    <para>
      With SUSE Linux 10.1 and all following versions, it is possible to set the <emphasis>size</emphasis> 
      to <emphasis>max</emphasis> for the logical volumes. Of course, you can only use <emphasis>max</emphasis>
      for one(!) logical volume. You cannot set two logical volumes in one volume group to 
      <emphasis>size</emphasis> <emphasis>max</emphasis>
    </para>
  </section>

  <section>
    <title>
      Enterprise Volume Management System (EVMS) &mdash; SLES10 only!
    </title>
    <para>
      SLES10 &ay; has EVMS support. SLES11 has not!
    </para>
    <para>
      Using EVMS is quite similar to using LVM (see above). Switching from LVM to EVMS
      is just a small change in the &ay; profile. Change the
      "is_lvm_vg" element to "is_evms_vg" and the "lvm_group" element to "evms_group".
    </para>
    <para>
      With &ay; it is not possible to mix LVM and EVMS.
    </para>
    <para>
      Using the LVM example from above for EVMS, looks like this:
    </para>
    <example>
      <title>
        EVMS Logical Volumes
      </title>
      <screen><xi:include href="examples/example.evms.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
    </example>
  </section>
  <section>
    <title>Software RAID</title>
    <para>
      Using &ay;, you can create and assemble software RAID devices. The
      supported RAID levels are the following:
    </para>
    <itemizedlist>
      <listitem>	  
	<para>
	  <emphasis>RAID 0:</emphasis> This level increases your disk performance.
	  There is <emphasis>no</emphasis> redundancy in this mode. If one
	  of the drives crashes, data recovery will not be possible.

	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>RAID 1:</emphasis>This mode offers the best redundancy. It
	  can be used with two or more disks. An exact copy of all data is
	  maintained on all disks. As long as at least one disk is still
	  working, no data is lost. The partitions used for this type of RAID
	  should have approximately the same size.
	</para>
      </listitem>

      <listitem>
	<para>
	  <emphasis>RAID 5:</emphasis> This mode combines management of a
	  larger number of disks and still maintains some redundancy. This
	  mode can be used on three disks or more.  If one disk fails, all
	  data is still intact. If two disks fail simultaneously, all data is
	  lost.<remark>emap 2011-11-05: Really all data is lost, although
	  there are three or more disks?</remark>
	</para>	  
      </listitem>
      <listitem>
	<para>
	  <emphasis>Multipath:</emphasis>This mode allows access to the same
	  physical device via multiple controllers for redundancy against a
	  fault in a controller card. This mode can be used with at least two
	  devices.
	</para>
      </listitem>
    </itemizedlist>
    <para>
      As with LVM, you need to create all <emphasis><acronym>RAID</acronym></emphasis> partitions first and assign
      the partitions to the <acronym>RAID</acronym> device you want to
      create. Additionally you need to specify whether a partition or a device should be configured in the
      <acronym>RAID</acronym>  or if it should be configured as a <emphasis>Spare</emphasis> device.
    </para>
    <para>
      The following example shows a simple RAID1 configuration:
    </para>
  

  	<example>
	  <title>RAID1 configuration</title>
      <screen><xi:include href="examples/example.raidnew.xml" parse="text"
    xmlns:xi="http://www.w3.org/2001/XInclude"/></screen>
	  </example>


    <para>
      Consider the following when configuring raid:
    </para>
    <itemizedlist>
      <listitem>
	<para>The device for raid is always <emphasis>/dev/md</emphasis></para>
      </listitem>
      <listitem>
	<para>The property <emphasis>partition_nr</emphasis> is used to
	  determine the MD device number. If
	  <emphasis>partition_nr</emphasis> is equal to 0, then
	  <emphasis>/dev/md0</emphasis> is configured.</para>	   
      </listitem>
      <listitem>
	<para>All RAID-specific options are contained in the
	  <emphasis>raid_options</emphasis> resource.</para>
      </listitem>
    </itemizedlist>



  </section>

  <xi:include href="Partitioning_zSeries.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
  </section>      

