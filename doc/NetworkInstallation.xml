<chapter id="Bootmanagement">
  <title>Network Based Installation</title>        
  <para>
    The installation method using AutoYaST provides a way to automatically
    and identically install groups of systems. The first step when preparing
    AutoYaST installations is deciding how you want the systems at your
    site to be installed. For example, the following scenario would be ideal to
    set up and perform automated installations:
  </para>
  <itemizedlist>
    <listitem>
      <para>
	You need to install SuSE Linux on 50 new systems.
      </para>
    </listitem>
    <listitem>
      <para>
	The development department owns 30 out of the 50 new dual processor
	and SCSI systems, and its systems must be installed as clients with
	development software.
      </para>
    </listitem>
    <listitem>
      <para>
	The sales department owns 20 out of the 50 new, uni-processor IDE
	based systems and its systems must be installed as clients with end user
	software and office tools.
      </para>
    </listitem>
  </itemizedlist>
  
  <para>
    Prerequisites:
  </para>
  <itemizedlist>
    <listitem>
      <para>A boot server on the same ethernet segment</para>
    </listitem>
    <listitem>
      <para>An install server with the SuSE Linux OS</para>
    </listitem>
    <listitem>
      <para>An AutoYaST configuration server that defines rules and profiles.</para>
    </listitem>
  </itemizedlist>
    
    <section>
	<title>
	  Boot Server
	</title>
	<para>
	  The boot server is composed of DHCP or BOOTP  and tftp servers. In
	  some cases the boot server has to be in the same network segment as
	  the client due to the fact that DHCP or TFTP packets will not be
	  forwarded across a router.	  
	</para>
 
      <para>
	For administrative purposes, booting from a network card (NIC) is much more
	flexible than booting from a floppy or other types of media. In order to use this boot method,
	the client's NIC needs to have a boot PROM that is able to communicate with a
	&dhcp; or BOOTP  server to receive  configuration parameters
	such as network addresses and boot server location.
      </para>
      <para>	
	<ulink url="http://etherboot.sourceforge.net/">Etherboot</ulink> and
	<ulink url="http://www.han.de/~gero/netboot.html">netboot</ulink>
	are capable of creating a PROM  binary (which must still be programmed onto a PROM) and a
	corresponding "tagged" TFTP boot image which includes a kernel and
	an initial ramdisk. Some tools exist that help test a boot PROM
	image, in fact the support utilities are pretty much common to both
	etherboot and netboot. 
      </para>
      <para>	  
	An alternative to etherboot and netboot is a PXE-compliant
	  boot PROM.  <acronym>PXE</acronym> (Pre-boot Execution Environment) is a protocol
	designed by Intel that allows computers to boot through the
	  network. <acronym>PXE</acronym> is stored in the ROM of new generation network
	  cards. When the computer boots up, the BIOS loads the<acronym> PXE</acronym> ROM in
	the memory and executes it. A menu can be displayed, allowing the
	computer to boot an operating system loaded through the
	network.
      </para>
      <para>
	To install a client via Pre-Boot Execution Environment (&pxe;) you
	don't need a &pxe; server! &pxe; sends a &bootp; request to get an IP
	address and other network information and a bootloader program to the
	client. You can either use a &bootp; server or a &dhcp;
	and &tftp; server.
      </para>
      <para>
	The following sections describe  how &dhcp;
	and &tftp; should be setup to make a &pxe; based installation possible.
      </para>



      <section>
	<title>DHCP</title>
	<para>
	  Install the &dhcp; server from ISC (http://www.isc.org/) by
	  using the package available in the &company-suse; distribution. Configure
	  the &dhcp; server parameter in
	  <filename>/etc/sysconfig/dhcpd</filename> and make sure you have a
	  working configuration file <filename>/etc/dhcpd.conf</filename>.
	</para>
      </section>


      <section>
	<title>PXE Bootloader</title>

	<para>
	  PXE can load a program into the client's memory and start it. The
	  bootloader then loads its configuration file via  TFTP from the the server defined in
	  <emphasis>next-server</emphasis> (in the<filename>
	    dhcpd.conf</filename> file example above).	 
	</para>

	<para>
	  The bootloader configuration file determines whether a client boots
	  from its local hard disk or over the network.
	</para>
	<para>
	  Here are example configuration files for both cases:
	</para>
	<example>
	  <title>Configuration file for PXELINUX net boot</title>
	  <programlisting>
default linux
serial 0,9600n8
label linux
  kernel linux
  append console=ttyS0,9800 console=tty0 load_ramdisk=1  initrd=initrd  autoyast=nfs://nfsserv/file.xml
	  </programlisting>
	</example>

	

	<para>Boot from local hard disk (filename default):</para>
	<example>
	  <title>Configuration file for PXELINUX local boot</title>
	  <programlisting>
default linux
label linux
  localboot 0
  </programlisting>
	</example>

	<para>
	  <filename>pxelinux.0</filename> tries to read several configuration files. It uses
	  the first one it finds. The filenames it looks for are determined
	  by the IP address of the client it is running on. It converts the
	  four decimal number parts of an IP address (they are devided by
	  dots) into hexadecimal numbers and concatenates them. Example: IP
	  address 192.168.0.11 gets converted into C0 A8 00 0B (without the
	  spaces).
	</para>
	<para>The search for files starts at<emphasis> C0A8000B</emphasis> and proceeds by
	  removing one digit from the right (leaving<emphasis> C0A8000</emphasis>) and so
	  forth. When all digits are removed it will try as last resort the
	  filename default.
	</para>
	<para>On your TFTP server, this algorithm can be used to tell each single machine how to boot:</para>
	<example>
	  <title>PXELINUX Configuration</title>
	  <programlisting>
/tftpboot/pxelinux.cfg/
                   C0A8000B -> default.netboot-8.0    
                   C0A8000C -> default.netboot-8.1    
                   default.netboot-8.0
                   default.netboot-8.1
                   default
	  </programlisting>
	</example>
	<para>
	  This is important if you install a lot of machines at the same
	  time. You can watch the syslog file on your TFTP server and
	  whenever a client got its initial RAM disk transmitted, you can
	  remove the symlink for that machine from the<filename> pxelinux.cfg</filename>
	  directory. This forces the client to load the default configuration
	  which says: "Boot from local disk!" when it reboots after AutoYaST
	  is done.
	</para>	  

      </section>


      <section>
	<title>TFTP</title>
	<para>PXE requires a special TFTP server. Read
	  <filename>pxelinux.doc</filename> from the already mentioned syslinux
	  package for details.</para>


	<para>
	  The inetd based TFTP server  cannot reliably handle much more
	  than 64 clients at a time! With more clients not all of them will
	  get an answer from your TFTP and you will see syslog messages like
	  this: 
	</para>
	<screen>
tftpd: read: Connection refused.
	</screen>
	  <para>
	    To overcome this problem you can  use <emphasis>atftp</emphasis>
	    which is available as a package.   This TFTP server can run as
	    stand-alone daemon.
	  </para>
	  <para>
	  The TFTP server directory <filename>/tftpboot</filename> should look like this:
	  </para>
	  
	  <example>
	    <title>Tftpboot dir contents</title>
	  <programlisting>
/tftpboot/initrd     
          pxelinux.0
          linux    
	  </programlisting></example>

	<para>
	  See next section for how to get the files
	  <filename>linux</filename> and <filename>initrd</filename>.
	</para>
	
      </section>



      <section>
	<title>Kernel and Initial Ramdisk</title>
	<para>
	  For network booting and other configurations, it is recommended to
	  use the images available on every &company-suse; CD-ROM in the directory
	  <filename>/suse/images/boot</filename>. The initial ramdisk
	  (initrd) contains all kernel modules needed for successful
	  installation. In special cases, you might need to build you own
	  kernel or use special kernels available on the CD-ROM. 
	</para>
      </section>


      <section>
	<title>
	  &bootp;/&dhcp; Options
	</title>
    
	<para>
	  To allow the specification of the source media location when booting
	  over the network,  <emphasis>root-path</emphasis> options of   &dhcp;   can be used.	 
	</para>
	<example>
	  <title>
	    <filename>/etc/dhcpd.conf</filename> with the <emphasis>root-path</emphasis> option
	  </title>
	  <screen>
subnet 192.168.1.0 netmask 255.255.255.0 
{
      range dynamic-bootp 192.168.1.100 192.168.1.110;
      option broadcast-address 192.168.1.255;
      option routers 192.168.1.1;
      filename "vmlinuz.nbi";
      option root-path "/tftpboot/CDs";
	
      next-server 192.168.1.1; 
}
	  </screen>
	</example>
	<para> 
	  One more example shows how the  &dhcp;  server can send an image to the
	  client, depending on the type of the requesting client (PXE or
	  Etherboot).
	</para>
	<example>
	  <title> &dhcp;  server configuration with PXE and Etherboot options</title>
	  <screen>
ddns-update-style none;
allow bootp;
allow booting;


subnet 192.168.1.0 netmask 255.255.255.0 {
  range dynamic-bootp 192.168.1.100 192.168.1.110;
  option domain-name "cluster.suse.de";
  option routers 192.168.1.240;
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.1.255;
  filename "vmlinuz-node.nbi";
  option root-path "/local/CD1";
}


group {
    next-server 192.168.1.240;
    use-host-decl-names on;

    host n1 {
        hardware ethernet 00:00:1c:b5:6e:71;
        fixed-address n1;
        if substring (option vendor-class-identifier, 0, 9) = "PXEClient" {
            filename "/tulip.lzpxe";
        } else if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
            filename "/vmlinuz-node.nbi";
        }
    }
    host n2 {
        hardware ethernet 00:00:1c:b5:72:ea;
        fixed-address n2;
        if substring (option vendor-class-identifier, 0, 9) = "PXEClient" {
            filename "pxelinux.0";
        } else if substring (option vendor-class-identifier, 0, 9) = "Etherboot" {
            filename "/vmlinuz-node.nbi";
        }
    }
}
	
	  </screen>      
	  </example>

	</section>

      </section>




</chapter>








      <!--
       Local Variables:
       mode: xml
       sgml-parent-document: ("autoyast2.xml" "book" "chapter")
       End:
      -->