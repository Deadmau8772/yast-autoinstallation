
<chapter>
    <title>Rules and Classes</title>
  <section>
    <title>Rule based auto-installation</title>
    <para>
      Rules offer the possibility to configure a system depending on system
      attributes by merging multiple control file during installation. The
      rules based installation is guided by the rules file.
    </para>
    <para>
      The rules file is an XML based file that contains
      rules for each group of systems (or single systems) that you want to
      automatically install. A set of rules distinguish a group of systems based on
      one or more system attributes, after passing all rules, it links each
      group of rules to a profile. Both the rules file and the profiles must be
      located in a pre-defined and accessable location.
    </para>
    <figure id="rules_fig1">
      <title id="rules_fig1.title" >Rules</title>
      <mediaobject>&rules;</mediaobject>
    </figure>
    <para>
      If more than one rule apply, the final profile for each group is generated
      on the fly using a merge script. The merging process is based on the
      order of the rules and later rules override configuration data in earlier rules.
    </para>
    <para>
      The use of  a rules file is optional. If the rules file is not found,
      system installation proceeds in the 
      classic way by just using the supplied profile or by searching for the
      profile depending on the <emphasis>MAC</emphasis> or the
      <emphasis>IP</emphasis> address of 
      the system.     
    </para>
<!--
    <para>
      In the previous scenario, you would create a rules file with two different
      rules, one rule for the development and another rule for the sales
      department. For each rule, you could use different system parameters to
      distinguish the groups from one another: the development department has SMP
      and SCI  based systems and the sales group has IDE based systems. Each rule
      would also contain a link to an appropriate profile. For example, in the
      rule for the development department, you would add a link to the profile, called
      <filename>devel.xml</filename>, that you created for this department. And, in the rule
      for the sales department, you would add a link to the profile, called
      <filename>sales.xml</filename>, that you created for the sales department.
    </para>
-->

    <section>
      <title>Rules File explained</title>
   
      <example>
	<title>
	  Simple rules file
	</title>		

	<para>
	  The following simple example illustrates how the rules file is used
	  to retrieve the configuration for a client with known hardware.
	</para>
	<screen>
<![CDATA[
<?xml version="1.0"?>
<!DOCTYPE autoinstall SYSTEM "/usr/share/YaST2/include/autoinstall/profiles.dtd">
<autoinstall xmlns="http://www.suse.com/1.0/yast2ns" xmlns:config="http://www.suse.com/1.0/configns">
  <rules config:type="list">
    <rule>
       <disksize>
            <match>/dev/hdc 1000</match>
            <match_type>greater</match_type>
       </disksize>
       <result>
            <profile>machine1.xml</profile>
            <continue config:type="boolean">false</continue>
        </result>
    </rule>
    <rule>
       <disksize>
            <match>/dev/hda 1000</match>
            <match_type>greater</match_type>
       </disksize>
       <result>
            <profile>machine2.xml</profile>
            <continue config:type="boolean">false</continue>
        </result>
    </rule>
  </rules>
</autoinstall>
]]>
	    </screen>

	  </example>	 
      <para>
	The last example defines 2 rules and provides a differes profile for
	every rule. The rule used in this case is
	<emphasis>disksize</emphasis>. After parsing the rules file, &yast2;
	attempts to match the system being installed to the rules in the 
	<filename>rules.xml</filename> file in order: first rule through the
	last rule. A rule match occurs when the system being installed matches
	all of the system attributes defined in the rule. As soon as a system
	matches a rule, the result resource is added to the
	stack of profiles &autoyast; will be using to create the final
	profile.  The <emphasis>continue</emphasis> property tells &autoyast; if it should
	continue with other rules or not. 
      </para>
      <para>
	If the first rule does not match,  next rule in the list is examined
	until a match is found.
      </para>
      <para>
	Using the <emphasis>disksize</emphasis> attribute, you can
	provide different configurations for different hard drives with
	different size. First rule checks if the device
	<emphasis>/dev/hdc</emphasis> is available and if it is greater than 1
	GB in size using the <emphasis>match</emphasis> property. 
      </para>
    
      <para>
	A rule must have at least one attribute to be matched. If you need
	to check more attributes, i.e. memory or architectures, you can add
	more attributes  the rule resource as shown in the next example.
      </para>
    </section>
      <section>
	<title>Rules file structure</title>
	<para>
	  The <filename>rules.xml</filename> file must have:	  
	</para>
	<itemizedlist>
	  <listitem>
	    <para>At least one rule</para>
	  </listitem>
	  <listitem>
	    <para>It must have the name <filename>rules.xml</filename></para>
	  </listitem>
	  <listitem>
	    <para>It must be located in the directory
	      <emphasis>rules</emphasis> in the profile repository</para>
	  </listitem>

	  <listitem>
	    <para>At least one attribute to match in the rule</para>
	  </listitem>
	</itemizedlist>
    </section>
  
 
  </section>
  
  <section>
    <title>Classes</title>
    <para/>
  </section>

  <section>
    <title>Mixing Rules and Classes</title>
    <para/>
  </section>
</chapter>

      <!--
       Local Variables:
       mode: xml
       sgml-parent-document: ("autoyast2.xml" "book" "chapter")
       End:
      -->
