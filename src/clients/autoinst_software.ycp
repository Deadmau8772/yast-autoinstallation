/**
 * File:	clients/autoinst_software.ycp
 * Package:	Autoinstallation Configuration System
 * Authors:	Anas Nashif (nashif@suse.de)
 * Summary:	Handle Package selections and packages
 *
 * $Id$
 */
{

    textdomain "autoinst";
    import "Mode";
    Mode::config = true;


    import "Wizard";
    import "Summary";
    import "Report";
    include "wizard/sequencer.ycp";
    include "ui/common_messages.ycp";
    include "autoinstall/dialogs.ycp";
    

    list args = WFM::Args ();

    if ( size (args) <= 0 )
    {
	y2error ("Did not get the settings, probably some mistake...");
	return false;
    }
    if ( !is ( WFM::Args (0), map ) )
    {
	y2error ("Bad argument: %1", WFM::Args (0));
	return false;
    }

    map settings = $[];
    {
	integer i = 0;
	while (i < size (WFM::Args()))
	{
	    if (is (WFM::Args (i), map) && nil != WFM::Args (i))	settings = WFM::Args (i);

	    i = i + 1;
	}
    }




    string base = settings["base"]:"Custom";

    list addons = settings["addons"]:[];

    list pacs = settings["packages"]:[];

    map software = settings;     
    
    /**
     * @return Html formatted configuration summary
     */
    define string Summary()``{
	string summary = "";
	
	summary = Summary::AddHeader(summary, _("Base Selection"));
	summary = Summary::AddLine(summary, (base != "") ?
				   software["base"]:"None" : Summary::NotConfigured());
	summary = Summary::AddHeader(summary, _("Add-on Selections"));
	
	if (size( software["addons"]:[])>0)
	{
	    summary = Summary::OpenList(summary);
	    foreach(`a, software["addons"]:[], ``{
		summary = Summary::AddListItem(summary, a);
	    });
	    summary = Summary::CloseList(summary);
	}
	else
	{
	    summary = Summary::AddLine(summary, Summary::NotConfigured());
	}
	summary = Summary::AddHeader(summary, _("Individualy selected Packages"));
	summary = Summary::AddLine(summary, sformat("%1", size(software["packages"]:[])));

	return summary;
    }





    define packageSelector() ``{
	string language = UI::GetLanguage(true);

	// Wizard::CreateDialog();

	// Dialog title for software selection
	string title = _("Software Selection");
	string helptext = _("<p>
TODO
</p>
");

	Wizard::SetContents(title,
			    `HVCenter(`Label(_("Reading package database..."))),
			    helptext, false, true);
	

	
	list available_base_selections = Pkg::GetSelections( `available, "base" );
	
	y2milestone("AVAILABLE Selections: %1",  available_base_selections);
	
	// Construct a box with radiobuttons for each software base configuration
	term baseconfs_box = `VBox();

	// sort available_base_selections by order
	// $[ "order" : [ "name", "summary" ], .... ]

	map sorted_base_selections = $[];
	foreach( `selection, available_base_selections,
		 ``{
	    map selection_data = Pkg::SelectionData (selection);
	    if (selection_data != nil)
	    {
		string order = selection_data["order"]:"";
		// use selection name as sort criteria if not given
		if (order == "")
		    order = selection;
		sorted_base_selections[order] = [selection, selection_data["summary"]:("'"+selection+"'")];
	    }
	});

	// construct display box in order
	foreach(`order, `data, sorted_base_selections,
		``{
	    {
		baseconfs_box = add( baseconfs_box, `Left(`RadioButton(`id(data[0]:""),     // id
								       `opt(`notify, `autoShortcut),
								       data[1]:"",              // descrption
								       (data[0]:"" == base)   )));
	    }
	});

	term contents = `HVSquash(
				  `VBox(
					`HSquash(
						 `VBox(
						       `Frame(
							      // Frame caption for software selection
							      _("Software"),
							      `VBox(
								    `VSpacing(0.3),
								    `RadioButtonGroup(`id(`baseconf),`opt(`notify), baseconfs_box),
								    `VSpacing(0.3)
								    )
							      ),
						       `VSpacing(),

						       // Push button that will pop up the detailed
						       // software selection (e.g. Multimedia, Games,
						       // KDE, Gnome, ... - not the individual packages!)
						       `PushButton( `id(`details),  _("&Detailed selection...") )
						       )
						 )
					)
				  );

	Wizard::SetContents(title, contents, helptext, true, true);
	any ret = nil;
	boolean error_found = false;

	repeat
	    {

		ret = Wizard::UserInput();

		// get the newly selected base configuration
		string base_selection = UI::QueryWidget( `id(`baseconf),`CurrentButton );

		// Inform the package manager on `next about the new (only about a NEW) selection
		// or if the selection has changed

		if (ret == `next)
		{
		    // set the new selection
		    boolean pkgret = Pkg::SetSelection( base_selection );
		    /*
		    if (size(pacs)>0)
		    {
			Pkg::DoProvide(pacs);
		    }
		    */
		    y2milestone ( "Selecting '%1' returns: %2", base_selection, pkgret );

		    pkgret = Pkg::ActivateSelections();
		    y2milestone ("Pkg::ActivateSelections() returns %1", pkgret);


		}

		if ( ret == `details )
		{
		    any details_ret = `again;

		    if (save_selection != base_selection || size(Pkg::GetPackages(`selected, true)) == 0)
		    {
			boolean ret = Pkg::SetSelection( base_selection );
			/*
			if (size(pacs)>0)
			{
			    Pkg::DoProvide(pacs);
			}
			*/
			y2milestone ( "Selecting '%1' returns: %2", base_selection, ret );
			// activate current selection before entering package widget
			Pkg::ActivateSelections();			

		    }
		    while ( details_ret == `again )
		    {
			details_ret = WFM::CallFunction( `inst_packages( true, true ) );
			y2milestone("details_ret %1", details_ret);
		    }

		    if ( details_ret == `accept )
		    {
			ret = `next;
			Pkg::ActivateSelections();
			break;
		    }
		    else if ( details_ret == `cancel )
		    {
			ret = `cancel;
			break;
		    }
		    else if ( details_ret == `abort )
		    {
			ret = `abort;
			break;
		    }
		}

	    } until ( (ret == `next && !error_found) || ret == `cancel ||  ret == `back || ret == `abort);
	
	// list allpacs = Pkg::GetPackages(`selected, true);	
	list seladd =  Pkg::GetSelections(`selected, "");
	list selbase =  Pkg::GetSelections(`selected, "base");

	/*
	foreach(string selection , union(selbase, seladd),
		``{
	    Pkg::ClearSelection(selection);
	});
	
	Pkg::DoRemove (allpacs);
	
	Pkg::SetSelection(selbase[0]:"");
	
	foreach(string selection , seladd,
		``{
	    Pkg::SetSelection(selection);
	});
	Pkg::ActivateSelections();
	list onlysel = Pkg::GetPackages(`selected, true);
	y2milestone("selection packages: %1, all packages: %2", size(onlysel), size(allpacs));

	pacs = [];
	foreach(string package, allpacs, ``{
	    if (!contains(onlysel, package)) {
		pacs=add(pacs,package);
	    }
	});
	
	*/
	
	software["addons"] = seladd;
	software["base"] =   selbase[0]:"";
	software["packages"] = pacs;

	return ret;
    }


    define set_contents()
	``{	
	term contents =
	    `VBox(
		  `VSpacing(1),
		  `RichText( `id(`summary), Summary()),
		  `VSpacing(0.5),
		  `HBox(
			`PushButton(`id(`configure), _("&Configure")),
			`HStretch(),
			`PushButton(`id(`reset), _("Reset Co&nfiguration"))
			),
		  `VSpacing(1)
		  );
	Wizard::SetContents(_("Software"),
			    contents, "", true, true);
    }

    set_contents();
    any result = nil;
    any ret = nil;
    repeat {
	ret = UI::UserInput();
	if (ret == `configure)
	{	        	    
	    result =  packageSelector();
	    
	    if (result == `next || result == `finish)
	    {
		settings = software;
	    }
	    set_contents();
	}
	else if ( ret == `reset)
	{
	    settings = $[];
	    software = $[];
	    set_contents();
	}
    } until (ret == `back || ret == `next || ret ==`key  || ret == `abort);

    return [ret, settings];
}
