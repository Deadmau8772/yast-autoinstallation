/**
 * File:
 *   modules/AIClone.ycp
 *
 * Package:
 *   Autoinstallation Configuration System
 *
 * Summary:
 *   Create a control file from an exisiting machine
 *
 * Authors:
 *   Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 *
 */
{
    module "AIClone";
    import "Mode";
    import "XML";

    // Relative location of extra package to suse directory
    global string extraPackageLocation = "";

    // Add non-SuSE package
    global boolean add_extraPackages = true;


    global map Profile = $[];

    include "autoinstall/xml.ycp";


    integer bytes_per_unit = 0;
    /**
     * Constructor
     */
    global define void AIClone()``{
	Mode::normal = true;
	return;
    }


    define string findMountpoint(string device, map p, list mounts) ``{
	string mountPoint = "";
	foreach(map mount , mounts, ``{
	    string m = sformat("%1%2", device ,  p["nr"]:"");
	    if (mount["spec"]:"" ==  m )
	    {
		mountPoint = mount["file"]:"";
	    }
	});
	return mountPoint;
    }


    define units_to_size (list region) ``{
	integer units = select(region,1,0);
	return (units * bytes_per_unit)  -  bytes_per_unit + 1;
    };

    /**
     * Create a partition plan for the calling client
     * @return list partition plan
     */
    global define list Partitioning()``{
	Mode::config = false;
	import "Storage";
	map StorageMap = eval(Storage::GetTargetMap());

	StorageMap = Storage::GetFsysType(StorageMap);
	y2milestone("mmm %1", StorageMap);
	list mounts = SCR::Read(.etc.fstab);

	list drives = maplist(`k,`v, StorageMap, ``{
	    bytes_per_unit = v["cyl_size"]:1;

	    list p = maplist(`pe, v["partitions"]:[], ``{
		map new_pe = $[];
		if (haskey(pe,"fsid")) {
		    new_pe["partition_id"] = pe["fsid"]:131;
		}
		if (haskey(pe,"region")) {
		    new_pe["region"] = pe["region"]:[];
		    new_pe["size"] = units_to_size(pe["region"]:[]);
		}
		if (haskey(pe,"used_fs")) {
		    new_pe["filesystem"] = pe["used_fs"]:`reiser;
		}
		if (haskey(pe,"nr")) {
		    new_pe["partition_nr"] = pe["nr"]:0;
		}
		string mountPoint = findMountpoint(k, pe, mounts);
		if (mountPoint != "") {
		    new_pe["mount"] = mountPoint;
		}

		return (new_pe);
	    });
	    map drive = $[];
	    drive["partitions"]	= p;
	    drive["device"] 	= k;
	    drive["use"] 	= "all";

	    return drive;
	});
	Mode::config = true;
	return drives;
    }
    /**
     * Return list of software packages of calling client
     * @return list list of installed software package
     */

    global define map Software()``{
	import "Packages";
	Mode::config = false;
	Packages::Init(true);

	// map allInstalledPackages = SCR::Read(.package.packageList);
	
	
	list productPackages = [];
	// now find out which package are original SuSE package from an
	// official SuSE installation medium

	foreach(`p,`v, allInstalledPackages, ``{
	    if  (v[1]:"" == "i")
	    {
		productPackages = add(productPackages,p);
	    }
	});

	map software = $[];
	software["packages"] = productPackages;
	software["base"] = "Minimal";
	Mode::config = true;
	return software;
    }

    /**
     * Bootloader options
     */
    global define map Bootloader()``{
	import "Boot";
	map bootloader = $[];
	bootloader["location"] = Misc::SysconfigRead(.sysconfig.bootloader.LOADER_LOCATION, "mbr" );

	if (Misc::SysconfigRead(.sysconfig.bootloader.LOADER_LOCATION, "" ) == "lilo" || Boot::LoaderType == "lilo") {
	    string lba = Misc::SysconfigRead(.sysconfig.bootloader.LILO_LBA, "no");
	    bootloader["lba_support"] = (lba == "yes")? true : false;
	    string activate = Misc::SysconfigRead(.sysconfig.bootloader.LILO_ACTIVATE, "no");
	    bootloader["activate"] = (activate == "yes")? true : false;
	    string linear = Misc::SysconfigRead(.sysconfig.bootloader.LILO_LINEAR, "no");
	    bootloader["linear"] = (linear == "yes")? true : false;
	}
	return bootloader;

    };

    /**
     * General options
     */

    global define map General() ``{
	import "Language";
	import "Keyboard";
	import "Mouse";
	import "Timezone";

	map general = $[];
	general["language"] = Misc::SysconfigRead(.sysconfig.language.DEFAULT_LANGUAGE, Language::language );
	map keyboard = $[];
	keyboard["keymap"]  = Misc::SysconfigRead(.sysconfig.keyboard.YAST2_KBD,  Keyboard::GetKeyboardForLanguage( Language::language, "en_US") );
	
	general["keyboard"] = keyboard;
	map clock = $[];
	clock["timezone"]   = Misc::SysconfigRead(.sysconfig.clock.TIMEZONE, Timezone::timezone );
	string hwclock = "";
	if ( size( Storage::GetWinPrimPartitions( Storage::GetTargetMap() ) ) > 0 )
	{
	    // Win partitions present ==> assume local time.
	    //
	    hwclock = "--localtime";
	    y2milestone("Assuming local time");
	}
	else
	{
	    // No Win partitions ==> assume UTC.
	    //
	    hwclock = "-u";
	    y2milestone("Assuming UTC");
	}
	string hwc 	    = Misc::SysconfigRead(.sysconfig.clock.HWCLOCK, hwclock);
	if (hwc == "--localtime")
	{
	    clock["hwclock"] = "localtime";
	}
	else if (hwc == "-u")
	{
	    clock["hwclock"] = "GMT";
	}
	else
	{
	    clock["hwclock"] = "";
	}	
	general["clock"]    = clock;
	
	map mouse = $[];
	mouse["id"]	    = Misc::SysconfigRead(.sysconfig.mouse.YAST_MOUSE, "probe" );
	general["mouse"]    = mouse;

	return general;
    }

    /**
     * Build the profile
     * @return map Profile
     */
    global define void constructProfile()
	``{
	map Install = $[];
	Install["partitioning"] = Partitioning();
	Install["software"] = Software();
	Install["general"] = General();
	Install["bootloader"] = Bootloader();
	Profile["install"] = Install;
	return;
    }



    /**
     * Write the profile to a defined path
     * @param outputFile Output file path
     * @return boolean true on success
     */
    global define boolean writeProfile(string outputFile)``{

	profileSetup();
	if (Profile == $[])
	    constructProfile();
	boolean ret =  XML::YCPToXMLFile(`profile, Profile, outputFile);
	return ret;
    }


    /**
     * Export profile, Used only from within CMS
     * @return void
     */
    global define void exportProfile()``{
	import "AIConfig";
	constructProfile();
	AIConfig::Import(Profile);
	return;
    }
}
