/**
 * File:	modules/AutoInstall.ycp
 * Package:	Auto-installation
 * Summary:	Auto-installation related functions module
 * Author:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

    module "AutoInstall";
    textdomain "autoinst";
    
    import "Installation";
    import "Mode";
    import "Report";
    import "XML";
    import "X11Version";
    import "Language";


    include "autoinstall/io.ycp";


    // Main directory for data generated during installation
    //
    global string var_dir = "/var/adm/autoinstall";

    // Cache directory
    //    
    global string cache = var_dir + "/cache";

    // Temporary directory for storing profile before installation starts
    //
    global string tmpdir = SCR::Read( .target.tmpdir );

    // Temporary file name for retrieved system profile
    //
    global string xml_tmpfile = tmpdir + "/autoinst.xml";

    // Final location for retrieved system profile
    //
    global string xml_file = cache + "/installedSystem.xml";

    // Parsed data from XML control in YCP format
    //
    string parsedControlFile = cache + "/autoinst.ycp";

    // Direcotry for runtime operation data
    global string runtime_dir = "/var/lib/autoinstall";

 
    // Directory where copmlete configuration files are kept.
    //
    global string files_dir = var_dir + "/files";

    // Auto-Configuration mode
    //
    global boolean autoconf = false;

    // Parsed data to be used to set variables in other modules
    //////////////////////////////////////////////////////////////

    global boolean interactive = true;


    global map Profile = $[];


    
    // Bootloader
    global map Bootloader = $[];


    global map X11 = $[];

    


    global list loadKernelModules = [];
    global list configureKernelModules = [];

 


    // Modules

    global map GroupMap = $[];
    global map ModuleMap = $[];


    // Kernel
    global string Kernel = "";


    //////////////////////////////////////////////////////////////////////////////////////////////
    // Local variables
    /////////////////////////////////////////////////////////////////////////////////////////////

    // Sysconfig variable already registered
    // FIXME
    list registered_list = [];


    /**
     * Constructer
     *
     */
    global define void AutoInstall()
	``{
	if (!Mode::config &&  ! ( Mode::cont && Continue() ))
	{
	    if ( SCR::Read(.target.size, xml_tmpfile) != -1  && size ( Profile::current ) == 0)
	    {
		// Profile is available and it has not been parsed yet.
		Profile::Read(  xml_tmpfile );
	    }

	}

	if (Mode::cont && size ( Profile::current ) > 0)
	{
	    y2milestone("Enabling Auto-Installation mode");
	    Mode::autoinst = true;
	}

	// Read module configuration data (y2cc)
	if (Mode::config || ( Mode::cont &&  Mode::autoinst))
	{
	    list MenuEntries = ReadMenuEntries();
	    ModuleMap = select(MenuEntries,0,$[]);
	    GroupMap = select(MenuEntries,1,$[]);
	    y2debug("Modules: %1 , Groups: %2", ModuleMap, GroupMap);
	}

	
	return;
    }



    /**
     * Read saved data in continue mode
     */

    
    global define boolean Continue() ``{
	
	// First check if there are some other control files availabe
	// i.e. for post-installation only
	string autoconf_file = runtime_dir + "/autoconf/autoconf.xml";
	
	if ( SCR::Read(.target.size, autoconf_file) != -1 )
	{
	    y2milestone("XML Post installation data found: %1", autoconf_file );
	    autoconf = true;
	    Profile::Read(  autoconf_file  );
	    boolean ret = Profile::Read(  xml_tmpfile );
	    SCR::Execute(.target.bash, sformat("/bin/mv %1 %2", autoconf_file, cache));
	    return (ret);
	}
	else
	{
	    Profile::ReadYCP ( parsedControlFile );
	    if ( Profile::current == $[] )	// No saved data base.
	    {
		y2milestone( "No saved autoinstall data found" );
		return (false);
	    }
	    else	// saved data  found
	    {
		y2milestone( "Found and read saved autoinst data : <%1>", Profile::current );
		y2milestone("Removing old data: %1", SCR::Execute(.target.remove, parsedControlFile));
		Profile = Profile::current;
		return (true);
	    }
	}
	
	
    }

    
    /**
     * Parse profile and set some values
     *
     */
    global define boolean ProcessProfile()
	``{
		
	// FIXME    
	Report::Set(Profile::Flat["report"]:$[]);

	X11 = Profile::Flat["x11"]:$[];

	if (size(X11) == 0 || !X11["configure_x11"]:false)
	{
	    Mode::x11_setup_needed = false;
	}

	map Software = Profile::Flat["software"]:$[];

	postPackageList();

	return true;
    }




    /**
     * Configure bootloader settings
     * @param void
     * @return void
     */
    global define bootloaderSettings()``{

	Boot::manual_location = true;
	Bootloader = Profile::Flat["bootloader"]:$[];


	map toimport = $[];
	
	if (!issubstring(Bootloader["location"]:"mbr", "/dev/"))
	{
	    toimport["location"] = Bootloader["location"]:"mbr";
	}
	else
	{
	    toimport["loader_device"] = Bootloader["location"]:"mbr";	    
	}
	if (haskey(Bootloader, "loader_type"))
	    toimport["loader_type"] = Bootloader["loader_type"]:"grub";

	
	/**
	 * FIXEME
	string parameters = Bootloader["kernel_parameters"]:"";

	if ( size(parameters) > 0)
	{
	    foreach (`parameter, splitstring(parameters, " "),
		     ``{
		list param_value_list = splitstring (parameter, "=");

		// now only collect keys not in discardlist
		if (size (param_value_list) > 0)
		{
		    Kernel::AddCmdLine (param_value_list[0]:"", param_value_list[1]:"");
		}
	    });
	}

	// Lilo settings
	Boot::Set(
		  Bootloader["linear"]:false,
		  Bootloader["activate"]:false,
		  Bootloader["lba_support"]:false
		  );

	// Add initrd modules
	if (size(Bootloader["initrd_modules"]:[]) > 0)
	{
	    foreach(`m, Bootloader["initrd_modules"]:[],
		    ``{
		Boot::AddInitrdModule (m, "");
	    });
	}

	Boot::Set();
	*/

	Bootloader::Import(toimport);
    }

    /**
     * Return post package list
     * @return list post packages
     */
    global define  list postPackageList() ``{
	map Software = Profile::Flat["software"]:$[];
	list postPackages = Software["post-packages"]:[];

	y2milestone("Post packages: %1",  postPackages);
	return postPackages;
    }

    /**
     * Parse package list
     * @return list Packages
     */
    global define list packageList()``{
	map Software = Profile::Flat["software"]:$[];
	list Packages = Software["packages"]:[];
	return Packages;
    }


    /**
     * Configure software settings
     * @param void
     * @return boolean
     */
    global define boolean softwareSettings()
	``{
	boolean ok = true;
	boolean ret = false;
	// y2milestone("set Locale to %1", Language::language);
	Pkg::SetLocale (Language::language);

	Packages::Init(true);
	// Standard Packages
	boolean retval = false;

	map Software = Profile::Flat["software"]:$[];
	list addons = Software["addons"]:[];


	string  base_selection = Software["base"]:"Minimal";
	if (! Pkg::SetSelection( base_selection ))
	{
	    y2error("Error while setting base selection: %1", base_selection);
	    Report::Error(sformat(_("Could not set base selection: %1"), s));
	    return false;
	}

	foreach(`s, toset(addons),
		``{
	    if (!Pkg::SetSelection( s ))
	    {
		y2error("Error while setting-addon selection: %1", s);
		Report::Warning(sformat(_("Could not set add-on selection %1"), s));
	    }
	});

	// single selected packages

	if (!Pkg::ActivateSelections()) {
	    return false;
	}


	list extraPackages = calcExtraPackages ();
	y2milestone("Packages selected in autoinstall mode: %1", extraPackages);
	if (size(extraPackages) > 0 ) {
	    Pkg::DoProvide(extraPackages);
	}

	Pkg::DoProvide (Packages::ComputeSystemPackageList());
	Pkg::PkgSolve();


	SpaceCalculation::ShowPartitionWarning();
	y2milestone( "INSTALLING Software Selection: base(%1), addon(%2)",  Pkg::GetSelections(`selected, "base"), Pkg::GetSelections(`selected, ""));

	return (ok);
    }


    global define list calcExtraPackages () ``{

	map Software = Profile::Flat["software"]:$[];
	Kernel = Software["kernel"]:"";
	
	// single selected packages
	// FIXEME
	list  forcedPackages = [];
	list Packages = union(Software["packages"]:[], forcedPackages);
	
	if (Kernel!="") {
	    Packages=add(Packages,Kernel);
	}

	return Packages;

    }
    


    /**
     * Finalize autoinst settings
     * @param
     * @return void
     */

    /*
    global define void Finalize()
	``{

	sysconfigSettings();
	if (X11Version::have_x11())
	{
	    if (  X11["default_wm"]:"" != "") {
		SCR::Write (.sysconfig.windowmanager.DEFAULT_WM, X11["default_wm"]:"kde");
		SCR::Write (.sysconfig.windowmanager, nil);
	    }
	    if (  X11["display_manager"]:"" != "") {
		SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER, X11["display_manager"]:"kdm");
		SCR::Write (.sysconfig.displaymanager, nil);
	    }
	}

	return;
    }
    */

    /**
     * Write sysconfig variables
     * @param void
     * @return void
     */

    /*
    global define void sysconfigSettings()
	``{

	list Sysconfig = GetConfList(Configure, "sysconfig", true);
	list allSysconfig = union(Sysconfig, SysconfigVars);

	if (size(allSysconfig)>0)
	{
	    foreach(map var , allSysconfig, ``{
		WriteSysconfigValue( var["sysconfig_path"]:"dummy",
				     var["sysconfig_key"]:"dummy",
				     var["sysconfig_value"]:""
				     );
	    });

	}
	return;
    }

    */





    /**       
     * Read module configuration files
     * @return: map
     */

    define list ReadMenuEntries() ``{
	list directory = SCR::Dir(.autoinst.menuentry.s);
	map configurations = $[];
	map groups = $[];
	foreach (`i, directory, ``{
	    path single_conf = add(.autoinst.menuentry.s, i);
	    list configuration = SCR::Dir(single_conf);

	    foreach(`s , configuration, ``{
		
		string name = select(splitstring(s, " "), 1 , "");
		string type = select(splitstring(s, " "), 0 , "");

		path main_section = add(.autoinst.menuentry.v, i);
		main_section = add(main_section, s);
		list vals = SCR::Dir(main_section);
		map values = $[];
		foreach(`v, vals, ``{
		    values[v]=SCR::Read(add(main_section,v));
		});

		if (type == "Y2Group")
		{
		    groups[name]=values;
		}
		else if (type == "Y2Module")
		{
		    if (values["Autoinst"]:"" == "configure" || values["Autoinst"]:"" == "all")
		    {
			string module_auto = "";
			// determine name of client, if not default name
			if (!haskey(values,"AutoClient"))
			{
			    string client =  name + "_auto";
			    values["AutoClient"] = client;			
			}
			configurations[name]=values;
		    }
		}
	    });

	});
	return [configurations, groups];
    }


    global define boolean Save() ``{
	return (Profile::SaveYCP( parsedControlFile ));
    }
    


    /**
     * Finish Auto-Installation by saving misc files
     */
    global define void Finish ()
	``{
	// Copy pre scripts to target system.
	import "AIScripts";
	AIScripts::Write("chroot-scripts");	
	SCR::Execute(.target.bash,"/bin/cp " +  AutoInstall::tmpdir + "/pre-scripts/* " + Installation::destdir + AIScripts::scripts_dir);
	SCR::Execute(.target.bash,"/bin/cp " +  AutoInstall::tmpdir + "/pre-scripts/logs/* " + Installation::destdir + AIScripts::logs_dir);
	
	SCR::Execute(.target.bash, sformat("/bin/cp %1 %2%3", xml_tmpfile ,  Installation::destdir ,  xml_file) );

	return;
    }



    global define map Linuxrc(map linuxrc) ``{
	import "Bootloader";
	import "AIgeneral";
	if (AIgeneral::ForceBoot && Mode::hardBoot)
	{
	    linuxrc["Root"] = Bootloader::getRootDevice ();
	}
	if (AIgeneral::Reboot && !Mode::hardBoot)
	{
	    linuxrc["Root"] = "reboot";
	    Mode::hardBoot = true;
	}

	if (AIgeneral::RebootMsg)
	{
	    linuxrc["RebootMsg"] = "1";
	}
	else
	{
	    linuxrc["RebootMsg"] = "0";
	}
	return linuxrc;
    }
}

