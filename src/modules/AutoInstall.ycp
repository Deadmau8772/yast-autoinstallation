/**
 * File:	modules/AutoInstall.ycp
 * Package:	Auto-installation
 * Summary:	Auto-installation related functions module
 * Author:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

    module "AutoInstall";
    textdomain "autoinst";

	import "Profile";
    import "Installation";
    import "Mode";
    import "Report";
    import "XML";
    import "X11Version";
    import "Language";
    import "Bootloader";

    include "autoinstall/io.ycp";


    // Main directory for data generated during installation
    //
    global string var_dir = "/var/adm/autoinstall";

    // Cache directory
    //
    global string cache = var_dir + "/cache";

    // Temporary directory for storing profile before installation starts
    //
    global string tmpdir = SCR::Read( .target.tmpdir );

    // Temporary file name for retrieved system profile
    //
    global string xml_tmpfile = tmpdir + "/autoinst.xml";

    // Final location for retrieved system profile
    //
    global string xml_file = cache + "/installedSystem.xml";

    // Parsed data from XML control in YCP format
    //
    string parsedControlFile = cache + "/autoinst.ycp";

    // Direcotry for runtime operation data
    global string runtime_dir = "/var/lib/autoinstall";


    // Directory where copmlete configuration files are kept.
    //
    global string files_dir = var_dir + "/files";

    // Auto-Configuration mode
    //
    global boolean autoconf = false;

    // Parsed data to be used to set variables in other modules
    //////////////////////////////////////////////////////////////

    global boolean interactive = true;


    global map Profile = $[];

    global map X11 = $[];


    global list loadKernelModules = [];
    global list configureKernelModules = [];


    // Modules

    global map GroupMap = $[];
    global map ModuleMap = $[];



    global boolean IgnorePkgErr = true;
    global map Bootloader = $[];
    
    //////////////////////////////////////////////////////////////////////////////////////////////
    // Local variables
    /////////////////////////////////////////////////////////////////////////////////////////////


    /**
     * Constructer
     *
     */
    global define void AutoInstall()
	``{
	if (!Mode::config &&  ! ( Mode::cont && Continue() ))
	{
	    if ( SCR::Read(.target.size, xml_tmpfile) != -1  && size ( Profile::current ) == 0)
	    {
		// Profile is available and it has not been parsed yet.
		Profile::Read(  xml_tmpfile );
	    }

	}

	if (Mode::cont && size ( Profile::current ) > 0)
	{
	    y2milestone("Enabling Auto-Installation mode");
	    Mode::autoinst = true;
	}

	// Read module configuration data (y2cc)
	if (Mode::config || ( Mode::cont &&  Mode::autoinst))
	{
	    list MenuEntries = ReadMenuEntries();
	    ModuleMap = select(MenuEntries,0,$[]);
	    GroupMap = select(MenuEntries,1,$[]);
	    y2debug("Modules: %1 , Groups: %2", ModuleMap, GroupMap);
	}


	return;
    }



    /**
     * Read saved data in continue mode
     */


    global define boolean Continue() ``{

	// First check if there are some other control files availabe
	// i.e. for post-installation only
	string autoconf_file = runtime_dir + "/autoconf/autoconf.xml";

	if ( SCR::Read(.target.size, autoconf_file) != -1 )
	{
	    y2milestone("XML Post installation data found: %1", autoconf_file );
	    autoconf = true;
	    Profile::Read(  autoconf_file  );
	    boolean ret = Profile::Read(  xml_tmpfile );
	    SCR::Execute(.target.bash, sformat("/bin/mv %1 %2", autoconf_file, cache));

	    Profile = Profile::current;
	    ProcessSpecialResources();

	    return (ret);
	}
	else
	{
	    boolean ret = Profile::ReadYCP ( parsedControlFile );
	    if ( Profile::current == $[] || !ret )	// No saved data base.
	    {
		y2milestone( "No saved autoinstall data found" );
		return (false);
	    }
	    else	// saved data  found
	    {
		y2milestone( "Found and read saved autoinst data : <%1>", Profile::current );
		SCR::Execute(.target.remove, parsedControlFile);

		Profile = Profile::current;

		ProcessSpecialResources();

		return (true);
	    }
	}


    }


    /**
     * Parse profile and set some values
     * @param true on success
     */
    global define boolean ProcessSpecialResources ()
	``{

	Report::Import(Profile::Flat["report"]:$[]);
	X11 = Profile::Flat["x11"]:$[];

	if (size(X11) == 0 || !X11["configure_x11"]:false )
	{
	    Mode::x11_setup_needed = false;
	}

	return true;
    }

    /**
     * Configure bootloader settings
     * @param void
     * @return void
     */
    global define boolean bootloaderSettings()``{

	// Bootloader::manual_location = true;
	Bootloader = Profile::Flat["bootloader"]:$[];

	string parameters = Bootloader["kernel_parameters"]:"";

	if ( size(parameters) > 0)
	{
	    foreach (`parameter, splitstring(parameters, " "),
		     ``{
		list param_value_list = splitstring (parameter, "=");		
		if (size (param_value_list) > 0)
		{
		    Kernel::AddCmdLine (param_value_list[0]:"", param_value_list[1]:"");
		}
	    });
	    Bootloader = remove(Bootloader, "kernel_parameters");
	}

	
	// Add initrd modules
	if (size(Bootloader["initrd_modules"]:[]) > 0)
	{
	    import "Initrd";
	    foreach(map mod , Bootloader["initrd_modules"]:[],
		    ``{
		Initrd::AddModule (mod["module"]:"", mod["module_args"]:"");
	    });
	    Bootloader = remove(Bootloader, "initrd_modules");
	}


	if (Bootloader == $[])
	{
	    Bootloader::Propose ();
	    return true;
	}
	else
	{
	    Bootloader::Import(Bootloader);
	    // FIXME: detect if configuration is the result of cloning.
	    BootCommon::was_proposed = false;
	    Bootloader::Propose ();
	}
    }



    /**
     * Read module configuration files
     * @return: map
     */

    define list ReadMenuEntries() ``{
	list directory = SCR::Dir(.autoinst.menuentry.s);
	map configurations = $[];
	map groups = $[];
	foreach (`i, directory, ``{
	    path single_conf = add(.autoinst.menuentry.s, i);
	    list configuration = SCR::Dir(single_conf);

	    foreach(`s , configuration, ``{

		string name = select(splitstring(s, " "), 1 , "");
		string type = select(splitstring(s, " "), 0 , "");

		path main_section = add(.autoinst.menuentry.v, i);
		main_section = add(main_section, s);
		list vals = SCR::Dir(main_section);
		map values = $[];
		foreach(`v, vals, ``{
		    values[v]=SCR::Read(add(main_section,v));
		});

		if (type == "Y2Group")
		{
		    groups[name]=values;
		}
		else if (type == "Y2Module")
		{
		    if (values["Autoinst"]:"" == "configure" || values["Autoinst"]:"" == "all")
		    {
			string module_auto = "";
			// determine name of client, if not default name
			if (!haskey(values,"AutoClient"))
			{
			    string client =  name + "_auto";
			    values["AutoClient"] = client;
			}
			configurations[name]=values;
		    }
		}
	    });

	});
	return [configurations, groups];
    }


    global define boolean Save()
	``{
	return (Profile::SaveYCP( parsedControlFile ));
    }



    /**
     * Finish Auto-Installation by saving misc files
     */
    global define void Finish ()
	``{
	// Copy pre scripts to target system.
	import "AIScripts";
	AIScripts::Write("chroot-scripts");
	SCR::Execute(.target.bash,"/bin/cp " +  AutoInstall::tmpdir + "/pre-scripts/* " + Installation::destdir + AIScripts::scripts_dir);
	SCR::Execute(.target.bash,"/bin/cp " +  AutoInstall::tmpdir + "/pre-scripts/logs/* " + Installation::destdir + AIScripts::logs_dir);

	SCR::Execute(.target.bash, sformat("/bin/cp %1 %2%3", xml_tmpfile ,  Installation::destdir ,  xml_file) );

	return;
    }

    /**
     * Linuxrc Settings
     * @param: linuxrc map
     * @return modified linuxrc map
     */

    global define map Linuxrc(map linuxrc) ``{
	import "Bootloader";
	import "AIgeneral";

	if (AIgeneral::ForceBoot && Mode::hardBoot)
	{
	    linuxrc["Root"] = Bootloader::getRootDevice ();
	}

	if (AIgeneral::Reboot && !Mode::hardBoot)
	{
	    linuxrc["Root"] = "reboot";
	    Mode::hardBoot = true;
	}

	if (AIgeneral::RebootMsg)
	{
	    linuxrc["RebootMsg"] = "1";
	}
	else
	{
	    linuxrc["RebootMsg"] = "0";
	}
	y2milestone("Linuxrc settings: %1", linuxrc);
	return linuxrc;
    }
}

