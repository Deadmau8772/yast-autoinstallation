/**
 * File:	modules/AutoInstall.ycp
 * Package:	Auto-installation
 * Summary:	Auto-installation related functions module
 * Author:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */

{

    module "AutoInstall";
    textdomain "autoinst";

    import "Installation";
    import "Mode";
    import "Report";
    import "XML";
    import "X11Version";
    import "Language";

    
    include "autoinstall/io.ycp";
  


    // Put all scripts and autoinstall data in this directory for later access
    //
    global string dir = Installation::yast2dir + "/Autoinstall";


    
    // Temporary directory for storing profile before installation starts
    //
    global string tmpdir = SCR::Read( .target.tmpdir );


    
    // Temporary file name for retrieved system profile
    //
    global string xml_tmpfile = tmpdir + "/Autoinstall.xml";


    
    // Final location for retrieved system profile
    //
    global string xml_file = Installation::yast2dir + "/Autoinstall.xml";


    
    // File with parsed data from system profile
    //
    string Profile_file = Installation::yast2dir + "/Autoinstall_data.ycp";


    
    // Main directory for data generated during installation
    //
    global string var_dir = "/var/adm/autoinstall";


    
    // Directory for the pre/post and chroot scripts
    //
    global string scripts_dir = var_dir + "/scripts";


    
    // Directory where log files of pre/post and chroot scripts are kept
    //
    global string logs_dir = var_dir + "/logs";


    
    // Directory where copmlete configuration files are kept.
    //
    global string files_dir = var_dir + "/files";

    // If true, this mode shows the proposal and lets the user change
    // settings
    //
    global boolean interactive = false;


    // Parsed data from system profile
    //
    global map Profile =  $[];

    // Map with data from comman dline specifying profile location and protocol to use.
    //
    global map ProfileLocation = $[];


    // Parsed data to be used to set variables in other modules
    //////////////////////////////////////////////////////////////

    // Show proposal and ask use for confirmation to go on with auto-installation
    // Similar to interactive mode, without letting use change settings
    // Interactive mode implies confirmation as well..

    global boolean Confirm = true;


    global string Encryption = "des";

    // Language
    global string Language = "";

    // Hard Reboot
    global boolean Reboot = false;

    // Dont Hard Reboot
    global boolean ForceBoot = false;

    // Show Reboot Message
    global boolean RebootMsg = false;


    // Keyboard
    global string Keyboard = "";

    // Timezone
    global string Timezone = "";

    // Mouse, if not autoprobed
    global string Mouse = "";

    // Hardware clock
    global string Hwclock = "";

    global map Bootloader = $[];


    global map X11 = $[];

    // partitioning
    global list Partitioning = [];
    global list LVM = [];

    global map targetMap = $[];


    global list loadKernelModules = [];
    global list configureKernelModules = [];
    
    global list RAID = [];

    global list Fstab = [];


    // Modules

    global map GroupMap = $[];
    global map ModuleMap = $[];


    // Kernel
    global string Kernel = "";


    //////////////////////////////////////////////////////////////////////////////////////////////
    // Local variables
    /////////////////////////////////////////////////////////////////////////////////////////////



    // Sysconfig variable already registered
    list registered_list = [];

    // Two main configuration resources
    map Install = $[];
    map Configure = $[];

    list SysconfigVars = [];

    list forcedPackages = [];

    boolean parsed = false;
    /**
     * Constructer
     */

    global define void AutoInstall()
	``{

	if (Mode::config || ( Mode::cont &&  Mode::autoinst))
	{
	    list MenuEntries = ReadMenuEntries();
	    ModuleMap = select(MenuEntries,0,$[]);
	    GroupMap = select(MenuEntries,1,$[]);
	    y2debug("Modules: %1 , Groups: %2", ModuleMap, GroupMap);
	}

	if (!Mode::config &&  ! ( Mode::cont && Restore() ))
	{
	    if ( SCR::Read(.target.size,xml_tmpfile) != -1  && size ( Profile ) == 0)
	    {
		// Profile is available and it has not been parsed yet.
		ProcessProfile();
	    }
	    // Just to be sure
	    if (Mode::initial && Mode::autoinst)
		ParseCmdLine();
	}

	if (Mode::cont && size ( Profile ) > 0)
	{
	    y2milestone("Enabling Auto-Installation mode");
	    Mode::autoinst = true;
	}

	return;
    }

    /**
     * Parse profile and set some values
     *
     */

    global define boolean ProcessProfile()
	``{
	any ret = nil;
	if ( SCR::Read(.target.size, xml_tmpfile) > 0 )
	{
	     ret = XML::XMLToYCPFile( xml_tmpfile );
	     if (ret == nil)
	     {
		 return false;
	     }
	     else
	     {
		 Profile = ret;
	     }
	}
	// the install section
	Install = Profile["install"]:$[];

	// and the configure section
	Configure = Profile["configure"]:$[];

	Report::Set(GetMap(Install , "report", true));
	Fstab = fstabSettings();
	X11 = Configure["x11"]:$[];


	map Software = Install["software"]:$[];

	postPackageList();
	
	return true;
    }



    /**
     * Parse and prepare fstab settings
     * 	<pre>fstab["/dev/pts"] = $["spec":"devpts", "file":"/dev/pts", "vfstype":"devpts",
     *  "mntops":"defaults", "freq":0, "passno":0];</pre>
     * @return list fstab list to be used by write_fstab
     */
    global define list fstabSettings()``{
	list fstab_raw = GetList(Configure, "fstab", true);
	list fstab = maplist(`f, fstab_raw, ``{
	    map entry = $[];
	    entry["spec"] 	= f["fs_spec"]:"";
	    entry["file"]	= f["fs_file"]:"";
	    entry["vfstype"]	= f["fs_vfstype"]:"";
	    entry["mntops"] 	= f["fs_mntops"]:"defaults";
	    entry["freq"]	= f["fs_freq"]:0;
	    entry["passno"]	= f["fs_passno"]:0;
	    return (entry);
	});
	return fstab;
    }

    /**
     * Configure general settings
     * @param void
     * @return void
     */

    global define void generalSettings () ``{
	// Get default values as fallback	
	string default_keyboard = Keyboard::GetKeyboardForLanguage( Language::language, "english-us" );

	Keyboard = default_keyboard;
	Language = Language::language;	
	Mouse = "probe";
	Encryption = "des";


	map general = GetMap(Install, "general", true);

	foreach(`k,`v, general , ``{
	    if (k == "language")
	    {
		y2milestone("Setting language to %1", v);
		Language 	= v;
	    }
	    else if (k == "keyboard" && is(v, map))
	    {
		Keyboard = v["keymap"]:default_keyboard;
	    }
	    else if (k == "keyboard" && is(v, string)) // compat
	    {
		Keyboard = v;
	    }
	    else if (k == "clock" && is(v, map))
	    {
		Timezone = v["timezone"]:"";
		string hwc = v["hwclock"]:"";
		if (hwc != "")
		{
		    if (hwc == "localtime")
			Hwclock = "--localtime";
		    else
			Hwclock = "-u";
		}


		if (size(v["ntp_servers"]:[])>0)
		{
		    string key = "XNTPD_INITIAL_NTPDATE";
		    string val = mergestring(v["ntp_servers"]:[], " ");
		    string file = "xntp";
		    addSysconfigVar(file,  key, val, "xntp");
		}

	    }

	    else if (k == "hwclock") // compat
	    {
		if (v == "localtime")
		    Hwclock = "--localtime";
		else
		    Hwclock = "-u";
	    }
	    else if (k == "timezone") // compat
	    {
		Timezone 	= v;
	    }
	    else if (k == "mouse"  && is(v, map) )
	    {
		// if id is set, then just take it and ignore everything else
		if (v["id"]:"" != "")
		{
		    Mouse = v["id"]:"";
		}

		// Otherwise, try to find the mouse id from the DB using data supplied by user,
		// at least the device is needed.

		else if (haskey(v,"device"))
		{
		    string device = v["device"]:"none";
		    integer wheels = v["wheels"]:0;

		    map mice = Misc::ReadAlternateFile ("mouse_db.ycp", "mouse_raw.ycp");

		    foreach(`f,`g, mice, ``{
			map data = select(g,1,$[]);
			if ( data["wheels"]:0 == wheels  && data["device"]:"" == device)
			{
			    Mouse =  f;
			}
		    });
		}
		else if (haskey(v, "probe"))
		{

		}
	    }
	    else if (k == "mouse" && is(v, string))
	    {
		Mouse = v;
	    }
	    else if (k == "mode")
	    {
		Confirm = v["confirm"]:true;
		interactive = v["interactive"]:true;
		Reboot = v["reboot"]:false;
		ForceBoot =  v["forceboot"]:false;
		RebootMsg =  v["rebootmsg"]:false;

		if (haskey(v, "interactive_boot"))
		{
		    string key = "PROMPT_FOR_CONFIRM";
		    string val = (v["interactive_boot"]:false) ? "yes"  : "no";
		    string file = "boot";
		    addSysconfigVar(file,  key, val, "");
		}
	    }
	    else if (k == "reboot")
	    {
		Reboot = v;
	    }
	    else if (k == "confirm")
	    {
		Confirm = v;
	    }

	});

	if (!Confirm)
	    interactive = false;

	return;
    }


    /**
     * Configure bootloader settings
     * @param void
     * @return void
     */
    global define bootloaderSettings()``{
	
	Boot::manual_location = true;
	Bootloader = GetMap(Install, "bootloader", true);

	
	
	if (issubstring(Bootloader["location"]:"mbr", "/dev/"))
	{
	    Boot::device=Bootloader["location"]:"mbr";
	    Boot::location="custom";
	}
	else
	{
	    Boot::location = Bootloader["location"]:"mbr";	  		
	}
	
	string parameters = Bootloader["kernel_parameters"]:"";
	
	if ( size(parameters) > 0)
	{
	    foreach (`parameter, splitstring(parameters, " "),
		     ``{		
		list param_value_list = splitstring (parameter, "=");

		// now only collect keys not in discardlist
		if (size (param_value_list) > 0)
		{
		    Kernel::AddCmdLine (param_value_list[0]:"", param_value_list[1]:"");
		}
	    });
	}
	
	// Lilo settings
	
	if (Boot::LoaderType == "lilo")
	{
	    import "BootLILO";
	    BootLILO::Set(
			  Bootloader["linear"]:false,
			  Bootloader["activate"]:false,
			  Bootloader["lba_support"]:false
			  );
	}
	else if (Boot::LoaderType == "grub")
	{
	    import "BootGRUB";
	    BootGRUB::Set(
			  Bootloader["linear"]:false,
			  Bootloader["activate"]:false,
			  Bootloader["lba_support"]:false
			  );
	}


	// Add initrd modules
	if (size(Bootloader["initrd_modules"]:[]) > 0)
	{
	    foreach(`m, Bootloader["initrd_modules"]:[],
		    ``{
		Boot::AddInitrdModule (m, "");
	    });
	}

	Boot::Set();
    }

    /**
     * Return post package list
     * @return list post packages
     */
    global define  list postPackageList() ``{
	map Software = Install["software"]:$[];		
	list postPackages = Software["post-packages"]:[];
			
	y2milestone("Post packages: %1",  postPackages);
	return postPackages;
    }
    
    /**
     * Parse package list
     * @return list Packages
     */
    global define list packageList()``{
	map Software = Install["software"]:$[];
	list Packages = Software["packages"]:[];
	return Packages;
    }


    /**
     * Configure software settings
     * @param void
     * @return boolean
     */
    global define boolean softwareSettings()
	``{

	boolean ret = false;
	y2milestone("set Locale to %1", Language::language);
	Pkg::SetLocale (Language::language);
	
	Packages::Init(true);	
	// Standard Packages
	boolean retval = false;

	map Software = Install["software"]:$[];
	list addons = Software["addons"]:[];

	if (Software["base"]:"" != "")
	{
	    string  base_selection = Software["base"]:"Minimal";
	    ret = Pkg::SetSelection( base_selection );
	    y2milestone ( "Selecting %1 returns: %2", base_selection, ret );	     
	}

	foreach(`s, toset(addons),
		``{	
	    ret = Pkg::SetSelection( s );	    
	});

	// single selected packages
	list Packages = union(Software["packages"]:[], forcedPackages);			
	Pkg::DoProvide(Packages);

	SpaceCalculation::ShowPartitionWarning();
	y2milestone( "INSTALLING Software Selection: base(%1), addon(%2)",  Pkg::GetSelections(`selected, "base"), Pkg::GetSelections(`selected, ""));
	return (Pkg::ActivateSelections());
        
    }


    
    /**
     * Finalize autoinst settings
     * @param
     * @return void
     */
    global define void Finalize()
	``{
	
	sysconfigSettings();
	if (  X11["default_wm"]:"" != "") {
	    SCR::Write (.sysconfig.windowmanager.DEFAULT_WM, X11["default_wm"]:"kde");
	    SCR::Write (.sysconfig.windowmanager, nil);
	}
	if (  X11["display_manager"]:"" != "") {
	    SCR::Write (.sysconfig.displaymanager.DISPLAYMANAGER, X11["display_manager"]:"kdm");
	    SCR::Write (.sysconfig.displaymanager, nil);
	}
	
	return;    
    }

    /**
     * Write sysconfig variables
     * @param void
     * @return void
     */
    global define void sysconfigSettings()
	``{

	list Sysconfig = GetConfList(Configure, "sysconfig", true);
	list allSysconfig = union(Sysconfig, SysconfigVars);

	if (size(allSysconfig)>0)
	{
	    foreach(map var , allSysconfig, ``{
		WriteSysconfigValue( var["sysconfig_path"]:"dummy",
				     var["sysconfig_key"]:"dummy",
				     var["sysconfig_value"]:"dummy"
				     );
	    });

	}
	return;
    }

     /**
     * Execute pre scripts
     * @param type of script
     * @return void
     */

    global define scriptSettings(string type)
	``{

	map allScripts = Configure["scripts"]:$[];
	list scripts = allScripts[type]:[];

	string tmpdirString = "";
	string current_logdir = "";
	
	if (type == "pre-scripts")
	{
	    tmpdirString = sformat("%1/%2", tmpdir, type);
	    SCR::Execute (.target.mkdir, tmpdirString);

	    current_logdir = sformat("%1/logs", tmpdirString);
	    SCR::Execute (.target.mkdir,  current_logdir);
	}
	else if (type == "chroot-scripts")
	{
	    tmpdirString = sformat("%1%2", Installation::destdir,  scripts_dir);
	    SCR::Execute (.target.mkdir, tmpdirString);

	    current_logdir = sformat("%1%2", Installation::destdir, logs_dir);
	    SCR::Execute (.target.mkdir,  current_logdir);
	}
	else
	{
	    current_logdir = logs_dir;
	}


	foreach( `s, scripts,
		 ``{
	    string scriptInterpreter=s["interpreter"]:"shell";
	    string scriptName=s["filename"]:type;
	    string scriptPath = "";

	    if (type == "pre-scripts")
	    {
		scriptPath = sformat("%1/%2/%3", tmpdir, type, scriptName);
		y2milestone("Writing pre script into %1", scriptPath);
		SCR::Write(.target.string, scriptPath, s["source"]:"echo Empty script!");
	    }
	    else if (type == "chroot-scripts")
	    {
		scriptPath = sformat("%1%2/%3", Installation::destdir,  scripts_dir,  scriptName);
		y2milestone("Writing chroot script into %1", scriptPath);
		SCR::Write(.target.string, scriptPath, s["source"]:"echo Empty script!");
	    }
	    else
	    {
		scriptPath = sformat("%1/%2", scripts_dir, scriptName);
		y2milestone("Writing  script into %1", scriptPath);
		SCR::Write(.target.string,  scriptPath, s["source"]:"echo Empty script!");
	    }

	    // string message =  sformat(_("Executing user supplied script: %1"), scriptName);
	    string executionString = "";
	    if (scriptInterpreter == "shell")
	    {
		executionString = sformat("/bin/sh -x %1  2&> %2/%3.log", scriptPath, current_logdir, scriptName);
		SCR::Execute (.target.bash, executionString);
	    }
	    else if (scriptInterpreter == "perl")
	    {
		executionString = sformat("/usr/bin/perl %1  2&> %3/%4.log", scriptPath, current_logdir, scriptName);
		SCR::Execute (.target.bash,executionString);
	    }
	    else
	    {
		y2error("Unknown interpreter: %1", scriptInterpreter);
	    }
	    y2milestone("Script Execution command: %1", executionString );
	});

	return;
    }


     /**
     * Create partition plans
     * @param void
     * @return void
     */

    global define void partitionSettings()
	``{
	import "Partitions";
	include "autoinstall/partitioning.ycp";



	Partitioning = Install["partitioning"]:[];

	map init_targetmap = Storage::GetTargetMap();
	y2milestone("Inital Target map: %1", init_targetmap);

	list drives = maplist( `k, `v, init_targetmap ,
			      ``{
				  return($["device":k, "size": lookup(v,"cyl_size",0)]);
	});

	y2milestone("Drives: %1", drives);

	Storage::SetPartDisk(lookup(select(drives,0,$[]),"device", Boot::FindMbrDisk()));

	// Set devices if missing
	targetMap =  listmap (map drive, Partitioning, ``{
	    boolean first_set = false;
	    string device = "";
	    if (!first_set && drive["device"]:"" == "")
	    {
		device = Storage::GetPartDisk();
		first_set = true;
		return([device,drive]);
	    }
	    else if (drive["device"]:"" != "")
	    {
		return([drive["device"]:"",drive]);
	    }

	});

	y2milestone("New Auto-Install tagetMap: %1", targetMap);

	// Initialize disks if needed
	boolean init_done = false;
	foreach (string device, map data, targetMap,
		 ``{
	    if (data["initialize"]:false)
	    {
		init_done = true;
		integer zero_ret = InitDevice(device);
		y2milestone("Initializing device:%1 --> %2", device, zero_ret);
	    }
	});

	// Re-probe Targets
	if (init_done)
	{
	    Storage::ReReadTargetMap();
	}

	foreach (string device, map data, targetMap,
		 ``{
	    y2milestone("Creating partition plans for %1", device);
	    boolean ret = AutoPartition(device);
	});

	raidSettings();
	if (size(RAID)!= 0)
	    autoRAID();
	lvmSettings();
	if (size(LVM)!= 0)
	    autoLVM();

    }



    /**
     * Create LVM partition plans
     * @param void
     * @return void
     */
    global define lvmSettings()
	``{

	LVM = Install["lvm"]:[];


    }

    /**
     * Create RAID partition plans
     * @param void
     * @return void
     */
    global define raidSettings()
	``{

	RAID = Install["raid"]:[];
    }


    /**
     * Restore the the current data from a file that has been saved before.
     * @param	-
     * @return  true	- Data base file found. Restore successful.
     *		false	- No data base file found.
     * @see	save()
     */

    global define boolean Restore()
	``{
	Profile = SCR::Read( .target.ycp, [Profile_file, $[]] );

	if ( Profile == $[] )	// No saved data base.
	{
	    y2milestone( "No saved Autoinstall data found" );
	    return false;
	}
	else	// saved database found
	{
	    y2milestone( "Found saved autoinst data : <%1>", Profile );
	    return (ProcessProfile());
	}

    }	// Restore()




    /**
     * Save the current data into a file to be read after a reboot.
     * @param	-
     * @return  -
     * @see	Restore()
     */
    global define void Save()
	``{

	if (size(SCR::Read  (.target.dir, tmpdir)) > 0 )
	{
	    if (SCR::Execute (.target.bash, "/bin/cp -a " + tmpdir + " " + dir) == 0)
	    {
		y2milestone("Copied temporary autoinstall files to %1", dir);
	    }
	}
	// Write it to the file.
	//
	SCR::Write( .target.ycp, Profile_file, Profile );
	return;
    }	// save()




    /**
     * Return location of profile from command line.
     * @return map with protocol, server, path
     * @example autoyast=http://www.server.com/profiles/
     */
    global define boolean ParseCmdLine ()
	``{
	include "transfer/url.ycp";
	map result = $[];
	string cmdLine = "";	
	any autoinstall = SCR::Read(.etc.install_inf.AutoYaST);
	
	if (autoinstall != nil && is(autoinstall,string))
	{
	    cmdLine = autoinstall;
	    if (cmdLine == "default")
	    {
		result["scheme"]= "default";
		ProfileLocation = result;
		return true;
	    }
	    else
	    {
		result = parse_url (cmdLine);
	    }
	}


	if (result["scheme"]:"" == "")
	{
	    // Autoinstall mode was not activated from command line.
	    // There must be a floppy with an 'autoinst.xml' in order
	    // to be able to reach this point, so we set floppy with
	    // autoinst.xml as the control file.

	    result = add(result, "scheme", "floppy");
	    result = add(result, "path","/autoinst.xml");
	}
	ProfileLocation = result;
	return true;;
    }

    /**
     * Copy custom configuration files to system.
     * @param void
     * @return void
     */
    global define void CopyFiles()
	``{

	list Files = GetConfList(Configure, "files", true);

	if (size(Files)==0)
	{
	    return;
	}

	integer counter = 0;
	foreach(map file, Files,
		``{
	    if (file["file_contents"]:"" != "")
	    {
		string alternate_location = sformat("%1/%2", files_dir, counter);
		y2milestone("AutoInstall: Copying file %1",  file["file_path"]:alternate_location );
		SCR::Write (.target.string, file["file_path"]:alternate_location, file["file_contents"]:"");
	    }
	    counter = counter + 1;
	});
	return;
    }

    /**
     * Write a single sysconfig value
     * @param file filename to write to
     * @param key of sysconfig variable
     * @param value of sysconfig variable
     * @return void
     */
    define void WriteSysconfigValue( string file,
				       string   key,
				       string value )
	``{

	list    path_list   = splitstring( "" + file, "/" );
	string variable     = key;

	string  path_string = ".etc.sysconfig." + mergestring( path_list, "." );
	path    path_path   = topath( path_string );
	string  path_slash  = mergestring(splitstring( path_string, "."), "/");

	if ( regexpmatch( path_slash, ".*rc/config.*" ) )
	{
	    path_slash = regexpsub( path_slash, "(.*)rc/config(.*)",  "\\1rc.config\\2" );
	}


	if ( !contains(registered_list, path_path))
	{
	    y2debug("Registering %1", path_path);
	    string tmp = SCR::Read(.target.tmpdir);
	    if (tmp == nil || tmp == "") tmp = "/tmp";

	    tmp = tmp + "/_" + path_string + ".scr";

	    string scrfile = path_string + "\n" + "`ag_ini( SysConfigFile(\"" + path_slash + "\"))\n";


	    SCR::Write (.target.string, tmp, scrfile);
	    SCR::RegisterAgent(path_path, tmp);
	    registered_list = add( registered_list, path_path );
	    y2debug("Registered: %1", registered_list );
	}
	any ret = SCR::Write( topath(path_string + "." + variable), value);
	y2milestone("sysconfig ret: %1", ret);

    };






     /**
     * read_plugins()
     * Read plugin configuration file
     * @return: map
     */

    define list ReadMenuEntries() ``{
	list directory = SCR::Dir(.autoinst.menuentry.s);
	map configurations = $[];
	map groups = $[];
	foreach (`i, directory, ``{
	    path single_conf = add(.autoinst.menuentry.s, i);
	    list configuration = SCR::Dir(single_conf);

	    foreach(`s,configuration, ``{
		string name = select(splitstring(s, " "),1,"");
		string type = select(splitstring(s, " "),0,"");


		path main_section = add(.autoinst.menuentry.v, i);
		main_section = add(main_section, s);
		list vals = SCR::Dir(main_section);
		map values = $[];
		foreach(`v, vals, ``{
		    values[v]=SCR::Read(add(main_section,v));
		});

		if (type == "Y2Group")
		    groups[name]=values;
		else if (type == "Y2Module") {
		    if (values["Autoinst"]:"" == "configure" || values["Autoinst"]:"" == "all")
			configurations[name]=values;
		}
	    });

	});
	return [configurations, groups];
    }

    /**
     * Add a single entry to the Sysconfig list of variables
     * @param string file name / path
     * @param string key
     * @param string value
     * @param string package name which uses this variable if installation of package has to be forced.
     * @return void
     */
    global define void addSysconfigVar(string file, string key, string value, string package)
	``{

	SysconfigVars=add(SysconfigVars, $["sysconfig_path":file, "sysconfig_key":key, "sysconfig_value": value]);
	if (package != "") {
	    forcedPackages = add(forcedPackages, package);
	}
    }


    global define void copyPrescriptData () ``{
	SCR::Execute(.target.bash,"/bin/cp " +  AutoInstall::tmpdir + "/pre-scripts/* " + Installation::destdir + AutoInstall::scripts_dir);
	SCR::Execute(.target.bash,"/bin/cp " +  AutoInstall::tmpdir + "/pre-scripts/logs/* " + Installation::destdir + AutoInstall::logs_dir);
    }

}

