/**
 * File:	modules/AutoinstStorage.ycp
 * Module:	Auto-Installation
 * Summary:	Storage
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{

    module "AutoinstStorage";
    textdomain "autoinst";

    import "Storage";
    import "Partitions";
    import "FileSystems";
    import "Mode";
    import "Summary";
    import "Report";
    import "Storage";
    import "Partitions";
    import "Bootloader";
    import "BootCommon";
    import "AutoinstLVM";
    import "AutoinstRAID";



    // Read existing fstab and format partitions, but dont create anything
    // Use same mountpoints etc.
    global boolean read_fstab = false;

    // Fstab options
    global map fstab = $[];

    // Show warning for /boot on raid
    global boolean BootRaidWarning = true;

    // Show warning for /boot on lvm
    global boolean BootLVMWarning = true;

    // Show warning for /boot cyl <1024
    global boolean BootCylWarning = true;

    // Partition plan as parsed from control file
    global list<map> AutoPartPlan = [];

    // All configured devices
    global list ConfiguredDevices = [];

    // Prepared target map from parsed data
    global map<string, map> AutoTargetMap = $[];

    // Map of only physical devices
    map<string, map> PhysicalTargetMap = $[];

    // List of physical drives
    list PhysicalDrives = [];

    // list of physical devices
    list PhysicalDevices = [];


    // maximal number ofpartitions
    integer max_partitions = 0;

    // The number of possible primary partitions
    integer max_primary = 0;

    // The partition number of the first logical partition
    integer first_logical_nr = 0;

    // How much to allocate for swap
    integer size_of_swap	= 1024 * 1024 * Partitions::SwapSizeMb(0);

    // calculate size of the /boot partition
    integer size_of_boot = Partitions::MinimalNeededBootsize();

    list<integer> full_region = [];

    boolean can_do_auto = false;

    list<integer> unused_region = [ 0, 0 ];

    integer minimal_size = 0;

    integer bytes_per_unit = 0;

    string TargetDevice = "";

    integer	fsid_boot = 0;

    integer	fsid_root = 0;

    list<integer> region = [ 0, 0 ];


    string target_is = "";

    list root_region = [];

    include "partitioning/custom_part_dialogs.ycp";
    include "autoinstall/partitioning.ycp";
    include "autoinstall/autoinst_dialogs.ycp";

    /**
     * Dump the settings to a map, for autoinstallation use.
     * @return list
     */
    global define list<map> Export()
	``{
	list<map> clean_drives = maplist(map d,  AutoPartPlan, ``{
	    list p = maplist(map part, d["partitions"]:[] , ``{
		if (haskey(part, "fsid"))
		{
		    part = remove(part, "fsid");
		}
		if (haskey(part, "used_fs")) {
		    part = remove(part, "used_fs");
		}
		return part;
	    });
	    d["partitions"] = p;
	    return d;
	});

	return clean_drives;
    }


    /**
     * Get all the configuration from a map.
     * When called by inst_auto<module name> (preparing autoinstallation data)
     * the list may be empty.
     * @param settings a list	[...]
     * @return	boolean success
     */
    global define boolean Import(list<map> settings) ``{
	AutoPartPlan = settings;
	return true;
    }
    /**
     * Import Fstab data
     * @param map
     * @return	boolean success
     */
    global define boolean ImportFstab(map settings) ``{
        fstab = settings["fstab"]:$[];
        read_fstab = fstab["use_existing_fstab"]:false;
	return true;
    }

    /**
     * return Summary of configuration
     * @return  string configuration summary dialog
     */
    global define string Summary() ``{
	string summary = "";
	summary = Summary::AddHeader(summary, _("Drives"));
	integer num = size(AutoPartPlan);
	summary = Summary::AddLine( summary, sformat(_("Total of %1 drive", "Total of %1 drives", num), num));
	summary = Summary::OpenList(summary);
	foreach(map drive, AutoPartPlan, ``{
	    summary = Summary::AddListItem(summary, drive["device"]:_("No specific device configured") );
	});
	summary = Summary::CloseList(summary);
	return summary;
    }



    /**
     * Preprocess partition plan and prepare for creating partitions.
     * @return void
     */
    global define void PreProcess() ``{

        boolean first_set = false;
	AutoTargetMap =  listmap (map drive, AutoPartPlan, ``{
	    string device = "";
	    y2milestone("Working on drive: %1", drive);

	    if (drive["device"]:"" == "ask"  && size(PhysicalDrives) > 1 )
	    {
		string dev = DiskSelection();
		if (dev != nil)
		{
		    first_set = true;
		    device = dev;
		}
		if (contains(PhysicalDevices, device))
		{
		    ConfiguredDevices=add(ConfiguredDevices, device);
		}

		return  $[device: drive ];
	    }

	    if (!first_set && ( drive["device"]:"" == ""  || drive["device"]:"" == "ask"))
	    {
		device = Storage::GetPartDisk();
		first_set = true;
		if (contains(PhysicalDevices, device))
		{
		    ConfiguredDevices=add(ConfiguredDevices, device);
		}

		return $[device: drive ];
	    }
	    else if (drive["device"]:"" != "")
	    {
		if (contains(PhysicalDevices, drive["device"]:""))
		{
		    ConfiguredDevices=add(ConfiguredDevices, drive["device"]:"");
		}
		string dev = drive["device"]:"";
		return$[dev: drive ];
	    }

	});

	// Add MD devices as well
	if (haskey(AutoTargetMap, "/dev/md"))
	{
	    ConfiguredDevices=add(ConfiguredDevices, "/dev/md");
	}

	return;
    }

    /**
     * Handle /etc/fstab usage
     */
    boolean handle_fstab()
    {
        import "RootPart";

        if (!RootPart::didSearchForRootPartitions)
        {
            UI::OpenDialog (`opt(`decorated ),
                            `Label(_("Evaluating root partition. One moment please...")));
            RootPart::FindRootPartitions ();
            UI::CloseDialog ();
        }

        if (RootPart::numberOfValidRootPartitions == 0)
        {
            // a popup
            Popup::Message(_("No Linux root partition found."));
            return false;
        }

        // We must only change RootPart::selectedRootPartition if booting
        // is inevitable.
        string rp = fstab["root_partition"]:"";
        list<map> fstab_partitions = fstab["partitions"]:[];

        if (RootPart::numberOfValidRootPartitions == 1)
        {
            RootPart::SetSelectedToValid ();
        }
        else if ( rp == ""){
            Popup::Message(_("Multiple root partitions found, You did not configure
which root partition should be used.  Auto-Installation not possible."));
            return false;
        }
        else if ( haskey(RootPart::rootPartitions, rp) && RootPart::numberOfValidRootPartitions > 1)
        {
            RootPart::selectedRootPartition = rp;
        }

        RootPart::MountPartitions(RootPart::selectedRootPartition);
        RootPart::UnmountPartitions ();
        RootPart::SetFormatPartitions (fstab_partitions);
        return true;
    }

    /**
     * Create partition plan
     * @return boolean
     */
    global define boolean Write()
	``{
        if (read_fstab)
        {
            return (handle_fstab());
        }

	map<string, map> InitialTargetMap = Storage::GetTargetMap();
	y2milestone("Initial Target map: %1", InitialTargetMap);

	list<map> alldrives = maplist( string k, map v, InitialTargetMap ,  ``{
	    return($["device":k, "size": v["cyl_size"]:0 ]);
	});

	PhysicalTargetMap = filter(string k, map v, InitialTargetMap , ``(Storage::IsRealDisk(k, v) ));

        PhysicalDrives = maplist( string k, map v, PhysicalTargetMap ,
                                  ``{
                                      return($["device":k, "size": v["cyl_size"]:0 ]);
                                  });

        PhysicalDevices = maplist( string k, map v, PhysicalTargetMap ,
                                  ``{
                                      return(k);
                                  });
        y2debug("Physicaltm: %1", PhysicalTargetMap );
        y2debug("PhysicalDrives: %1", PhysicalDrives );
        y2debug("PhysicalDevices: %1", PhysicalDevices );
	y2milestone("All Drives=%1", alldrives);

	map FirstDrive = PhysicalDrives[0]:$[];

	string mbrDisk = FirstDrive["device"]:BootCommon::mbrDisk;

	y2milestone("MBR disk= %1", mbrDisk );

	Storage::SetPartDisk(mbrDisk);

	y2milestone("AutoPartPlan= %1", AutoPartPlan);

	boolean abort = false;

	// Start the real work

	PreProcess();

	y2milestone("New Auto-Install targetMap=%1", AutoTargetMap);
	if ( AutoTargetMap == $[] || abort )
	{
	    // Something went really wrong..
	    Report::Error(_("An error occurred while trying to create the partitioning plans.
Make sure the control file has the correct syntax and values.
"));
	    return false;
	}

	// Initialize disks if needed
	boolean DriveInitialized = false;
	foreach (string device, map data, AutoTargetMap,
		 ``{
	    if (data["initialize"]:false)
	    {
		    map thisDevice = InitialTargetMap[device]:$[];
		    thisDevice["partitions"] = [];
		    InitialTargetMap[device] = thisDevice;
		    Storage::SetTargetMap(InitialTargetMap);
		    DriveInitialized = true;
	    }
	});

	if (DriveInitialized)
	{
	    y2milestone("Target map after initialzing disk: %1", Storage::GetTargetMap());
	}

	if ( size(AutoTargetMap) > 0)
	{
	    boolean ok = true;
	    foreach (string device, map data, AutoTargetMap,
		     ``{
		if ( Storage::IsRealDisk( device, data) )
		{
		    y2milestone("Creating partition plans for %1", device);
		    TargetDevice = device;
		    boolean ret = AutoPartition();
		    if (!ret)
		    {
			ok = false;
		    }
		}
	    });
	    if (!ok)
	    {
		return false;
	    }
	}
        AutoinstLVM::Init();
	AutoinstLVM::lvm   = filter(string k, map v, AutoinstStorage::AutoTargetMap, ``(v["is_lvm_vg"]:false));
        AutoinstLVM::ConfiguredDevices = ConfiguredDevices;

	AutoinstRAID::raid = filter(string k, map v, AutoinstStorage::AutoTargetMap, ``(k == "/dev/md"));

	if ( size(AutoinstRAID::raid) != 0)
	{
	    y2milestone("Configuring RAID");
	    AutoinstRAID::Write();
	}
	else
	{

	    AutoinstRAID::DeleteMDs();
	}


	if ( size(AutoinstLVM::lvm) != 0)
	{
	    y2milestone("Configuring LVM");
	    if (!AutoinstLVM::Write() )
	    {
		return false;
	    }
	}
	return true;
    }


    /**
     * Initialize devices
     * @return void
     */
    global define void Initialize () ``{
	foreach (string device, map data, AutoTargetMap,
		 ``{
	    if (data["initialize"]:false && !data["is_lvm_vg"]:false && data["device"]:"" != "/dev/md" )
	    {
		integer zero_ret = Storage::ZeroDevice( device );
		y2milestone("Initializing device: %1 --> %2", device, zero_ret);
	    }
	});
	return;
    }



    /**
     * Delete Software raid
     * @return list
     */
    global define list<map> DeletedMDs ( string vgname )
	``{
	map<string, map> tm = Storage::GetTargetMap();
	list<list<map> >  ret = [];
	foreach( string dev, map devmap, tm,
		 ``{
	    ret = add( ret,
		       filter( map part, devmap["partitions"]:[],
			       ``(
				  part["lvm_group"]:"" == vgname
				  &&
				  part["delete"]:false
				  &&
				  ( part["fsid"]:0 == Partitions::fsid_lvm ||
				    part["fsid"]:0 == Partitions::fsid_raid ||
				    part["fsid"]:0 == Partitions::fsid_native )
				  )
			       )
		       );
	});
	list<map> output = flatten(ret);
	return( output );
    }


    /**
     * Build the id for a partition entry in the man table.
     * @parm disk_dev_name name of the devie e.g.: /dev/hda
     * @parm nr number of the partition e.g.: 1
     * @return string e.g.: 01./dev/hda
     */
    define string  build_id(  string disk_dev_name , any nr )
	``{
        return (sformat( "%1:%2", disk_dev_name, nr));
    };


    /**
     * Partitioning Overview
     * @return term
     */
    global define list Overview()
	``{

	map allfs = FileSystems::GetAllFileSystems(true, true);
	list drives_table = [];

	string id = "";
	foreach(map d, AutoPartPlan,
		``{
	    id = d["device"]:"";
	    term a = `item(`id(id), d["device"]:"", "", "", "", "", "" );

	    drives_table = add (drives_table, a);

	    list<map> partitions = d["partitions"]:[];
	    integer start_id = 1;

	    if ( size (partitions) > 0 )
	    {
		foreach(map p, partitions, ``{
		    id = build_id(d["device"]:"" , start_id );

		    term b = `item(`id(id));
		    b = add (b, "");

		    b=add(b, p["mount"]:"" );
		    b=add(b, p["size"]:"");

		    if (!haskey(p, "filesystem_id"))
		    {
			b=add(b, Partitions::FsIdToString(p["partition_id"]:131));
		    }
		    else
		    {
			b=add(b, Partitions::FsIdToString(p["filesystem_id"]:131));
		    }

		    map fs = allfs[p["filesystem"]:`nothing]:$[];
		    string fs_name = fs[`name]:"";

		    b=add(b, fs_name);

		    if ( size( p["region"]:[] ) > 0 )
		    {
			b=add(b, sformat("%1 - %2", select(p["region"]:[], 0 , 0), select(p["region"]:[], 1 , 0)));
		    }
		    else
		    {
			b=add(b, "");
		    }

		    drives_table = add(drives_table, b);
		    start_id = start_id + 1;
		});
	    }

	});

	integer entries = size(drives_table);
	list reversed_table = [];
	integer counter = entries;

	term tmp = `item(`id(`empty));

	while (counter != 0)
	{
	    reversed_table=add(reversed_table, select(drives_table, counter -1, tmp));
	    counter = counter - 1;

	}
	y2debug("table: %1", drives_table );
	return drives_table;


    }





}
