/**
 * File:	modules/AutoInstallRules.ycp
 * Package:	Auto-installation
 * Summary:	Process Auto-Installation Rules
 * Author:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{

    module "AutoInstallRules";
    textdomain "autoinst";


    import "Arch";
    import "Storage";
    import "Kernel";
    import "Mode";
    import "Profile";
    import "Label";
    import "Report";
    import "Popup";
    import "ProfileLocation";

    include "autoinstall/profileDialogs.ycp";

    global string remote_rules_location = "rules/rules.xml";
    global string local_rules_location = "";
    global string local_rules_file = "";

    global boolean userrules = false;

    global symbol Behaviour = `many;

    /////////////////////////////////////////////
    // Pre-defined Rules
    /////////////////////////////////////////////
    /////////////////////////////////////////////

    global string hostname = "";

    global string hostaddress = "";

    global string network = "";

    global string domain = "";

    global string arch = "";

    global string karch = "";

    global string model = ""; // Still not supported (FIXME)

    global string vendor = ""; // Still not supported (FIXME)

    global integer memsize = 0;

    global list disksize = [];

    global integer totaldisk = 0;

    global string hostid = "";

    global string mac = "";

    global integer linux = 0;

    global integer others = 0;

    global string xserver = "";

    global string haspcmcia = "0";

    /////////////////////////////////////////////
    /////////////////////////////////////////////

    global list NonLinuxPartitions = [];

    global list LinuxPartitions = [];



    global map UserRules = $[];

    // Local
    string shell = "";
    map env = $[];

    list tomerge = [];


    /**
     * Constructor
     *
     */
    global define void AutoInstallRules () ``{
		return;
	}




    global define void Init () ``{


	local_rules_location = SCR::Read(.target.tmpdir) + "/rules";
	SCR::Execute(.target.mkdir, local_rules_location);

	local_rules_file = local_rules_location + "/rules.xml";

	if (Mode::initial)
	{
	    ProbeRules();
	}

	return;
    }

    /**
     * Probe all system data to build  a set of rules
     */
    global define void ProbeRules () ``{

	// Architecture
	arch = Arch::architecture;

	karch = select(Kernel::kernel_packages, 0, "k_deflt");


	// Memory
	integer memory = 0;
	list memories = SCR::Read(.probe.memory);
	memory = memories[0,"resource","phys_mem",0,"range"]:0;
	memsize =  memory / ( 1024 * 1024);


	// Disk sizes
	map storage =  Storage::GetTargetMap();
	totaldisk = 0;
	disksize = maplist( `k, `v, storage ,
			    ``{
				integer size_in_mb = v["cyl_size"]:0 * v["cyl_count"]:0 / ( 1024 * 1024 ) ;
				totaldisk = totaldisk + size_in_mb;
				return($["device":k, "size": size_in_mb]);
			    });
	// MAC
	mac = getMAC();

	// Network
	if (Mode::initial)
	    hostaddress  = SCR::Read(.etc.install_inf.IP);
	else
	    hostaddress  = "192.168.1.1"; // FIXME

	// Hostid (i.e. a8c00101);
	hostid = getHostid();



	hostname = SCR::Read(.etc.install_inf.Hostname);
	domain = SCR::Read(.etc.install_inf.Domain);
	network = SCR::Read(.etc.install_inf.Network);
	haspcmcia = SCR::Read(.etc.install_inf.HasPCMCIA);
	xserver = SCR::Read(.etc.install_inf.XServer);

	NonLinuxPartitions = Storage::GetForeignPrimary();
	others = size(NonLinuxPartitions );
	y2milestone ("Other primaries: %1", NonLinuxPartitions);
	LinuxPartitions = Storage::GetOtherLinuxPartitions();
	linux = size(LinuxPartitions);
	y2milestone ("Other linux parts: %1",  LinuxPartitions);


	return;
    }

    /**
     * Return MAC address of active device
     */
    global define string getMAC() ``{
	string tmpmac = "";
	list ifconfig = SCR::Read(.run.ifconfig);
	string device = "";
	if (Mode::initial)
	{
	    device  = SCR::Read (.etc.install_inf.Netdevice);
	}
	else
	{
	    // Fallback
	    device = "eth0";
	}

	foreach(`dev, ifconfig, ``{
	    if (dev["name"]:"" == device)
	    {
		string link = dev["value", "link"]:"";
		list linktok = splitstring(link, " ");
		list clean = filter(`tok, linktok, ``(tok != ""));
		y2debug("mac line: %1", clean);
		tmpmac = clean[3]:"";
	    }

	});
	string cleanmac = deletechars(tmpmac, ":");
	return cleanmac;
    }


    /**
     * Return host id (hex ip )
     */
    global define string getHostid () ``{
	import "IP";
	string hex = IP::ToHex(hostaddress);
	return hex;
    }


    /**
     * Read rules file
     *
     */
    global define void Read() ``{
	import "XML";

	UserRules = XML::XMLToYCPFile( local_rules_file );

	y2milestone("Rules: %1", UserRules);

	list rulelist = UserRules["rules"]:[];

	boolean ismatch = false;
	boolean go_on = true;
	foreach ( map ruleset, rulelist, ``{
	    y2debug("Ruleset: %1", ruleset);
	    if (go_on) {
		foreach(string rule, map ruledef, ruleset, ``{
		    y2debug("Rule: %1", rule);
		    y2debug("Ruledef: %1", ruledef);

		    string match = ruledef["match"]:"undefined";

		    string op = ruledef["operator"]:"and";
		    string matchtype = ruledef["match_type"]:"exact";

		    if ( rule == "hostname")
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = hostname;
		    }
		    else if ( rule == "hostaddress")
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = hostaddress;
		    }
		    else if ( rule == "custom1" ||  rule == "custom2" || rule == "custom3" ||  rule == "custom4" || rule == "custom5")
		    {
			string script = ruledef["script"]:"exit -1";
			string tmpdir = SCR::Read( .target.tmpdir );
			string scriptPath = sformat("%1/%2", tmpdir,  "rule_" + rule);
			y2milestone("Writing rule script into %1", scriptPath);
			SCR::Write(.target.string, scriptPath, script);

			map out = SCR::Execute (.target.bash_output, "/bin/sh " + scriptPath, $[]);
			string script_result = out["stdout"]:"";
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;

			env[rule] = script_result;
		    }
		    else if ( rule == "domain" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = domain;
		    }
		    else if ( rule == "network" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = network;
		    }
		    else if ( rule == "mac" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = mac;
		    }
		    else if ( rule == "linux" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = linux;
		    }
		    else if ( rule == "others" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = others;
		    }
		    else if ( rule == "xserver" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = xserver;
		    }
		    else if ( rule == "memsize" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = memsize;
		    }
		    else if ( rule == "totaldisk" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = totaldisk;
		    }
		    else if ( rule == "haspcmcia" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = haspcmcia;
		    }
		    else if ( rule == "karch" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = karch;
		    }
		    else if ( rule == "hostid" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = hostid;
		    }
		    else if ( rule == "arch" )
		    {
			shellseg(ismatch, rule, match, op, matchtype);
			ismatch = true;
			env[rule] = arch;
		    }
		    else if ( rule == "disksize" )
		    {
			// [ $["device":"/dev/hda", "size":"100000"] ]
			list disk = splitstring(match, " ");

			// ["/dev/hda", "1000"]

			integer i = 0;
			foreach(map dev, disksize, ``{
			    string var1 = sformat("disksize_size%1", i );
			    string var2 = sformat("disksize_device%1", i );
			    shellseg(ismatch , var1 , disk[1]:"" , op, matchtype);
			    ismatch = true;
			    shellseg(ismatch, var2 , disk[0]:"" , "and", "exact");
			    env[var1] = dev["size"]:-1;
			    env[var2] = dev["device"]:"";
			    i = i + 1;
			    op = "or";
			});
		    }
		    else if ( rule == "result" )
		    {
			if ( verifyrules() == 0 )
			{
			    tomerge = add(tomerge,  ruledef["profile"]:"");
			    go_on = ruledef["continue"]:false;
			}
			else
			{
			    go_on = true;
			}
			shell = "";
			ismatch = false;
		    }

		});
	    }
	});
	return;
    }


    /**
     * Create shell command for rule verification
     */

    define void shellseg (boolean match, string var, any val, string op, string matchtype) ``{
	if (op == "and")
	    op = " -a ";
	else if (op == "or")
	    op = " -o ";

	string tmpshell = "";
	y2debug("Match type: %1", matchtype);
	if (matchtype == "exact")
	    tmpshell = tmpshell + sformat("\"$%1\" = \"%2\" ", var,  val);
	else if (matchtype == "greater")
	    tmpshell = tmpshell + sformat("\"$%1\" -gt \"%2\" ",  var,  val);
	else if (matchtype == "lower")
	    tmpshell = tmpshell + sformat("\"$%1\" -lt \"%2\" ",  var,  val);
	else if (matchtype == "range")
	{
	    list range = splitstring(val, "-");
	    y2debug("Range: %1", range);
	    tmpshell = tmpshell + sformat("\"$%1\" -gt \"%2\" -a \"$%1\" -lt \"%3\" ",  var,  range[0]:0,  range[1]:0);
	}

	if (match)
	{
	    shell = shell + sformat(" %1 %2", op, tmpshell);
	}
	else
	{
	    shell = tmpshell;
	}

    }

    /**
     * Verify rules using the shell
     */
    define verifyrules ()
    ``{

	string script = sformat("if [ %1 ]; then exit 0; else exit 1; fi", shell);
	map ret = SCR::Execute (.target.bash_output, script, env);
	y2milestone("Bash return: %1 (%2) (%3)", script, ret, env);
	return ret["exit"]:-1;
    }

    /**
     * Return list of file to merge (Order matters)
     */
    global define list Files () ``{
	return tomerge;
    }




    /**
     * Return list of file to merge (Order matters)
     */
    global define boolean GetRules () ``{

	y2milestone("Getting Rules: %1", tomerge);

	string scheme = ProfileLocation::scheme;
	string host = ProfileLocation::host;
	string filepath = ProfileLocation::filepath;
	string directory = ProfileLocation::directory;

	list valid = [];
	boolean stop = false;
	foreach(string file, tomerge,
		``{
	    if (!stop)
	    {
		string dir = ProfileLocation::dirname ( file );
		if (dir != "")
		{
		    SCR::Execute(.target.mkdir, local_rules_location + "/" + dir);
		}

		string localfile = local_rules_location + "/" + file  ;
		if (!ProfileLocation::Get( scheme, host, directory + "/" + file , localfile))
		{
		    y2error("Error while fetching file:  %1", directory + "/" + file);

		}
		else
		{
		    if (Behaviour == `one)
			stop = true;

		    valid = add(valid, file);

		}
	    }
	});
	tomerge = valid;
	if (size ( tomerge ) == 0 )
	{
	    y2milestone("No files from rules found");
	    return (false);
	}
	else
	{
	    return (true);
	}
    }


    /**
     * Merge Rule results
     * @param the resulting control file path
     * @return true on success
     */
    global define boolean Merge (  string result_profile   )
	``{

	string tmpdir = SCR::Read( .target.tmpdir );
	boolean ok = true;
	boolean skip = false;

	string base_profile  =  tmpdir + "/base_profile.xml";

	foreach(string file, tomerge,
		``{
	    y2milestone("Working on file: %1", file);

	    string current_profile = local_rules_location + "/" + file;
	    if (!skip)
	    {
		if (!XML_cleanup(current_profile,  tmpdir + "/base_profile.xml"))
		    y2error("Error reading XML file");
		skip = true;
	    }
	    else
	    {
		string MergeCommand = "/usr/bin/xsltproc --novalid --param replace \"'false'\" --param dontmerge \"'package, addon'\"  --param with ";
		MergeCommand = MergeCommand + "\"'" + current_profile + "'\"  ";
		MergeCommand = MergeCommand + "--output " +  tmpdir + "/result.xml";
		MergeCommand = MergeCommand + " /usr/share/autoinstall/xslt/merge.xslt ";
		MergeCommand = MergeCommand +   base_profile + " ";

		map xsltret = SCR::Execute(.target.bash_output, MergeCommand);
		y2milestone("Merge result: %1", xsltret);
		if (xsltret["exit"]:-1 != 0 || xsltret["stderr"]:"" != "")
		{
		    y2error("Merge Failed");
		    StdErrLog(xsltret["stderr"]:"");
		    ok =  false;
		}

		XML_cleanup(tmpdir + "/result.xml",  tmpdir + "/base_profile.xml");

	    }
	});


	SCR::Execute(.target.bash, "cp " +  tmpdir + "/base_profile.xml " + result_profile );

	y2milestone("Ok=%1", ok);
	return ok;
    }


    /**
     * Process Rules
     *
     */
    global define boolean Process(  string result_profile  )
	``{

	boolean ok = true;
	string tmpdir = SCR::Read( .target.tmpdir );
	string prefinal = local_rules_location + "/prefinal_autoinst.xml" ;
	if (!Merge (  prefinal ) )
	    return false;

	tomerge = [];


	// Now check if there any classes defined in theis pre final control file
	if (! Profile::Read( prefinal )) {
	    Popup::Error(_("Error while parsing the control file.
Check the log files for more details or fix the
control file and try again.
"));
	    return false;
	}
	y2milestone("Checking classes...");
	if ( haskey(Profile::Flat, "classes") )
	{
	    y2milestone("User defined classes available, processing....");
	    list classes = Profile::Flat["classes"]:[];
	    foreach(map class, classes,
		    ``{
		tomerge = add(tomerge,  "classes/" + class["class_name"]:"none" + "/" + class["configuration"]:"none");
	    });

	    y2milestone("New files to process: %1", tomerge);
	    Behaviour = `multiple;
	    boolean ret  = GetRules();
	    if (ret)
	    {
		tomerge = prepend(tomerge, "prefinal_autoinst.xml");
		ok = Merge ( result_profile );
	    }
	    else
	    {
		Report::Error(_("User-defined classes could not be retrieved.
Make sure all classes are defined correctly and available for this system via
the network or locally. The system will be installed with the original control file without using
classes."));
		ok = false;
		SCR::Execute(.target.bash, "cp " + prefinal + " "  + result_profile );
	    }
	}
	else
	{
	    SCR::Execute(.target.bash, "cp " + prefinal + " "  + result_profile );
	}
	y2milestone("returns=%1", ok );
	return ok;

    }


    /**
     * Create default rule in case no rules file is available
     * This adds a list of file starting from full hex ip representation to
     * only the first letter. Then default and finally mac address.
     */
    global define void CreateDefault() ``{

	Behaviour = `one;
	string tmp_hex_ip = hostid;
	tomerge = add(tomerge, tmp_hex_ip );
	while (size(tmp_hex_ip) != 1)
	{
	    tmp_hex_ip = substring(tmp_hex_ip, 0 , size ( tmp_hex_ip ) - 1 );
	    tomerge = add(tomerge, tmp_hex_ip );
	}
	tomerge = add(tomerge, mac );
	tomerge = add(tomerge, "default" );
	y2milestone("Created default rules=%1", tomerge);
	return;
    }

   /**
     * Create default rule in case no rules file is available (Only one file which is given by the user)
     */
    global define void CreateFile(string filename) ``{
	tomerge = add (tomerge, filename);
	y2milestone("Created default rules:", tomerge);
	return;
    }




    /**
     * Cleanup XML file from namespaces put by xslt
     */
    global define boolean XML_cleanup(string in, string out)
	``{

	map ycpin = XML::XMLToYCPFile(in);
	y2debug("Writing clean XML file to  %1, YCP is (%2)", out, ycpin);
	return XML::YCPToXMLFile(`profile, ycpin, out);
    }
}
