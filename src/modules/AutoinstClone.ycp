/**
 * File:
 *   modules/AutoinstClone.ycp
 *
 * Package:
 *   Autoinstallation Configuration System
 *
 * Summary:
 *   Create a control file from an exisiting machine
 *
 * Authors:
 *   Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 *
 */
{
    module "AutoinstClone";
    import "Mode";

    import "XML";
    import "Call";
    import "Profile";
    import "Y2ModuleConfig";
    import "Misc";
    import "Storage";
    import "AutoinstConfig";
    include "autoinstall/xml.ycp";

    

    global map Profile = $[];
  
    integer bytes_per_unit = 0;


    // spceial treatment for base resources
    global list base = [];

    // aditional configuration resources o be cloned
    global list additional = [];


    /**
     * Constructor
     */
    global define void AutoinstClone()``{

	Mode::normal = true;
	return;
    }

    /**
     * Set root password
     */
    define list root() ``{
	list shadow = (list) SCR::Read(.etc.shadow);
	map rootacct = (map) select(filter(map acct, shadow, ``(acct["username"]:"" == "root")), 0 , $[]);
	list users = [];
	map rootacct_mod = $[];
	rootacct_mod["user_password"] = rootacct["password"]:"";
	rootacct_mod["encrypted"] = true;
	rootacct_mod["username"] = "root";
	users = add(users, rootacct_mod);
	return users;
    }


    /**
     * Find mount points in running system
     * @param string device name
     * @param map partition
     * @param list mount points
     * @return string
     */
    define string findMountpoint(string device, map p, list mounts) ``{
	string mountPoint = "";
	foreach(map mount , mounts, ``{
	    string m = sformat("%1%2", device ,  p["nr"]:"");
	    if (mount["spec"]:"" ==  m )
	    {
		mountPoint = mount["file"]:"";
	    }
	});
	return mountPoint;
    }

    /**
     * Convert units to size
     * @param list region
     * @return integer size
     */
    define integer units_to_size (list region) ``{
	integer units = (integer) select(region,1,0);
	return (units * bytes_per_unit)  -  bytes_per_unit + 1;
    };


    /**
     * Create a partition plan for the calling client
     * @return list partition plan
     */
    global define list Partitioning()``{
	Mode::config = false;
	import "Storage";
	import "Partitions";
	map StorageMap = (map) eval(Storage::GetTargetMap());

	StorageMap = Storage::GetFsysType(StorageMap);
	y2milestone("Storagemap %1", StorageMap);
	list mounts = (list) SCR::Read(.etc.fstab);

	list drives = maplist(string k, map v, StorageMap, ``{
	    bytes_per_unit = v["cyl_size"]:1;
	    list partitions = [];
	    list winp = [];
	    list usepartitions = [];
	    foreach(map pe, v["partitions"]:[], ``{
		map new_pe = $[];
		boolean skipwin = false;
		if (haskey(pe,"fsid"))
		{
		    integer fsid = pe["fsid"]:131;
		    list wintypes = union(Partitions::fsid_wintypes, Partitions::fsid_dostypes);
		    list allwin = union(wintypes, Partitions::fsid_ntfstypes);
		    if (contains(allwin, fsid))
		    {
			y2milestone("Windows partitions found: %1", fsid );
			winp = add(winp, pe["nr"]:0);
			skipwin = true;
		    }

		    new_pe["partition_id"] = pe["fsid"]:131;
		}
		if (haskey(pe,"region"))
		{
		    new_pe["region"] = pe["region"]:[];
		    new_pe["size"] = sformat("%1", units_to_size(pe["region"]:[]));
		}
		if (haskey(pe,"used_fs"))
		{
		    new_pe["filesystem"] = pe["used_fs"]:`reiser;
		}
		if (haskey(pe,"nr"))
		{
		    if (!skipwin)
		    {
			y2milestone("Adding partition to be used: %1",  pe["nr"]:0);
			usepartitions = add(usepartitions, pe["nr"]:0);
		    }
		    new_pe["partition_nr"] = pe["nr"]:0;
		}
		string mountPoint = findMountpoint(k, pe, mounts);
		if (mountPoint != "") {
		    new_pe["mount"] = mountPoint;
		}

		if (!skipwin) {
		    partitions=add(partitions,new_pe);
		}
	    });


	    map drive = $[];
	    drive["partitions"]	= partitions;
	    drive["device"]	= k;

	    if (size(partitions) > 0 )
	    {
		if (size(winp) == 0 )
		{
		    drive["use"]	= "all";
		}
		else
		{
		    list<string> up = [];
		    foreach(integer i, usepartitions, ``{
			up=add(up,sformat("%1", i));
		    });
		    drive["use"]	= mergestring(up, ",");
		}
	    }

	    return drive;
	});
	Mode::config = true;
	return drives;
    }


    
    /**
     * Return list of software packages of calling client
     * @return list list of installed software package
     */
    global define map Software() ``{
	boolean ret = Pkg::TargetInit("/", false);
	
	base =  Pkg::GetSelections(`installed, "base");
	list addons =  Pkg::GetSelections(`installed, "addon");
	list inst = Pkg::GetPackages(`installed, true);

	Pkg::TargetFinish ();


	string tmproot = AutoinstConfig::tmpDir;
	SCR::Execute(.target.mkdir, tmproot + "/rootclone");
	Pkg::TargetInit( tmproot + "/rootclone", true);
	y2milestone("SourceStartCache: %1", Pkg::SourceStartCache(false));

	Pkg::SourceStartManager(true);

	Pkg::SetSelection( base[0]:"" );
	foreach(string addon, addons, ``{
	    Pkg::SetSelection( addon );
        });

	Pkg::ActivateSelections();

	list sel =  Pkg::GetPackages(`selected, true);
	foreach(string p, inst, ``{
	    if (!contains(sel, p))
		Pkg::PkgInstall(p);
	});

	list packages = Pkg::FilterPackages(false, false, true, true);
	Pkg::TargetFinish ();
	// Remove kernel packages
	list userpackages =  filter(string pkg, packages, ``(! regexpmatch(pkg, "k_.*")));

	map software = $[];
	software["base"] = base[0]:"";
	software["addons"] = addons;
	software["packages"] = userpackages;
	return software;
    }


    /**
     * Bootloader options
     * @return map bootloader options
     */
    global define map Bootloader()``{
	map bootloader = $[];

	boolean readret = (boolean)Call::Function("bootloader_auto", ["Read", $[] ]);
	if (readret)
	{
	    bootloader = (map)Call::Function("bootloader_auto", ["Export", $[] ]);
	}

	return bootloader;

    };


    /**
     * General options
     * @return map general options
     */
    global define map General() ``{
	import "Language";
	import "Mode";
	Mode::config = false;
	import "Keyboard";
	import "Timezone";

	map general = $[];
	general["language"] = Language::language;

	map keyboard = $[];
	y2milestone("Current Keyboard: %1", Keyboard::default_kbd);
	keyboard["keymap"]  = Keyboard::current_kbd;

	general["keyboard"] = keyboard;
	map clock = $[];
	clock["timezone"]   = Misc::SysconfigRead(.sysconfig.clock.TIMEZONE, Timezone::timezone );
	string hwclock = "";
	if ( size( Storage::GetWinPrimPartitions( Storage::GetTargetMap() ) ) > 0 )
	{
	    // Win partitions present ==> assume local time.
	    hwclock = "--localtime";
	    y2milestone("Assuming local time");
	}
	else
	{
	    // No Win partitions ==> assume UTC.
	    hwclock = "-u";
	    y2milestone("Assuming UTC");
	}
	string hwc 	    = Misc::SysconfigRead(.sysconfig.clock.HWCLOCK, hwclock);
	if (hwc == "--localtime")
	{
	    clock["hwclock"] = "localtime";
	}
	else if (hwc == "-u")
	{
	    clock["hwclock"] = "UTC";
	}
	else
	{
	    clock["hwclock"] = "";
	}
	general["clock"]    = clock;

	map mouse = $[];
	mouse["id"]	    = Misc::SysconfigRead(.sysconfig.mouse.YAST_MOUSE, "probe" );
	general["mouse"]    = mouse;
	Mode::config = true;
	return general;
    }





     /**
      * Clone a Resource
      * @param string resource
      * @param map resource name
      * @return list
      */
     define boolean CommonClone(string resource, map resourceMap) ``{


	 string data_type = resourceMap["X-SuSE-YaST-AutoInstDataType"]:"map";
	 string tomerge = resourceMap["X-SuSE-YaST-AutoInstMerge"]:"";
	 string tomergetypes = resourceMap["X-SuSE-YaST-AutoInstMergeTypes"]:"";

	 string auto = sformat("%1_auto", resource);
	 resource = resourceMap["X-SuSE-YaST-AutoInstResource"]:resource;

	 boolean readret = false;

	 map mergedResource = $[];
	 if (size(tomerge) > 0 )
	 {
	     list MergeTypes = splitstring(tomergetypes, ",");
	     list Merge = splitstring(tomerge, ",");

	     boolean readret = (boolean)Call::Function(auto , ["Read", $[] ]);
	     map result = (map)Call::Function(auto, ["Export",  Y2ModuleConfig::getResourceData(resourceMap , resource) ]);
	     y2milestone("export result: %1", result);
	     integer i = 0;
	     foreach( string res, splitstring(tomerge, ",") , ``{
		 if ( MergeTypes[i]:"map" == "map")
		 {
		     Profile::Flat[res] = result[res]:$[];

		 }
		 else
		     Profile::Flat[res] = result[res]:[];

		 y2debug("flat: %1", Profile::Flat);
		 i = i + 1;
	     });
	 }
	 else
	 {
	     if (data_type == "map")
	     {
		 readret = (boolean)Call::Function(auto , ["Read", $[] ]);
		 Profile::Flat[resource]  = Call::Function(auto, ["Export", $[] ]) ;
	     }
	     else
	     {
		 readret = (boolean)Call::Function(auto , ["Read", [] ]);
		 Profile::Flat[resource]  = Call::Function(auto, ["Export", [] ]) ;
	     }
	 }

	 return true;

     }



     /**
      * Create a list of clonable resources 
      * @return list list to be used in widgets
      */
     global define list createClonableList() 
	 ``{
	 list items = [];
	 foreach(string def_resource, map resourceMap, Y2ModuleConfig::ModuleMap, ``{
	     y2milestone("r: %1 => %2", def_resource, resourceMap["X-SuSE-YaST-AutoInstClonable"]:"false" );
	     boolean clonable = ( resourceMap["X-SuSE-YaST-AutoInstClonable"]:"false" == "true" );
	     if (clonable)
	     {
		 // Set resource name, if not using default value
		 string resource = resourceMap["X-SuSE-YaST-AutoInstResource"]:"";
		 string name = resourceMap["Name"]:"";
		 if (resource != "")
		 {
		     items = add(items, `item(`id(resource), name ) );
		 }
		 else
		 {
		     items = add(items, `item(`id(def_resource), name ) );
		 }
	     }
	 });
	 return items;
     }

    

    /**
     * Build the profile
     * @return map Profile
     */
    global define void Process()
	``{
	y2milestone("Additional resources: %1 %2", base, additional);
	Profile::Reset();
	foreach(string def_resource, map resourceMap, Y2ModuleConfig::ModuleMap, ``{
	    
	    // Set resource name, if not using default value
	    string resource = resourceMap["X-SuSE-YaST-AutoInstResource"]:def_resource;
	    y2milestone("current resource: %1", resource);
	    if (contains(additional, resource))
	    {
		boolean ret = CommonClone(def_resource, resourceMap);
	    }

	});

	if (!contains(base, "partitioning"))
	{
	    Profile::Flat["partitioning"] = Partitioning();
	}
	else
	{
	    Profile::Flat["partitioning"] = [$["use":"all"]];
	}


	if (!contains(base, "software"))
	{
	    Profile::Flat["software"] = Software();
	}
	else
	{
	    Profile::Flat["software"] = $["base":"default"];
	}

	if (!contains(base, "bootloader"))
	{
	    Profile::Flat["bootloader"] = Bootloader();
	}

	Profile::Flat["general"] = General();
	y2debug("b4 prepare: %1", Profile::Flat );
	Profile::Prepare();
	return;
    }

    /**
     * Write the profile to a defined path
     * @param string outputFile Output file path
     * @return boolean true on success
     */
    global define boolean Write(string outputFile)``{

	Process();
	boolean ret =  Profile::Save( outputFile );
	return ret;
    }


    /**
     * Export profile, Used only from within autoyast2
     * @return void
     */
    global define void Export()
	``{

	import "Profile";
	Profile::Reset();
	Process();
	return;
    }
}
