/**
 * File:
 *	modules/AIServer.ycp
 *
 * Module:
 *	AIServer
 *
 * Summary:
 *	This module handles the configuration for auto-installation server
 *
 * Authors:
 *	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{
    module "AIServer";

    // Package repository. Source directory for network installation
    global string PackageRep = "";

    // Packages::Init() called?
    global boolean PkdInitialized = false;

    // Tftp root directory
    global string Tftpboot = "/tftpboot";   
    
    // tmp dir
    global string tmpDir = "";


    ///////////////////////////////////////////////////////////////////////
    // Alice
    ///////////////////////////////////////////////////////////////////////
    global symbol aliceOutput = `load;

    global string aliceRep = "";



    ///////////////////////////////////////////////////////////////////////    
    // Kickstart
    ///////////////////////////////////////////////////////////////////////    
    global symbol ksOutput = `load;



    ///////////////////////////////////////////////////////////////////////
    // Media
    ///////////////////////////////////////////////////////////////////////    
        
    global boolean nojoliet 		= false;

    global string params 		= "";

    global string sourceDir 		= "";
    
    global string suseDir 		= "";

    string bootDir 			= "";

    global string applicationID		= "";

    global string volumePreparer 	= "SuSE Linux AG";

    global string volumeID		= "SU8100.001";

    global string publisher 	 	= "SuSE Linux AG";

    global string skelDir		= "";

    global string isoFile		= "";

    global integer totalPacs		= 0;


    // Packages Source
    global map sourceData = $[];
    global map productData = $[];
    global map mediaData = $[];
    global boolean createdNewSource = false;
    /**
     * Constructer
     *
     **/    
    global define void AIServer()
	``{
	tmpDir = SCR::Read (.target.tmpdir);
	PackageRep = Misc::SysconfigRead( .sysconfig.autoinstall.PACKAGE_REPOSITORY, "/tmp");
	return;
    }


    /**
     * Create skeleton directory
     */
    define void createSkelDir()``{
	skelDir = tmpDir + "/iso_skeleton";
	SCR::Execute(.target.mkdir, skelDir);
	return;
    }

    /**
     * initialize source
     */
    global define boolean initSource() ``{

	list theSources = [];
	string base_url = "dir://" + sourceDir;
	if (!AIConfig::PkdInitialized)
	{	    
	 		
	    theSources = Pkg::SourceStartCache (false);
	    y2milestone("sources: %1", theSources);
	    if (size (theSources) <= 0)
	    {
		y2error ("No Sources available, creating a new source.");
		theSources = [];
	    }
	    else
	    {
		foreach (`source, theSources, ``{
		    y2milestone("source: %1", source);
		    map sdata = Pkg::SourceMediaData(source);
		    
		    if (sdata["url"]:"" == base_url)
		    {
			AIConfig::theSource = source;
			boolean enable = Pkg::SourceSetEnabled(source, true);
			if (!enable)
			{
			    y2warning("Error while trying to enable source %1", source);
			    return false;
			}
		    }
		});
	    }
	    
	    if (AIConfig::theSource == -1)
	    {
		Report::Error(_("No source with this path was found,
please add the source using the source manager using the control center and
try again."));
		return false;
	    }	  
	}
	else
	{
	    y2milestone("Source already active");
	}
	
	sourceData 	= Pkg::SourceGeneralData(AIConfig::theSource);	
	productData 	= Pkg::SourceProductData(AIConfig::theSource);	
	mediaData 	= Pkg::SourceMediaData(AIConfig::theSource);

	
	if (mediaData != nil && productData != nil && sourceData != nil )
	    return true;
	else
	    return false;
    }
	    

    
    /**
     * Set paraeters for mkisofs command
     *
     */
    define initIsoParams ()
	``{
	

	string skeleton = skelDir + "/skeleton";
	
	if (nojoliet)
	{
	    params =  "-r -T -pad -no-emul-boot -boot-load-size 4 -boot-info-table";
	}
	else
	{
	    params = "-r -T -J -pad -no-emul-boot -boot-load-size 4 -boot-info-table";
	}
	string tmp_datadir = productData["datadir"]:"./suse";
	string datadir = ( substring(tmp_datadir, 0, 1 ) == ".") ? substring(tmp_datadir, 1, size(tmp_datadir)) :   tmp_datadir;
	y2milestone("Data dir: %1", datadir);
	
	suseDir = skeleton + datadir;
	
	bootDir = skeleton + "/boot/loader";

	if (applicationID == "")
	{	  	   
	    params = params + sformat(" -A \"%1\"", productData["label"]:"SuSE-Linux");	   
	}
	else
	{
	    params = params + sformat(" -A \"%1\"", applicationID);
	}
	

    }

    /**
     * Construct mkisofs command    
     * @param dest name of resulting ISO file
     * @return string mkisofs command
     */    
    global define string createISOCmd (string dest )
	``{
	
	initIsoParams ();
	string skeleton = skelDir + "/skeleton";
	
	string isotmp = SCR::Read (.target.tmpdir);
	SCR::Execute(.target.mkdir, isotmp + "/iso");
	string sortfile = isotmp + "/sortfile";

	if (SCR::Read(.target.dir, suseDir)!=nil && SCR::Read(.target.dir, bootDir)!= nil )
	{	    
	    string findstring = "find " + bootDir + " -printf \"%p 1\\n\" > " + sortfile;
	    integer ret = SCR::Execute (.target.bash, findstring);
	    
	    params = params + sformat(" -sort %1  -b boot/loader/isolinux.bin -c boot.cat", sortfile);
	    y2milestone("found boot image. Making CD bootable.");
	    SCR::Execute(.target.mkdir, sformat("%1/iso/boot/loader", isotmp));

	}
	else
	{
	    y2milestone("found no boot image. No bootable CD will be created.");
	    return "";
	}
	
	string mkisofs = sformat("mkisofs -p \"%1\" -V\"%2\" -P \"%3\" %4 -o %5 %6/iso %7", volumePreparer, volumeID, publisher, params, dest, isotmp, skeleton);
	return mkisofs;
    }

    /**
     * Create Skeleton
     *
     */

    global define createISOSkeleton () ``{
	list commands = [];
	integer ret = 0;
	boolean success = true;
	createSkelDir();
	
	y2milestone("creating skeleton in %1", skelDir);
	
	SCR::Execute(.target.mkdir, sformat("%1/skeleton/%2", skelDir, productData["datadir"]:"./suse"));
	commands= add(commands, sformat("/bin/cp -a %1/boot %2/skeleton", sourceDir, skelDir));
	commands= add(commands, sformat("/bin/mkdir -p   %1/skeleton/%2",  skelDir, productData["descrdir"]:"./suse/setup/descr"));
	commands= add(commands, sformat("/bin/cp -a %1/%2 %3/skeleton/%4", sourceDir,  productData["descrdir"]:"./suse/setup/descr", skelDir,  productData["descrdir"]:"./suse/setup/descr"));
	commands= add(commands, sformat("/bin/cp  %1/* %2/skeleton/", sourceDir, skelDir));
	commands= add(commands, sformat("/bin/mkdir -p   %1/skeleton/media.1",  skelDir));
	commands= add(commands, sformat("/bin/cp %1/media.1/products   %2/skeleton/media.1/products",  sourceDir , skelDir));
	
	foreach (`c, commands, ``{
	    ret = SCR::Execute (.target.bash, c);
	    if (ret != 0)
	    {
		success= false;
	    }
	});
	SCR::Write(.target.string,   sformat("%1/skeleton/media.1/media",  skelDir),  readMedia());
	list pacdirs = ["i386", "i586", "noarch"];
	foreach(`dir, pacdirs, ``{
	    string dirname =  sformat("%1/skeleton/%2/%3", skelDir, productData["datadir"]:"./suse", dir);
	    SCR::Execute (.target.mkdir, dirname);
	});
	return success;
    }

    /**
     * Parse media data
     */
    global define string readMedia() ``{
	string media = SCR::Read(.target.string,  sourceDir + "/media.1/media");
	list media_data = splitstring(media, "\n");	
	return (mergestring( [media_data[0]:"",media_data[1]:"", "1"] , "\n"));
    }
 
}
