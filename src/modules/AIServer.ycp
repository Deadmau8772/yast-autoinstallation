/**
 * File:
 *	modules/AIServer.ycp
 *
 * Module:
 *	AIServer
 *
 * Summary:
 *	This module handles the configuration for auto-installation server
 *
 * Authors:
 *	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{
    module "AIServer";

    // Package repository. Source directory for network installation
    global string PackageRep = "";

    // Packages::Init() called?
    global boolean PkdInitialized = false;

    // Tftp root directory
    global string Tftpboot = "/tftpboot";   
    
    // tmp dir
    global string tmpDir = "";


    ///////////////////////////////////////////////////////////////////////
    // Alice
    ///////////////////////////////////////////////////////////////////////
    global symbol aliceOutput = `load;

    global string aliceRep = "";



    ///////////////////////////////////////////////////////////////////////    
    // Kickstart
    ///////////////////////////////////////////////////////////////////////    
    global symbol ksOutput = `load;



    ///////////////////////////////////////////////////////////////////////
    // Media
    ///////////////////////////////////////////////////////////////////////    
        
    global boolean nojoliet 		= false;

    global string params 		= "";

    global string sourceDir 		= "";
    
    global string suseDir 		= "";

    string bootDir 			= "";

    global string applicationID		= "";

    global string volumePreparer 	= "SuSE Linux AG";

    global string volumeID		= "SU8100.001";

    global string publisher 	 	= "SuSE Linux AG";

    global string skelDir		= "";

    global string isoFile		= "";

    global integer totalPacs		= 0;


    // Packages Source
    global map sourceData = $[];
    global map productData = $[];
    global map mediaData = $[];
    
    /**
     * Constructer
     *
     **/    
    global define void AIServer()
	``{
	tmpDir = SCR::Read (.target.tmpdir);
	PackageRep = Misc::SysconfigRead( .sysconfig.autoinstall.PACKAGE_REPOSITORY, "/tmp");
	return;
    }


    /**
     *
     */
    define void createSkelDir()``{
	skelDir = tmpDir + "/iso_skeleton";
	SCR::Execute(.target.mkdir, skelDir);
	return;
    }

    /**
     *
     */
    global define boolean initSource() ``{

	list theSources = [];
	if (!AIConfig::PkdInitialized)
	{	    
	    string grepCmd = sformat("grep \"^VERSION\" %1/content | cut -d' ' -f 2",  sourceDir);
	    map out = SCR::Execute(.target.bash_output, grepCmd);
	    list version_raw = splitstring(out["stdout"]:"",  "\n");
	    string version = version_raw[0]:"";
	    y2milestone("version :%1", version);
	    if (version == "")
	    {
		y2error("Non-valid package repository..");
		return false;
	    }
		
	    theSources = Pkg::SourceStartCache (true);
	    y2milestone("sources: %1", theSources);
	    if (size (theSources) <= 0)
	    {
		y2error ("Pkg::SourceStartCache failed");
		theSources = [];		
	    }
	    else
	    {
		foreach (`source, theSources, ``{
		    y2milestone("source: %1", source);
		    map pdata = Pkg::SourceProductData (source);
		    y2milestone("data %1", pdata);
		    if (contains(splitstring(pdata["productversion"]:"","-"), version))
		    {
			AIConfig::theSource = source;
		    }
		});
	    }
	    
	    if (AIConfig::theSource == -1) {
		y2milestone("creating new source");
		string base_url = "dir://" + sourceDir;
		integer ret = Pkg::SourceCreate (base_url);
		  
		if (ret!=nil)
		{
		    AIConfig::theSource = ret;
		}	  
	    }

	  
	}
	else
	{
	    y2milestone("Source already active");
	}
	
	sourceData 	= Pkg::SourceGeneralData(AIConfig::theSource);	
	productData 	= Pkg::SourceProductData(AIConfig::theSource);	
	mediaData 	= Pkg::SourceMediaData(AIConfig::theSource);

	
	if (mediaData != nil && productData != nil && sourceData != nil )
	    return true;
	else
	    return false;
    }
	    

    
    /**
     * Set paraeters for mkisofs command
     *
     */
    define initIsoParams ()
	``{
	

	string skeleton = skelDir + "/skeleton";
	
	if (nojoliet)
	{
	    params =  "-r -T -pad -no-emul-boot -boot-load-size 4 -boot-info-table";
	}
	else
	{
	    params = "-r -T -J -pad -no-emul-boot -boot-load-size 4 -boot-info-table";
	}
	string tmp_datadir = productData["datadir"]:"./suse";
	string datadir = ( substring(tmp_datadir, 0, 1 ) == ".") ? substring(tmp_datadir, 1, size(tmp_datadir)) :   tmp_datadir;
	y2milestone("Data dir: %1", datadir);
	
	suseDir = skeleton + datadir;
	
	bootDir = skeleton + "/boot/loader";

	if (applicationID == "")
	{	  	   
	    params = params + sformat(" -A \"%1\"", productData["label"]:"SuSE-Linux");	   
	}
	else
	{
	    params = params + sformat(" -A \"%1\"", applicationID);
	}
	

    }

    /**
     * Construct mkisofs command    
     * @param dest name of resulting ISO file
     * @return string mkisofs command
     */    
    global define string createISOCmd (string dest )
	``{
	
	initIsoParams ();
	string skeleton = skelDir + "/skeleton";
	
	string isotmp = SCR::Read (.target.tmpdir);
	SCR::Execute(.target.mkdir, isotmp + "/iso");
	string sortfile = isotmp + "/sortfile";

	if (SCR::Read(.target.dir, suseDir)!=nil && SCR::Read(.target.dir, bootDir)!= nil )
	{	    
	    string findstring = "find " + bootDir + " -printf \"%p 1\\n\" > " + sortfile;
	    integer ret = SCR::Execute (.target.bash, findstring);
	    
	    params = params + sformat(" -sort %1  -b boot/loader/isolinux.bin -c boot.cat", sortfile);
	    y2milestone("found boot image. Making CD bootable.");
	    SCR::Execute(.target.mkdir, sformat("%1/iso/boot/loader", isotmp));

	}
	else
	{
	    y2milestone("found no boot image. No bootable CD will be created.");
	    return "";
	}
	
	string mkisofs = sformat("mkisofs -p \"%1\" -V\"%2\" -P \"%3\" %4 -o %5 %6/iso %7", volumePreparer, volumeID, publisher, params, dest, isotmp, skeleton);
	return mkisofs;
    }

    /**
     * Create Skeleton
     *
     */

    global define createISOSkeleton () ``{
	list commands = [];
	integer ret = 0;
	boolean success = true;
	createSkelDir();
	
	y2milestone("creating skeleton in %1", skelDir);
	
	SCR::Execute(.target.mkdir, sformat("%1/skeleton/%2", skelDir, productData["datadir"]:"./suse"));
	commands= add(commands, sformat("/bin/cp -a %1/boot %2/skeleton", sourceDir, skelDir));
	commands= add(commands, sformat("/bin/mkdir -p   %1/skeleton/%2",  skelDir, productData["descrdir"]:"./suse/setup/descr"));
	commands= add(commands, sformat("/bin/cp -a %1/%2 %3/skeleton/%4", sourceDir,  productData["descrdir"]:"./suse/setup/descr", skelDir,  productData["descrdir"]:"./suse/setup/descr"));
	commands= add(commands, sformat("/bin/cp  %1/* %2/skeleton/", sourceDir, skelDir));
	commands= add(commands, sformat("/bin/mkdir -p   %1/skeleton/media.1",  skelDir));
	commands= add(commands, sformat("/bin/cp %1/media.1/products   %2/skeleton/media.1/products",  sourceDir , skelDir));
	
	foreach (`c, commands, ``{
	    ret = SCR::Execute (.target.bash, c);
	    if (ret != 0)
	    {
		success= false;
	    }
	});
	SCR::Write(.target.string,   sformat("%1/skeleton/media.1/media",  skelDir),  readMedia());
	list pacdirs = ["i386", "i586", "noarch"];
	foreach(`dir, pacdirs, ``{
	    string dirname =  sformat("%1/skeleton/%2/%3", skelDir, productData["datadir"]:"./suse", dir);
	    SCR::Execute (.target.mkdir, dirname);
	});
	return success;
    }

    /**
     * Parse media data
     */
    global define string readMedia() ``{
	string media = SCR::Read(.target.string,  sourceDir + "/media.1/media");
	list media_data = splitstring(media, "\n");	
	return (mergestring( [media_data[0]:"",media_data[1]:"", "1"] , "\n"));
    }
 
}
