/**
 * File:	modules/AutoinstSoftware.ycp
 * Package:	Autoyast
 * Summary:	Software
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 */
{
    module "AutoinstSoftware";
    textdomain "autoinst";

    import "Profile";
    import "Summary";
    import "Mode";
    import "SpaceCalculation";
    import "Packages";
    import "Report";
    import "Popup";
    import "Report";
    import "Language";
    import "Kernel";
    import "AutoinstConfig";
    import "ProductControl";
    import "AutoinstImage";
    import "Storage";

    import "PackageAI";

    global map Software = $[];

    // Base selection
    global string base = "";

    // Add-on selections
    global list<string> addons = [];

    // Individual packages
    global list<string> packages = [];

    // Kernel, force type of kernel to be installed
    global string kernel = "";

    // Packages that should be installed in continue mode
    global list<string> post_packages = [];

    // Package that should be removed from list, and not installed
    global list<string> remove_packages = [];

    // Additional languages for packages
    global list<string> additional_locales = [];


    global string ft_module = "";
    boolean imaging = false;


    /**
     * Import data
     * @param settings settings to be imported
     * @return true on success
     */
    global define boolean Import(map settings) ``{

	Software = settings;
	base = settings["base"]:"";
	addons = settings["addons"]:[];
	additional_locales = settings["additional_locales"]:[];
	packages = (list<string>)union(settings["packages"]:[], PackageAI::toinstall) ;
	kernel = settings["kernel"]:"";
	post_packages = settings["post-packages"]:[];
	remove_packages = (list<string>)union ( settings["remove-packages"]:[], PackageAI::toremove );


        // Imaging
        map<string, any> image = settings["system_images"]:$[];
        imaging = image["enable_multicast_images"]:false;
        ft_module = image["module_name"]:"";

	return true;
    }
    /**
     * Constructer
     */
    global define void AutoinstSoftware() ``{
	if ( Mode::cont )
	{
	    Import(Profile::Flat["software"]:$[]);
	}

    }

    /**
     * Export data
     * @return dumped settings (later acceptable by Import())
     */
    global define map Export() ``{

	map s = $[];
	if (base != "")
	    s["base"] = base ;
	if (kernel != "")
	    s["kernel"] = kernel ;

	if (addons != [])
	    s["addons"] = addons ;

	if (packages != [])
	    s["packages"] = packages ;

	if (post_packages != [])
	    s["post-packages"] = post_packages ;

	if (remove_packages != [])
	    s["remove-packages"] = remove_packages ;


	return (s);
    }


    /**
     * Add packages needed by modules, i.e. NIS, NFS etc.
     * @param list of strings packages to add
     * @return void
     */
    global define void AddModulePackages(list<string> module_packages)
	``{
	packages = toset((list<string>) union(packages,  module_packages));
	//
	// Update profile
	//
	Profile::Flat["software"] = Export();
	return;
    }

    /**
     * Remove packages not needed by modules, i.e. NIS, NFS etc.
     * @param list of packages to remove
     * @return void
     */
    global define void RemoveModulePackages (list<string> module_packages) ``{
	packages = filter(string p, packages, ``(!contains(module_packages,p)));
	Profile::Flat["software"] = Export();
	return;
    }



    /**
     * Summary
     * @return Html formatted configuration summary
     */
    global define string Summary()``{
	string summary = "";
	summary = Summary::AddHeader(summary, _("Base Selection"));
	summary = Summary::AddLine(summary, (base != "") ?
				   base : Summary::NotConfigured());
	summary = Summary::AddHeader(summary, _("Add-on Selections"));
	if (size( addons) > 0 )
	{
	    summary = Summary::OpenList(summary);
	    foreach(string a, addons, ``{
		summary = Summary::AddListItem(summary, a);
	    });
	    summary = Summary::CloseList(summary);
	}
	else
	{
	    summary = Summary::AddLine(summary, Summary::NotConfigured());
	}
	summary = Summary::AddHeader(summary, _("Individually Selected Packages"));
	summary = Summary::AddLine(summary, sformat("%1", size(packages)));

	return summary;
    }
    /**
     * Compute list of packages selected by user and other packages needed for important
     * configuration modules.
     * @return list of strings list of packages needed for autoinstallation
     */
    global define list<string> autoinstPackages()
	``{

	list<string> allpackages = [];

	// the primary list of packages
	allpackages = (list<string>) union (allpackages,  packages);

	// In autoinst mode, a kernel should not be  available
	// in <packages>
	if ( size(kernel) == 0)
	{
            string the_kernel = Packages::ComputeKernelPackage();
	    allpackages = add (allpackages, the_kernel);
	}
	else
	{
	    if (Pkg::IsAvailable (kernel))
	    {
		allpackages = add (allpackages, kernel);
	    }
	    else
	    {
		y2warning ("%1 not available, using kernel-default", kernel);
		allpackages = add (allpackages, "kernel-default");
	    }
	}


	if (haskey(Profile::Flat, "nis")) {
		map conf = Profile::Flat["nis"]:$[];
		if (conf["start_nis"]:false)
			allpackages = (list<string>) union(allpackages, ["yast2-nis-client","ypbind"]);

                if (conf["start_autofs"]:false)
                {
                    string pkg = "autofs";
                    if (! contains ( allpackages, "autofs4"))
                    {
                        allpackages = add (allpackages, pkg);
                    }
                }

	}

	if (haskey(Profile::Flat, "ldap")) {
		map ldapclient = Profile::Flat["ldap"]:$[];
		if (ldapclient["start_ldap"]:false)
			allpackages = (list<string>) union(allpackages, ["pam_ldap","nss_ldap"]);
	}

	if (haskey(Profile::Flat, "nfs_server"))
	{
	    boolean start_nfsserver = Profile::Flat["nfs_server", "start_nfsserver"]:false;
	    if (start_nfsserver)
		allpackages = (list<string>) union(allpackages, ["yast2-nfs-server", "nfs-utils"]);
	}


	if (haskey(Profile::Flat, "mail")) {
		map mail = Profile::Flat["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			allpackages = add(allpackages, "postfix");
			remove_packages = add(remove_packages, "sendmail");
			if (mail["use_amavis"]:false)
				allpackages = add(allpackages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			allpackages = add(allpackages, "sendmail");
			remove_packages = add(remove_packages, "postfix");

			if (mail["use_amavis"]:false)
				allpackages = add(allpackages, "amavis-sendmail");
		}
	}
	return allpackages;
    }



    /**
     * Configure software settings
     * @param void
     * @return boolean
     */
    global define boolean Write()
	``{

        if (imaging)
        {
            if (ft_module!="")
            {
                ProductControl::DisabledModules=add(ProductControl::DisabledModules, "kickoff");
                ProductControl::DisabledModules=add(ProductControl::DisabledModules, "rpmcopy");
                AutoinstImage::enabled = true;
                return true;
            }
        }

	boolean ok = true;
	Pkg::SetLocale (Language::language);
        additional_locales=add(additional_locales, Language::language );
        Pkg::SetAdditionalLocales(toset(additional_locales));

	Packages::Init(true);
	string  base_selection = base;
	if (size(base_selection) > 0)
	{
	    if (! Pkg::SetSelection( base_selection ))
	    {
		y2error("Error while setting base selection: %1", base_selection);
		Report::Error(sformat(_("Could not set base selection: %1"), base_selection));
		return false;
	    }
	}
	else
	{
	    Popup::Warning(_("Base selection is not set in control file.
If packages to install have been added individually, 
this message can be ignored."));
	}

	list<string> failed = [];

	foreach(string s, toset(addons),
		``{
	    if (!Pkg::SetSelection( s ))
	    {
		failed = add(failed, s);
	    }
	});

	list<string> failed_again = [];

	if (size(failed) > 0 )
	{
	    foreach(string s, failed,
		    ``{
		if (!Pkg::SetSelection( s ))
		{
		    failed_again = add(failed_again, s);
		}
	    });
	}
	if (size(failed_again) > 0 )
	{
	    y2error("Error while setting-addon selection: %1",  mergestring(failed_again, ","));
	    Report::Warning(sformat(_("Could not set add-on selections: %1"), mergestring(failed_again, ",")));
	}

	if (!Pkg::ActivateSelections())
	{
	    return false;
	}


	list<string> autoinstPacks = autoinstPackages ();
	y2debug("Packages selected in autoinstall mode: %1", autoinstPacks);

	if (size(autoinstPacks) > 0 )
	{
	    y2milestone("Installing individual packages: %1", Pkg::DoProvide(autoinstPacks) );
	}


	list<string> computed_packages = Packages::ComputeSystemPackageList();
	y2debug("Computed list of packages: %1", computed_packages);


	//
	// Now remove all packages listed in remove-packages
	//
	y2milestone("Packages to be removed: %1", remove_packages);
	if (size(remove_packages) > 0 )
	{
	    foreach (string rp, remove_packages, ``{
		Pkg::PkgNeutral(rp);
	    });

	    Pkg::DoRemove(remove_packages);
	}
        list<string> pack = Storage::AddPackageList();
        if( size(pack)>0 )
        {
            y2milestone("Installing storage packages: %1", Pkg::DoProvide( pack ));
        }
	//
	// Solve dependencies
	//
	Pkg::PkgSolve(false);

	SpaceCalculation::ShowPartitionWarning();
	y2milestone( "INSTALLING Software Selection: base(%1), addon(%2)",
		     Pkg::GetSelections(`selected, "base"),
		     Pkg::GetSelections(`selected, ""));

	return (ok);
    }


    /**
     * Initialize temporary target
     */
    global define void  pmInit() ``{

	string tmproot = AutoinstConfig::tmpDir;

	SCR::Execute(.target.mkdir, tmproot + "/root");
	Pkg::TargetInit( tmproot + "/root", true);
	y2milestone("SourceStartCache: %1", Pkg::SourceStartCache(false));
	return;
    }


    /**
     * Add post packages
     * @param list calculated post packages
     * @return void
     */
    global define void addPostPackages(list<string> calcpost) ``{	
	post_packages = (list<string>)toset(union(calcpost,post_packages));
	return;
    }
    
    //EOF
}
