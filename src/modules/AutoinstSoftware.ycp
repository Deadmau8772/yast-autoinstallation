/**
 * File:	modules/AutoinstSoftware.ycp
 * Package:	Autoyast
 * Summary:	Software
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 */
{
    module "AutoinstSoftware";
    textdomain "autoinst";

    import "Profile";
    import "Summary";
    import "Mode";
    import "SpaceCalculation";
    import "Packages";
    import "Report";
    import "Popup";
    import "Report";    
    import "Language";


    global map Software = $[];

    global string base = "";
    global list addons = [];
    global list packages = [];
    global string kernel = "";
    global list post_packages = [];
    global list remove_packages = [];
    global list delete_packages = [];

    global list forcedPackages = [];

 


    /**
     * Import data
     * @param settings settings to be imported
     * @return true on success
     */
    global define boolean Import(map settings) ``{

	Software = settings;
	base = settings["base"]:"";
	addons = settings["addons"]:[];
	packages = settings["packages"]:[];
	kernel = settings["kernel"]:"";
	post_packages = settings["post-packages"]:[];
	remove_packages = settings["remove-packages"]:[];

	return true;
    }


    /**
     * Constructer
     */
    global define void AutoinstSoftware() ``{
	if ( Mode::cont )
	{	    
	    Import(Profile::Flat["software"]:$[]);
	}

    }

    /**
     * Export data
     * @return dumped settings (later acceptable by Import())
     */
    global define map Export() ``{

	map s = $[];
	if (base != "")
	    s["base"] = base ;
	if (kernel != "")
	    s["kernel"] = kernel ;

	if (addons != [])
	    s["addons"] = addons ;

	if (packages != [])
	    s["packages"] = packages ;

	if (post_packages != [])
	    s["post-packages"] = post_packages ;

	if (remove_packages != [])
	    s["remove-packages"] = remove_packages ;


	return (s);
    }


    /**
     * Add packages needed by modules, i.e. NIS, NFS etc.
     * @param list of packages to add
     * @return void
     */
    global define void AddModulePackages(list module_packages) ``{
	packages = toset(union(packages,  module_packages));
	
	//
	// Update profile
	//	
	Profile::Flat["software"] = Export();
	return;
    }

    
    /**
     * Remove packages not needed by modules, i.e. NIS, NFS etc.
     * @param list of packages to remove
     * @return void
     */
    global define void RemoveModulePackages (list module_packages) ``{
	packages = filter(string p, packages, ``(!contains(module_packages,p)));
	
	Profile::Flat["software"] = Export();
	return;
    }



    /**
     * Summary
     * @return Html formatted configuration summary
     */
    global define string Summary()``{
	string summary = "";
	summary = Summary::AddHeader(summary, _("Base Selection"));
	summary = Summary::AddLine(summary, (base != "") ?
				   base : Summary::NotConfigured());
	summary = Summary::AddHeader(summary, _("Add-on Selections"));
	if (size( addons) > 0 )
	{
	    summary = Summary::OpenList(summary);
	    foreach(string a, addons, ``{
		summary = Summary::AddListItem(summary, a);
	    });
	    summary = Summary::CloseList(summary);
	}
	else
	{
	    summary = Summary::AddLine(summary, Summary::NotConfigured());
	}
	summary = Summary::AddHeader(summary, _("Individually Selected Packages"));
	summary = Summary::AddLine(summary, sformat("%1", size(packages)));

	return summary;
    }



    /**
     * Configure software settings
     * @param void
     * @return boolean
     */
    global define boolean Write()
	``{
	boolean ok = true;
	
	Pkg::SetLocale (Language::language);

	Packages::Init(true);
		
	string  base_selection = base;
	
	if (size(base_selection) > 0)
	{
	    if (! Pkg::SetSelection( base_selection ))
	    {
		y2error("Error while setting base selection: %1", base_selection);
		Report::Error(sformat(_("Could not set base selection: %1"), base_selection));
		return false;
	    }
	}
	else
	{
	    Popup::Warning(_("Base selection is not configured in control file.
If packages to install have been added individually, 
this message can be ignored."));
	}

	
	list failed = [];
	
	foreach(string s, toset(addons),
		``{
	    if (!Pkg::SetSelection( s ))
	    {
		failed = add(failed, s);
	    }
	});

	list failed_again = [];
	
	if (size(failed) > 0 )
	{
	    foreach(string s, failed,
		    ``{
		if (!Pkg::SetSelection( s ))
		{
		    failed_again = add(failed_again, s);
		}
	    });
	}
	if (size(failed_again) > 0 )
	{
	    y2error("Error while setting-addon selection: %1", s);
	    Report::Warning(_("Could not set add-on selections: %1"), mergestring(failed_again, ","));
	}

	if (!Pkg::ActivateSelections())
	{
	    return false;
	}


	list autoinstPacks = autoinstPackages ();
	y2milestone("Packages selected in autoinstall mode: %1", autoinstPacks);

	if (size(autoinstPacks) > 0 )
	{
	    Pkg::DoProvide(autoinstPacks);
	}

	
	list computed_packages = Packages::ComputeSystemPackageList();
	y2milestone("Computed list of packages: %1", computed_packages);
	

	//
	// Now remove all packages listed in remove-packages 
	//
	y2milestone("Packages to be removed: %1", remove_packages);
	if (size(remove_packages) > 0 )
	{
	    foreach (string rp, remove_packages, ``{
		Pkg::PkgNeutral(rp);
	    });

	    Pkg::DoRemove(remove_packages);
	}

	//
	// Solve dependencies
	//
	Pkg::PkgSolve();
	
	SpaceCalculation::ShowPartitionWarning();
	y2milestone( "INSTALLING Software Selection: base(%1), addon(%2)",
		     Pkg::GetSelections(`selected, "base"),
		     Pkg::GetSelections(`selected, ""));

	return (ok);
    }

    /**
     * Compute list of packages selected by user and other packages needed for important
     * configuration modules.
     */
    
    global define list autoinstPackages()
	``{
	
	list allpackages = [];
	
	// the primary list of packages
	allpackages = union (allpackages,  packages);

	// In autoinst mode, a kernel should not be  available
	// in <packages>
	if ( size(kernel) == 0)
	{
	    import "Kernel";
	    if (Pkg::IsAvailable (Kernel::kernel_packages[0]:"k_deflt"))
	    {
		allpackages = union (allpackages, Kernel::kernel_packages);
	    }
	    else
	    {
		y2warning ("%1 not available, using k_deflt", Kernel::kernel_packages);
		allpackages = add (allpackages, "k_deflt");
	    }	   
	}
	else
	{
	    if (Pkg::IsAvailable (kernel))
	    {
		allpackages = add (allpackages, kernel);
	    }
	    else
	    {
		y2warning ("%1 not available, using k_deflt", Kernel::kernel_packages);
		allpackages = add (allpackages, "k_deflt");
	    }	   	    
	}



	if (haskey(Profile::Flat, "ldap")) {
		map ldapclient = Profile::Flat["ldap"]:$[];
		if (ldapclient["start_ldap"]:false)
			allpackages = union(allpackages, ["pam_ldap","nss_ldap"]);
	}

	if (haskey(Profile::Flat, "nfs_server"))
	{
	    boolean start_nfsserver = Profile::Flat["nfs_server", "start_nfsserver"]:false;
	    if (start_nfsserver)
		allpackages = union(allpackages, ["yast2-nfs-server", "nfs-utils"]);
	}


	if (haskey(Profile::Flat, "nisplus")) {
		map nisplus = Profile::Flat["nisplus"]:$[];
		if (nisplus["start_nisplus"]:false)
			allpackages = add(allpackages, "nis-utils");
	}
	if (haskey(Profile::Flat, "mail")) {
		map mail = Profile::Flat["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			allpackages = add(allpackages, "postfix");
			remove_packages = add(remove_packages, "sendmail");
			if (mail["use_amavis"]:false)
				allpackages = add(allpackages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			allpackages = add(allpackages, "sendmail");
			remove_packages = add(remove_packages, "postfix");

			if (mail["use_amavis"]:false)
				allpackages = add(allpackages, "amavis-sendmail");
		}
	}
	
	return allpackages;
    }

    //EOF
}
