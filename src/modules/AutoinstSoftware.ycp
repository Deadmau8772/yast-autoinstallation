/**
 * File:	modules/AutoinstSoftware.ycp
 * Package:	Autoyast
 * Summary:	Software
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 *
 */
{
    module "AutoinstSoftware";
    textdomain "autoinst";

    import "Profile";
    import "Summary";
    import "Stage";
    import "SpaceCalculation";
    import "Packages";
    import "Popup";
    import "Report";
    import "Kernel";
    import "AutoinstConfig";
    import "ProductControl";
    import "Storage";
    import "Mode";

    // All shared data are in yast2.rpm to break cyclic dependencies
    import "AutoinstData";

    import "PackageAI";

    global map Software = $[];

    global map<string, any> image = $[];

    // patterns
    global list<string> patterns = [];

    // Kernel, force type of kernel to be installed
    global string kernel = "";

    // Packages that should be installed in continue mode
    // AutoinstData::post_packages = [];

    global string ft_module = "";

    /* Enable Imaging */
    global boolean imaging = false;

    /* default value of settings modified */
    global boolean modified = false;

    global list<string> inst = [];
    global map<string,boolean> fulfilled_cache = $[];

    /**
     * Function sets internal variable, which indicates, that any
     * settings were modified, to "true"
     */
    global define void SetModified ()
    {
        modified = true;
    }

    /**
     * Functions which returns if the settings were modified
     * @return boolean  settings were modified
     */
    global define boolean GetModified ()
    {
        return modified;
    }


    /**
     * Import data
     * @param settings settings to be imported
     * @return true on success
     */
    global define boolean Import(map settings)
    {
        Software = settings;
        patterns = settings["patterns"]:[];

        string notFound = "";
        Packages::Init(true);
        Packages::InitializeAddOnProducts();
        foreach( string pack, settings["packages"]:[], ``{
            if( ! Pkg::IsAvailable(pack) && Stage::initial() ) {
                notFound = notFound + pack + "\n";
            }
        });
        if( size(notFound) > 0 ) {
            y2error("packages not found: %1",notFound);
            // warning text during the installation. %1 is a list of package names
            Report::Error( sformat(_("These packages could not be found in the software repositories:\n%1"), notFound));
        }

        PackageAI::toinstall  = settings["packages"]:[];
        kernel = settings["kernel"]:"";
        AutoinstData::post_packages = settings["post-packages"]:[];
        AutoinstData::post_patterns = settings["post-patterns"]:[];
        PackageAI::toremove  =  settings["remove-packages"]:[];

        /* Imaging */
        /*
        map<string, any> image = settings["system_images"]:$[];
        imaging = image["enable_multicast_images"]:false;
        ft_module = image["module_name"]:"";
        if (settings == $[])
            modified = false;
        else
            modified = true;
        */
        image = settings["image"]:$[];
        if( size(image) > 0 )
            imaging=true;

        return true;
    }

    /**
     * Constructer
     */
    global define void AutoinstSoftware()
    {
        if ( Stage::cont () && Mode::autoinst ())
        {
	    Pkg::TargetInit ("/", false);
            Import(Profile::current["software"]:$[]);
        }
        return;
    }

    /**
     * Export data
     * @return dumped settings (later acceptable by Import())
     */
    global define map Export()
    {
        map s = $[];
        if (kernel != "")
            s["kernel"] = kernel ;

        if( patterns != [])
            s["patterns"] = patterns;

        if (PackageAI::toinstall != [])
            s["packages"] = PackageAI::toinstall;

        if (AutoinstData::post_packages != [])
            s["post-packages"] = AutoinstData::post_packages ;

        if (PackageAI::toremove != [])
            s["remove-packages"] = PackageAI::toremove;


        return (s);
    }


    /**
     * Add packages needed by modules, i.e. NIS, NFS etc.
     * @param list of strings packages to add
     * @return void
     */
    global define void AddModulePackages(list<string> module_packages)
    {
        PackageAI::toinstall = toset((list<string>)
                union(PackageAI::toinstall,  module_packages));
        //
        // Update profile
        //
        Profile::current["software"] = Export();
        return;
    }

    /**
     * Remove packages not needed by modules, i.e. NIS, NFS etc.
     * @param list of packages to remove
     * @return void
     */
    global define void RemoveModulePackages (list<string> module_packages)
    {
        PackageAI::toinstall = filter(string p, PackageAI::toinstall, ``(!contains(module_packages,p)));
        Profile::current["software"] = Export();
        return;
    }



    /**
     * Summary
     * @return Html formatted configuration summary
     */
    global define string Summary()
    {
        string summary = "";
        
        summary = Summary::AddHeader(summary, _("Selected Patterns"));
        if (size( patterns ) > 0 )
        {
            summary = Summary::OpenList(summary);
            foreach(string a, patterns, ``{
                summary = Summary::AddListItem(summary, a);
            });
            summary = Summary::CloseList(summary);
        }
        else
        {
            summary = Summary::AddLine(summary, Summary::NotConfigured());
        }
        summary = Summary::AddHeader(summary, _("Individually Selected Packages"));
        summary = Summary::AddLine(summary, sformat("%1",
                    size(PackageAI::toinstall)));

        summary = Summary::AddHeader(summary, _("Packages to Remove"));
        summary = Summary::AddLine(summary, sformat("%1",
                    size(PackageAI::toremove)));

        if (kernel != "")
        {
            summary = Summary::AddHeader(summary, _("Force Kernel Package"));
            summary = Summary::AddLine(summary, sformat("%1", kernel));
        }
        return summary;
    }
    /**
     * Compute list of packages selected by user and other packages needed for important
     * configuration modules.
     * @return list of strings list of packages needed for autoinstallation
     */
    global define list<string> autoinstPackages()
    {

        list<string> allpackages = [];

        // the primary list of packages
        allpackages = (list<string>) union (allpackages,  PackageAI::toinstall);

        // In autoinst mode, a kernel should not be  available
        // in <packages>
        if ( size(kernel) == 0)
        {
            list <string> kernel_pkgs = Kernel::ComputePackages ();
            allpackages = (list <string>) union (allpackages, kernel_pkgs);
        }
        else
        {
            if (Pkg::IsAvailable (kernel))
            {
                allpackages = add (allpackages, kernel);
                string kernel_nongpl = kernel + "-nongpl";

                if (Pkg::IsAvailable (kernel_nongpl))
                    allpackages = add (allpackages, kernel_nongpl);
            }
            else
            {
                y2warning ("%1 not available, using kernel-default", kernel);
                list <string> kernel_pkgs = Kernel::ComputePackages ();
                allpackages = (list <string>) union (allpackages, kernel_pkgs);
            }
        }

        if (haskey(Profile::current, "inetd")) {
                map conf = Profile::current["inetd"]:$[];
                if (conf["netd_service"]:`none == `xinetd )
                        allpackages = (list<string>) union(allpackages,
                                ["xinetd"]);
                else
                        allpackages = (list<string>) union(allpackages,
                                ["inetd"]);

        }

        if (haskey(Profile::current, "nis")) {
                map conf = Profile::current["nis"]:$[];
                if (conf["start_nis"]:false)
                        allpackages = (list<string>) union(allpackages, ["yast2-nis-client","ypbind"]);

                if (conf["start_autofs"]:false)
                {
                    string pkg = "autofs4";
                    allpackages = add (allpackages, pkg);
                }
        }

        if (haskey(Profile::current, "security")) {
            allpackages = (list<string>) union(allpackages,
                    ["yast2-security"]);
        }

        if (haskey(Profile::current, "ldap")) {
                map ldapclient = Profile::current["ldap"]:$[];
                if (ldapclient["start_ldap"]:false)
                        allpackages = (list<string>) union(allpackages, ["pam_ldap","nss_ldap"]);
                if (ldapclient["start_autofs"]:false)
                {
                    string pkg = "autofs4";
                    allpackages = add (allpackages, pkg);
                }
        }

        if (haskey(Profile::current, "nfs_server"))
        {
            boolean start_nfsserver = Profile::current["nfs_server", "start_nfsserver"]:false;
            if (start_nfsserver)
                allpackages = (list<string>) union(allpackages, ["yast2-nfs-server", "nfs-kernel-server"]);
        }


        if (haskey(Profile::current, "mail")) {
                map mail = Profile::current["mail"]:$[];
                if (mail["mta"]:`other == `postfix)
                {
                        allpackages = add(allpackages, "postfix");
                        PackageAI::toremove = add(PackageAI::toremove, "sendmail");
                        if (mail["use_amavis"]:false)
                                allpackages = add(allpackages, "amavis-postfix");
                }
                else if (mail["mta"]:`other == `sendmail)
                {
                        allpackages = add(allpackages, "sendmail");
                        PackageAI::toremove = add(PackageAI::toremove, "postfix");

                        if (mail["use_amavis"]:false)
                                allpackages = add(allpackages, "amavis-sendmail");
                }
        }
        return allpackages;
    }



    /**
     * Configure software settings
     * @param void
     * @return boolean
     */
    global define boolean Write()
    {

        if (imaging)
        {
            if( ! image["run_kickoff"]:false )
                ProductControl::DisableModule ("kickoff");
            ProductControl::DisableModule ("rpmcopy");
            return true;
        }

        boolean ok = true;

        Packages::Init(true);
        list<string> failed = [];

        /* set SoftLock to avoid the installation of recommended patterns (#159466) */
        foreach( map<string,any> p, Pkg::ResolvableProperties ("", `pattern, ""), ``{
            Pkg::ResolvableSetSoftLock( p["name"]:"", `pattern );
        });

        foreach(string p, toset(patterns),
                ``{
            if (! Pkg::ResolvableInstall( p, `pattern ) )
            {
                failed = add(failed, p);
            }
        });

        if (size(failed) > 0 )
        {
            y2error("Error while setting pattern: %1",  mergestring(failed, ","));
            Report::Warning(sformat(_("Could not set patterns: %1."), mergestring(failed, ",")));
        }

//        list<string> autoinstPacks = autoinstPackages ();
        list<string> autoinstPacks = PackageAI::toinstall;
        y2milestone("Packages selected in autoinstall mode: %1", autoinstPacks);

        if (size(autoinstPacks) > 0 )
        {
            y2milestone("Installing individual packages: %1", Pkg::DoProvide(autoinstPacks) );
        }


        list<string> computed_packages = Packages::ComputeSystemPackageList();
        y2debug("Computed list of packages: %1", computed_packages);

        foreach( string pack, computed_packages, ``{
            if( size(kernel) > 0 && pack != kernel && search(pack, "kernel-") == 0 ) {
                y2milestone("taboo for kernel %1",pack);
                PackageAI::toremove = add( PackageAI::toremove, pack );
            }
        });


        //
        // Now remove all packages listed in remove-packages
        //
        y2milestone("Packages to be removed: %1", PackageAI::toremove);
        if (size(PackageAI::toremove) > 0 )
        {
            foreach (string rp, PackageAI::toremove, ``{
                //Pkg::ResolvableSetSoftLock( rp, `package ); // FIXME: maybe better Pkg::PkgTaboo(rp) ?
                Pkg::PkgTaboo(rp);
            });

            Pkg::DoRemove(PackageAI::toremove);
        }
        list<string> pack = Storage::AddPackageList();
        if( size(pack)>0 )
        {
            y2milestone("Installing storage packages: %1", Pkg::DoProvide( pack ));
        }
        //
        // Solve dependencies
        //
        if( !Pkg::PkgSolve(false) ) {
            Report::Error( _("The package resolver run failed. Please check your software section in the autoyast profile.") );
        }

        SpaceCalculation::ShowPartitionWarning();

        return (ok);
    }


    /**
     * Initialize temporary target
     */
    global define void  pmInit()
    {

//        string tmproot = AutoinstConfig::tmpDir;

//        SCR::Execute(.target.mkdir, tmproot + "/root");
//        Pkg::TargetInit( tmproot + "/root", true);
        Pkg::TargetInit( "/", true);
        y2milestone("SourceStartCache: %1", Pkg::SourceStartCache(false));
        return;
    }


    /**
     * Add post packages
     * @param list calculated post packages
     * @return void
     */
    global define void addPostPackages(list<string> calcpost)
    {
        AutoinstData::post_packages = (list<string>)toset(union(calcpost,AutoinstData::post_packages));
        return;
    }
 
    global define boolean isPatternFulfilled( string p ) {
        boolean ret = true;
	if( haskey( fulfilled_cache, p ) )
		return fulfilled_cache[p]:false;
        list<map<string,any> > all_xpatterns = Pkg::ResolvableDependencies ("", `pattern, "");

        foreach( map<string,any> dep, all_xpatterns, ``{
            if( ret == true && dep["name"]:"" == p ) {
                foreach( map<string,string> dep2, dep["dependencies"]:[], ``{
                    if( dep2["dep_kind"]:"" == "requires" ) {
                        if( dep2["res_kind"]:"" == "package" && !contains( inst, dep2["name"]:"" ) ) {
                            ret = false;
                            break;
                        } else if( dep2["res_kind"]:"" == "pattern" && !isPatternFulfilled( dep2["name"]:"" ) ) {
                            ret = false;
                            break;
                        }
                    }
                });
            }
        });
	fulfilled_cache[p] = ret;
        return ret;
    }

    global define list<string> getPatterns() {
        list<string> ret = [];
        list<map<string,any> > all_patterns = Pkg::ResolvableProperties ("", `pattern, "");

        foreach( map<string,any> m, all_patterns, ``{
            if( !contains(ret, m["name"]:"") && isPatternFulfilled( m["name"]:"" ) )
                ret = add( ret, m["name"]:"" );
        });
        return ret;
    }


    /**
     * Return list of software packages of calling client
     * @return map map of installed software package
     *		"patterns" -> list<string> addon selections
     *		"packages" -> list<string> user selected packages
     *      "remove-packages" -> list<string> packages to remove
     */
    global define map<string, any > ReadHelper()
    {
//        boolean ret = Pkg::TargetInit("/", false);
        Pkg::TargetInitialize ("/");
        Pkg::TargetLoad();
        Pkg::SourceStartManager (true);

        inst = Pkg::GetPackages(`installed, true);
        list<map<string,any> > all_patterns = Pkg::ResolvableProperties ("", `pattern, "");
        list<map<string,any> > all_xpatterns = Pkg::ResolvableDependencies ("", `pattern, "");
        list<string> patterns = [];

        // get all fulfilled patterns
        // way too many will be fulfilled
        // we will clean that up later
        patterns = getPatterns();

        Pkg::TargetFinish ();

        string tmproot = AutoinstConfig::tmpDir;
        SCR::Execute(.target.mkdir, tmproot + "/rootclone");
        Pkg::TargetInit( tmproot + "/rootclone", true);
        y2debug("SourceStartCache: %1", Pkg::SourceStartCache(false));

        Pkg::SourceStartManager(true);

        list<string> packages = Pkg::FilterPackages(false, false, true, true);
        Pkg::TargetFinish ();
        // Remove kernel packages
        list<string> userpackages =  packages;
        list<string> removepackages = [];

        list<string> patternPackages = [];
        list<string> new_p = [];
        foreach( string tmp_pattern, patterns, ``{
            list<map<string,any> > xpattern = filter( map<string,any> p, all_xpatterns, ``( p["name"]:"" == tmp_pattern ) );
            map<string,any> found = xpattern[0]:$[];
            boolean req = false;
            foreach( map<string,any> d, found["dependencies"]:[], ``{
                if( d["res_kind"]:"" == "package" && d["dep_kind"]:"" == "requires" ) {
                    patternPackages = add(patternPackages, d["name"]:"");
                    req = true;
                }
            });
            // workaround for our pattern design
            if( req == true )
                new_p = add( new_p, tmp_pattern );
        });
        patterns = new_p;


        map<string, any > software = $[];
        if( size(patterns) > 0 ) {
            foreach(string p, inst, ``{
                if (!contains(patternPackages, p))
                    userpackages = add( userpackages, p );
            });
            foreach(string p, patternPackages, ``{
                if (!contains(inst,p))
                    removepackages = add( removepackages, p );
            });
        }

        software["packages"] = sort( filter(string pkg, userpackages, ``(! regexpmatch(pkg, "kernel-.*") || pkg == "kernel-uml")) );
        software["patterns"] = sort( patterns );
        software["remove-packages"] = sort( removepackages );
        return software;
    }

    global define boolean Read(){
      return Import( ReadHelper() );
    }

    //EOF
}
