/**
 * File: 	include/autoinstall/dialogs.ycp
 * Module:	AIConfig
 * Summary:	This module handles the configuration for auto-installation
 * Authors:	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{
    textdomain "autoinst";
    



    
    /**
     * Dialog Contents     
     */

    global define class_dialog_contents ()
	``{
	
	list classes = maplist(map class , AIClass::Classes,
			       ``{
				   string pathtoClass = sformat("%1/%2", AIConfig::classDir, class["name"]:("Unknown"));
				   
				   list files_in_class = SCR::Read(.target.dir, pathtoClass);
				   return (`item(
						 `id(class["name"]:"Unknown"),
						 class["name"]:"No name",
						 class["order"]:"0",
						 size(files_in_class)
						 )
					   );
			       });
	
	
	term contents =	 
    `VBox(
	  `VWeight(40, `Table( `id(`table), `opt (`notify, `immediate),
			       `header(_("Class Name"), _("Order"), _("Configurations")),
			       classes			 
			       )
		   ),
	  `VSpacing(1),
	  `VWeight(40,`RichText(`id(`description), _("Class Description"))),
	  `VSpacing(1),
	  `HBox(			
		`PushButton(`id(`new), _("Ne&w")),
		`PushButton(`id(`edit), _("&Edit")),
		`PushButton(`id(`delete), _("&Delete"))
		)
	  );
	return contents;
    }

    
    /** 
     * Manage Classes
     *      
     */    
    global define symbol ManageClasses()
	``{
	
	string title = _("Classes");
	
	string help = _("<p>Use this interface to define classes of control files. </p>
");
	
	help = help + _("<p>For example, you can define a class of configurations for
a specific  department, group or site in your company environment.</p>
");
	
	help = help + _("<p>The order (periority) defines the hierarchy of a class
and when it is merged when creating a control file.
</p>
");

	  
	Wizard::SetContents(title,	
			    class_dialog_contents() , help, true, true);
	Wizard::ReplaceAbortButton(`Empty());
	UI::ChangeWidget(`id(`next), `Label, FinishButtonLabel());
	Wizard::ReplaceAbortButton(`Empty());
	any ret = nil;	
	repeat
	    {
	    	if (size(AIClass::Classes) == 0 )
		{
		    UI::ChangeWidget(`id(`edit), `Enabled, false);
		    UI::ChangeWidget(`id(`delete),`Enabled, false);
		}
		
		string class =  UI::QueryWidget(`id(`table), `CurrentItem);
		map selected_class = select(filter(map c,  AIClass::Classes,``(c["name"]:""  == class) ), 0, $[] );  
		if ( class != nil )
		{
		    UI::ChangeWidget(`id(`description), `Value, selected_class["description"]:_("No Description"));
		}
	    
		ret = UI::UserInput();
	    
		y2milestone("ret: %1, class: %2", ret, class);
	  	    
	
		if (ret == `new)
		{
		    any defret = AddEditClasses(ret, "");
		   
		    Wizard::SetContents(title,
					 class_dialog_contents(), help, true, true);
		}
		else if (ret ==`edit)
		{
		    if (class == nil)
		    {
			UI::MessagePopup(_("Select at least one class
to be edited.
"));
			continue;
		    }		     
		    any defret = AddEditClasses(ret, class);
		    if (defret != `cancel)
		    {
			
		    }
		    Wizard::SetContents(title,
					class_dialog_contents(), help, true, true);
		}
		else if (ret ==`delete)
		{
		    if (class == nil) {
			UI::MessagePopup(_("At least select one class
to be delete .
"));
			continue;
		    }
		    AIClass::Classes = filter(map c,  AIClass::Classes,``( lookup(c,"name","")!=class) );
	
		    Wizard::SetContents(title,
					class_dialog_contents(), help, true, true);	
	
		}
		
	
	    
	    } until (ret == `back || ret == `next );

	if (ret == `next)
	{	 
	    AIClass::Save();
	}
	return ret;
 
    }


    
    /**
     * Add or Edit a class
     * @param symbol mode
     * @param string name
     */

    global define AddEditClasses(symbol mode, string name)
	``{	
	list classNames = maplist(map c,
				  AIClass::Classes,
				  ``(lookup(c,"name",""))
				  );
	
	map class = $[];
	if (mode == `edit)
	{	    
	    class = select(filter(
				  map c,
				  AIClass::Classes,
				  ``(lookup(c,"name","")== name)),0,$[]);
	}
	
	integer order =  tointeger(lookup(class,"order", sformat("%1", size(AIClass::Classes) + 1)));
	
	UI::OpenDialog( `opt(`decorated),			
			`HBox(
			      `HSpacing(0.5),
			      `VBox(
				    `Heading( _("Edit or Create Classes")),
				    `VSpacing(1),
				    `HBox(				    
					  `TextEntry(`id(`name), _("Na&me"), lookup(class,"name","")),
					  `IntField(`id(`order), _("Or&der:"), 1, 10, order)
					  ),
				    `MultiLineEdit(`id(`description), `opt(`hstretch),
						   _("Descri&ption:"),	
						   lookup(class,"description","")),
				    `VSpacing(1),
				    `HBox(
					  `PushButton(`id(`save), SaveButtonLabel()),			      
					  `PushButton(`id(`cancel), CancelButtonLabel())
					  )
				    ),
			      `HSpacing(0.5)
			      )
			);
	if (mode == `edit)
	{
	    UI::ChangeWidget(`id(`name), `Enabled, false);
	}
	
	repeat {
	    ret = UI::UserInput();
	    if (ret == `save )
	    {
		if (UI::QueryWidget(`id(`name),`Value) == "")
		{
		    UI::MessagePopup(_("That name is already used. Select another name."));
		    continue;
		}
		if (mode !=`edit && contains(classNames, UI::QueryWidget(`id(`name),`Value)))
		{		    
		    UI::MessagePopup(_("That name is already used. Select another name."));
		    continue;
		}
		string name = UI::QueryWidget(`id(`name),`Value);
		if (checkFileName(name) != 0 || name == "")
		{
		    UI::ErrorPopup(invalidFileName());
		    continue;
		}
		map newClass = $[
				 "name": name,
				 "order":UI::QueryWidget(`id(`order),`Value),
				 "description":UI::QueryWidget(`id(`description),`Value)
		];
		if (mode == `new)
		{
		    AIClass::Classes=add(AIClass::Classes, newClass);
		    SCR::Execute(.target.mkdir, AIConfig::classDir + "/" + name);
		}
		else
		{
		    AIClass::Classes=    maplist(
						 map c, AIClass::Classes,``{
						     if (lookup(c,"name","") == UI::QueryWidget(`id(`name),`Value)) {
							 return newClass;
						     }
						     else
						     {
							 return c;
						     }				    
						 });
		}   
		
	    } 
	} until (ret == `save || ret == `cancel);

	UI::CloseDialog();
	
	return ret;
    }




    /**
     * Merge Dialog
     *
     */

    global define MergeDialog()
	``{	
	string title = _("Merge Classes");
	map profiles = $[];

	term Combo = `VBox();
	AIClass::Files();
	foreach(map prof, AIClass::confs, ``{
	    
	    string class = prof["class"]:"Default";
	    list ui_list = profiles[class]:[];
	    
	    if (size(ui_list)==0)
	    {
		ui_list=add(ui_list,`item(`id("none"),
					  _("None"))
			    );
	    }
	    
	    ui_list=add(ui_list,`item(`id(prof["name"]:"Unknown"),
				      prof["name"]:"Unknown")
			);
	    
	    profiles[class] =  ui_list;
	});
		

	if ( size(profiles) > 0 )
	{
	    foreach(`k,`v, profiles,``{
		Combo = add(Combo,	 
			  `HBox(
				`HWeight(50,(`Left(
						   `ComboBox(`id(k),`opt(`hstretch,`autoShortcut),
							     k,
							     v
							     )
						   )
					     )
					 ),
				`HWeight(50, `Empty()
					 )
				)
			  );
	    });
	}
	else
	{
	    Combo = `Left(`Label(`id(`emptyclasses), _("No control files defined")));	    
	}
	

	term contents =
    `Top(
	 `Left(
	       `VBox(
		     Combo,
		     `VSpacing(),
		     `RadioButtonGroup(`id(`rbg),
				       `VBox(
					     `Left(
						   `RadioButton(`id(`empty),
								_("&Merge with empty control file"), true)
						   ),
					     `Left(
						   `RadioButton(`id(`current),
								_("Merge with &current loaded control file"))
						   )
					     )
				       ),
		     `PushButton(`id(`merge), _("Merge Cla&sses"))
		     )
	       )
	 );
		  

	string help = _("<p>If you have defined and created <b>
classes</b>, you will be able to merge them using this interface to create
a new <i>Profile</i> that will contain information from every class
depending on the priority (order) set when
creating the classes</P>
");

	help = help + _("<P>To merge the classes, a <b>XSLT</b>
script is used.</P>
");
	
	Wizard::SetContents(title,	
			    contents, help , true, true);

	Wizard::ReplaceAbortButton(`Empty());
	list widgets = [ `merge, `empty, `current ];
		
	UI::ChangeWidget(`id(`next), `Label, FinishButtonLabel());
	UI::ChangeWidget(`id(`next), `Enabled, false);
	
	any ret = nil;
	repeat {
	    ret = UI::UserInput();
	    symbol base = UI::QueryWidget(`id(`rbg), `CurrentButton);	    
	    integer n = 0;
	    if (ret == `merge)
	    {				
		list selected_profiles = [];
		foreach (map prof, AIClass::confs,``{
		    
		    any selected = UI::QueryWidget(`id(prof["class"]:""), `Value);
		    
		    if (selected != nil) {
			if (selected != "none") {
			    n = n +1;
			}
			selected_profiles = add(selected_profiles,
						$[
						  "order": GetClassOrder(prof["class"]:""),
						  "class":prof["class"]:"none",
						  "profile":selected
						]
						);
		    }
		    
		});
		
		if (n ==  0) {
		    integer min = 1;
		    if (base == `empty)
			min = 2;
		    
		    UI::ErrorPopup(sformat(_("You have to select at least %1  configurations
to be able to  perform a merge.
"), min));
		    continue;
		}
		
		list sorted_profiles =  sort(`x,`y, filter(`c, toset(selected_profiles),``(c["profile"]:""!= "none")),
					     ``(x["order"]:0<=y["order"]:0)					
					     );
		y2debug("Selected Profiles: %1", sorted_profiles);
		if ( size(sorted_profiles)>0 )
		{
		    y2milestone("Calling merge with %1 (%2)", sorted_profiles, base);
		    MergeAll(sorted_profiles, base);
		}
		UI::ChangeWidget(`id(`next), `Enabled, true);
	    }	 
	} until  (ret == `next || ret == `back );

	return ret;
    }


    

    /**
     * The merge operation
     */    
    global define boolean MergeAll(list selected_profiles, symbol base)
	``{
	
	string tmpdir = SCR::Read( .target.tmpdir );
	SCR::Execute(.target.mkdir, tmpdir);

	if (base == `empty)
	{
	    XML::YCPToXMLFile(`profile, $[], tmpdir + "/base_profile.xml");	    
	}
	else if (base == `current)
	{
	    Profile::Save( tmpdir + "/base_profile.xml");
	}
	else
	{
	    return false;
	}
	
	boolean error = false;
	boolean skip = false;
	foreach( map c, selected_profiles,
		``{	  
	    map profile = select(filter(`cc, AIClass::confs,
					``( cc["name"]:"" == c["profile"]:"" )
					),
				 0,
				 $[]
				 );
	    if (base == `empty && !skip)
	    {		
		SCR::Execute(.target.bash, "cp " + AIConfig::classDir + "/" + profile["class"]:""  + "/" +  profile["name"]:"" +  "  " + tmpdir + "/base_profile.xml");
		skip = true;
	    }
	    else
	    {
		y2milestone("Working on profile: %1", profile);
		string base_text = "empty control file";
		if (base != `empty)
		{
		    base_text = "current control file";
		}
	
		if (profile["name"]:"" != "" && !error)
		{
		    showFeedback(sformat("Merging %1 with %2....", profile["name"]:"", base_text));
		    map xsltret = AIClass::MergeClasses(profile,  tmpdir + "/base_profile.xml", "result.xml");
		    if (xsltret["exit"]:-1 != 0 )
		    {
			UI::ErrorPopup(sformat(_("Merge failed:\n %1"), xsltret["stderr"]:"error"));
			error =  true;
		    }
		    XML_cleanup(tmpdir + "/result.xml",  tmpdir + "/base_profile.xml");		    
		}
		else
		{
		    error = true;
		}
	    }
	});

	
	if (error)
	{
	    clearFeedback();
	    return false;
	}

	// Backup file
	SCR::Execute(.target.bash, "cp " + tmpdir + "/result.xml /var/lib/autoinstall/tmp/autoinst_result.xml" );

	Profile::Read("/var/lib/autoinstall/tmp/autoinst_result.xml" );	
	SCR::Execute(.target.remove, " /var/lib/autoinstall/tmp/autoinst_result.xml");	
	clearFeedback();
	
	return true;
    }
    

    global define XML_cleanup(string in, string out)
	``{
	
	map ycpin = XML::XMLToYCPFile(in);	
	y2debug("Writing clean XML file to  %1, YCP is (%2)", out, ycpin);
	return XML::YCPToXMLFile(`profile, ycpin, out);
    }


    
    global define integer GetClassOrder(string name)``{
	integer order = 0;
	foreach(map class, AIClass::Classes, ``{
	    if (class["name"]:"" == name)
		order = class["order"]:0;
	});
	return order;
    }


    



}
