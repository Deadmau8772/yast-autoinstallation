/**
 * File:	include/autoinstall/imports.ycp
 * Package:	Autoinstallation Configuration System
 * Summary:	Imports older and foreign format
 * Authors:	Anas Nashif<nashif@suse.de>
 *
 * $Id$
 */
{
    textdomain "autoinst";
 

    /**
     * Generate control file list
     * @return file list
     */
    global define aliceHostList()
	``{

	list files = SCR::Read(.target.dir, AutoinstConfig::AliceRepository + "/info");
	list extensions = ["sys.tcf" ];
	list hosts = [];
	string host = "";
	foreach(string file, files, ``{
	    foreach(`ext, extensions, ``{
		if (issubstring(file, ext))
		{
		    integer extsize = size(splitstring(ext, "."));
		    list comp = splitstring(file, ".");
		    integer i = 0;
		    while (i < extsize) {
			comp  = remove(comp, size(comp) - 1 );
			i = i + 1;
		    }

		    hosts=add(hosts,mergestring(comp,"."));
		}
	    });

	});
	list hostfiles = maplist(string host, toset(hosts), ``{
	    return (`item(`id(host), host));
	});

	term contents =
	    `VBox(
		  `VSpacing(0.5),
		  `Table(`id(`table), `opt(`notify,`immediate), `header("Host"),
			 hostfiles
			 ),		 
		  `VSpacing(0.5)
		  );
	return contents;
    }




    global define aliceImportList()
	``{

	Wizard::SetScreenShotName ("autoyast-alice-2");

	string help = _("<p>Using this dialog, select a
host from the <b>ALICE</b> repository.</p>
");
	help = help +  _("<p>Using this feature, import <b>Alice</b> configuration
files.</p>
");
	help = help + _("<p>System configuration in  <em>Alice</em> files may vary in their scope from what is offered
in <b>AutoYaST</b>, so some limitations should be taken into consideration. A standard <em>Alice</em>
configuration file with no special customization can, however, be imported without any loss of data.</p>
");
	
	help = help + _("<p>Converting <b>ALICE</b> data to use with the new autoinstallation
system might take some time.  Be patient while
the configuration files are read and converted.
</p>
");
	Wizard::SetContents(_("Hosts in Alice Repository"),
			    aliceHostList(), help, true, true);

	Wizard::ReplaceAbortButton(`Empty());
	UI::ChangeWidget(`id(`next), `Label, _("&Import"));


	any ret = "";
	string host = "";
	repeat
	    {
	    ret = UI::UserInput();
	    if (ret == `next)
	    {
		host = UI::QueryWidget(`id(`table), `CurrentItem);
		if (host != nil && host != "")
		{
		    showFeedback(_("
Reading Alice configuration files.
This may take a while. Please wait...
"));

		    map aliceConf = $[];
		    any aliceret = createAliceConf(host);
		    if (is(aliceret, map) && aliceret != $[])
		    {
			aliceConf = aliceret;
		    }
		    else
		    {
			UI::ErrorPopup(_("Error while importing ALICE data"));
			clearFeedback();
			continue;
		    }

		    Profile::Import(createProfile(aliceConf));
		    clearFeedback();
		   
		}
	    }
	} until (ret == `next || ret == `back );


	Wizard::RestoreScreenShotName ();
	return ret;
    }

    global define any createAliceConf(string host)
	``{

	string MakeinfoCommand = "alice make_info_file --yast2 ";
	MakeinfoCommand = MakeinfoCommand + host;
	map out = SCR::Execute(.target.bash_output, MakeinfoCommand, $["YAST2_TMPDIR": AutoinstConfig::tmpDir , "ALICE_HOME":AutoinstConfig::AliceRepository]);
	string filelist = SCR::Read(.target.string, AutoinstConfig::tmpDir + "/filelist");
	list files = splitstring(filelist, "\n");
	y2milestone("files: %1", files);

	any ret =  mergeFiles(files, AutoinstConfig::tmpDir);
	SCR::Execute(.target.remove,  AutoinstConfig::tmpDir + "/filelist");
	y2milestone("alice conf %1", ret);
	return ret;
    }

    global define map mergeFiles(list files, string dir)
	``{
	include "autoinstall/xml.ycp";
	aliceXmlSetup();
	integer cnt = 0;
	string base = "";
	foreach (`f, files, ``{
	    if (f!="") {

		string filename = sformat("%1/%2", dir, f);
		y2milestone("Working on %1", filename);
		base = sformat("%1/base.xml", dir);
		if (cnt == 0)
		{
		    _cleanup(filename, base);
		}
		else
		{

		    string MergeCommand = "/usr/bin/xsltproc --novalid --param replace \"'true'\" --param with ";
		    MergeCommand = MergeCommand + "\"'" + filename + "'\"  ";
		    MergeCommand = MergeCommand + "--output " +  dir + "/mergeOutput ";
		    MergeCommand = MergeCommand + " /usr/share/autoinstall/xslt/merge.xslt ";
		    MergeCommand = MergeCommand +   base + " ";

		    y2milestone("Merge command: %1", MergeCommand);

		    map out = SCR::Execute(.target.bash_output, MergeCommand, $[]);
		    y2milestone("Merge stdout: %1, stderr: %2", out["stdout"]:"", out["stderr"]:"");
		    _cleanup(sformat("%1/mergeOutput", dir), base);
		}

		cnt = cnt + 1;
	    }

	});
	any ret = XML::XMLToYCPFile(base);

	return (ret);
    }


    global define _cleanup(string in, string out)
	``{
	map ycpin = XML::XMLToYCPFile(in);
	y2milestone("Writing file as %1", out);

	map sortedMap = $[];
	list keys = toset(maplist(`k,`v, ycpin, ``(k)));
	foreach(`k, keys, ``{
	    sortedMap[k]=ycpin[k]:"";
	});
	return XML::YCPToXMLFile(`alice, sortedMap, out);
    }

    /**
     * Create the profile from Alice data
     * @param map alice data
     * @return map Profile
     */

    global define map createProfile(map aliceConf)
	``{
	import "Misc";
	// General resource
	////////////////////////////////////////////////////////
	map keymap2yast1 = $[
			     "us"		:"english-us",
			     "de-lat1-nd"	:"german",
			     "fr-latin1"	:"french",
			     "it"		:"italian",
			     "es"		:"spanish",
			     "nl"		:"dutch",
			     "pt2"		:"portugese",
			     "br-abnt2"		:"portugese-br",
			     "hu"		:"hungarian",
			     "Pl02"		:"polish" ,
			     "gr"		:"greek"  ,
			     "trq"		:"turkish",
			     "ru1"		:"russian",
			     "cz-lat2"		:"czech"
	];
	map lang2iso = SCR::Read( .target.yast2, "lang2iso.ycp");

	map general = $[];
	map install = $[];
	map configure = $[];

	// SYS_LANGUAGE, SYS_KEYTABLE, SYS_TIMEZONE, SYS_MOUSE_DEVICE, SYS_HWC_GMT
	string language = aliceConf["SYS_LANGUAGE"]:"english";
	general["language"] = lang2iso[language]:"en_US";
	string keymap = aliceConf["SYS_KEYTABLE"]:"us";
	general["keyboard"] = keymap2yast1[keymap]:"english-us";
	general["timezone"] =  aliceConf["SYS_TIMEZONE"]:"CET";
	if ( aliceConf["SYS_HWC_GMT"]:"no" == "yes")
	    general["hwclock"] = "GMT";
	else
	    general["hwclock"] = "localtime";

	map mice = Misc::ReadAlternateFile ("mouse_db.ycp", "mouse_raw.ycp");
        y2debug("Mice %1", mice);
	boolean found = false;
	foreach(`k,`v, mice, ``{
	    map data = select(v,1,$[]);
	    y2debug("yours %1, mine %2",  data["device"]:"", aliceConf["SYS_MOUSE_DEVICE"]:"none");
	    if ( data["wheels"]:0 == 0 && data["device"]:"" == aliceConf["SYS_MOUSE_DEVICE"]:"none")
	    {
		general["mouse"] = k;
		found = true;
	    }
	});
	if (!found)
	    general["mouse"] = "probe";



	list drives = [];
	map newDrive = $[];
	foreach(`k,`v, aliceConf , ``{
	    if (issubstring(k, "SYS_PART")) {
		string device =  "/dev/" + select(splitstring(k,"_"), 2, "");
		list partitions  = createAlicePartitions(v);
		y2milestone("Partitions for %1: %2", device , partitions );
		drives = add(drives, $["device":device, "partitions": partitions]);
	    }
	});



	install["partitioning"] = drives;
	install["general"] = general;
	install["software"] = createAliceSoftware(aliceConf);
	configure["networking"] = createAliceNetwork(aliceConf);

	install["init"] = aliceInit(aliceConf, 	configure["networking"]:$[]);
	configure["users"] =  createAliceUsers(aliceConf);
	if (aliceConf["NETWORK_NIS_YPDOMAIN"]:"" != "")
	    configure["nis"] =  createAliceNis(aliceConf);

	map profile = $[];
	profile["install"] = install;
	profile["configure"] = configure;
	y2milestone("Profile : %1", profile);
	return profile;
    }

    /**
     * create partition list from alice data
     * @param string partition
     * @return list  list of partitions
     */
    global define list createAlicePartitions(string partitions)
	``{
	SCR::Write(.target.string, "/var/lib/autoinstall/tmp/alice_part", partitions);
	list raw_part =  SCR::Read(.tmp.alice.part);
	
	
	
	list part =filter(`pe, raw_part, ``(!haskey(pe, "path")));
	y2milestone("and parts again: %1", part);
	list newPartitions = maplist(`p, part, ``{
	    map newPart = $[];

	    if (p["mount"]:""!="NONE" && p["mount"]:""!="SWAP")
	    {
		newPart["mount"] = p["mount"]:"";
	    }
	    else if (p["mount"]:"" == "SWAP")
	    {
		newPart["partition_id"]= tointeger(sformat("0x%1","82"));
	    }

	    if (p["size"]:-1 == 0)
	    {
		newPart["size"]= "max";
	    }
	    else
	    {
		newPart["size"]= sformat("%1mb", p["size"]:0);
	    }

	    if (haskey(p,"id")) {
		string hex = sformat("0x%1", p["id"]:"83");
		newPart["partition_id"]= tointeger(hex);
	    }
	    if (haskey(p,"num")) {
		newPart["partition_nr"]= tointeger(p["num"]:"0");
	    }

	    return newPart;
	});
	SCR::Execute(.target.remove,  "/var/lib/autoinstall/tmp/alice_part");
	SCR::UnmountAgent(.tmp.alice.part);
	y2milestone("Alice Partitions %1", newPartitions);
	return  newPartitions;
    }

    /**
     * create software map from alice data
     * @param map aliceConf alice configuration
     * @return map  software map
     */

    global define map createAliceSoftware(map aliceConf) ``{

	map software= $[];
	string base = "";
	if (size(aliceConf["SYS_SW_SELLIST"]:"")>0)
	{
	    string SYS_SW_SELLIST = aliceConf["SYS_SW_SELLIST"]:"";
	    software["packages"] = readSelection(SYS_SW_SELLIST);
	}
	else if (aliceConf["SYS_SW_SELECTION"]:"" != "")
	{
	    list tmpsel = splitstring(aliceConf["SYS_SW_SELECTION"]:"", "/");
	    base = select(tmpsel, size(tmpsel) - 1 , "");
	    software["base"] = select(splitstring(base, "."), 0, "Minimal");
	}

	if (aliceConf["SYS_INST_KERNEL"]:"" != "")
	{
	    software["kernel"] = aliceConf["SYS_INST_KERNEL"]:"";
	}
	if (aliceConf["SYS_SW_ADDLIST"]:"" != "")
	{
	    string SYS_SW_ADDLIST = aliceConf["SYS_SW_ADDLIST"]:"";
	    software["packages"] = readSelection(SYS_SW_ADDLIST);
	}
	if (aliceConf["SYS_SW_AUXLIST"]:"" != "")
	{
	    string SYS_SW_AUXLIST = aliceConf["SYS_SW_AUXLIST"]:"";
	    map extra = $[];
	    extra["packages"] = readSelection(SYS_SW_AUXLIST);
	    extra["package_location"] = "custom";
	    software["extra_packages"] = extra;
	}
	return software;

    }
    /**
     * Read package selection from a file
     * @param string selection as string
     * @return list package selection list
     */
    global define list readSelection(string selection) ``{
	SCR::Write(.target.string, "/var/lib/autoinstall/tmp/alice_software", "Toinstall:\n" + selection + "\nLlatsniot:\n");
	list sel = filter(`p, SCR::Read(.yast1sel.selection, "/var/lib/autoinstall/tmp/alice_software"), ``(p!=""));
	SCR::Execute(.target.remove, "/var/lib/autoinstall/tmp/alice_software");
	SCR::UnmountAgent(.tmp.alice.software);
	return sel;
    }



    /**
     * create network map from alice data
     * @param map aliceConf alice configuration
     * @return map  network map
     */
    global define map createAliceNetwork(map aliceConf) ``{
	 include "network/ip.ycp";
	 string network =  aliceConf["NET_IP_CONFIG"]:"";
	 string DNS_NAMESERVER = aliceConf["DNS_NAMESERVER"]:"";
	 string DNS_SEARCHLIST = aliceConf["DNS_SEARCHLIST"]:"";
	 string SYS_NAME = aliceConf["SYS_NAME"]:"";
	 string DEF_GATEWAY = aliceConf["DEF_GATEWAY"]:"";
	 string ROUTES = aliceConf["ROUTES"]:"";


	 map networking = $[];
	 map dns = $[];
	 map routing = $[];



	 SCR::Write(.target.string, "/var/lib/autoinstall/tmp/alice_network", network);
	 map raw_interfaces =SCR::Read(.tmp.alice.network);
	 list interfaces = maplist(`iface, `data, raw_interfaces, ``{
	     map interface = $[];
	     if (data["bootproto"]:"" == "dhcpclient")
	     {
		 interface["bootproto"] = "dhcp";
		 interface["device"] = iface;
		 interface["startmode"] = "onboot";
	     }
	     else
	     {
		 interface["device"] = iface;
		 interface["bootproto"] = "static";
		 interface["network"] =  compute_network(ip2string(data["ipaddr"]:""),ip2string(data["netmask"]:""));
		 interface["ipaddr"] = ip2string(data["ipaddr"]:"");
		 interface["netmask"] = ip2string(data["netmask"]:"");
		 interface["startmode"] = "onboot";
		 interface["broadcast"] = compute_broadcast(ip2string(data["ipaddr"]:""),ip2string(data["netmask"]:""));
	     }
	     return (interface);
	 });

	 list nameserver = filter(`n, splitstring(DNS_NAMESERVER, " "), ``(n!= "" && n!= " "));
	 list searchlist = filter(`s, splitstring(DNS_SEARCHLIST, " "), ``(s!= "" && s!= " "));

	 string hostname = select(splitstring( SYS_NAME, "."), 0 , "");
	 string domain = mergestring(remove(splitstring( SYS_NAME, "."), 0), ".");

	 dns["hostname"] = hostname;
	 dns["domain"] = domain;
	 dns["searchlist"] = searchlist;
	 dns["nameservers"] = nameserver;

	 list routes= [];
	 map route = $[];

	 if (DEF_GATEWAY!="") {
	     route["destination"] = "default";
	     route["device"] = "-";
	     route["gateway"] = DEF_GATEWAY;
	     route["netmask"] = "-";
	     routes=add(routes, route);
	 }
	 if (ROUTES!="") {
	     SCR::Write(.target.string, "/var/lib/autoinstall/tmp/alice_routes", ROUTES);
	     list raw_routes =SCR::Read(.tmp.alice.routes);
	     routes = union(routes, raw_routes);
	 }
	 routing=add(routing, "routes", routes);
	 routing=add(routing,"ip_forwarding", false);

	 networking["interfaces"] = interfaces;
	 networking["dns"] = dns;
	 networking["routing"] = routing;

	 return networking;
     }



    /**
     * create NIS map from alice data
     * @param map aliceConf alice configuration
     * @return map  NIS map
     */
    global define map createAliceNis (map aliceConf) ``{
	map nis = $[];
	string nis_domain = aliceConf["NETWORK_NIS_YPDOMAIN"]:"";
	list nis_servers = splitstring( aliceConf["NETWORK_NIS_YPSERVER"]:"", " ");
	nis["nis_domain"] = nis_domain;
	nis["nis_servers"] = nis_servers;
	nis["start_nis"] = true;

	return nis;
    }

    /**
     * create users list from alice data
     * @param map aliceConf alice configuration
     * @return list  List of users
     */
    global define list  createAliceUsers (map aliceConf) ``{
	list users = [];
	// root
	map root = $[];
	root["encrypted"] = true;
	root["username"] = "root";
	root["user_password"] =  aliceConf["SYS_ROOT_START_PWD"]:"";
	users=add(users,root);

	return users;
    }

    global define aliceInit(map aliceConf, map networking)``{
	map init = $[];
	y2milestone("networking %1", networking);
	if ( aliceConf["SYS_BOOT_MODE"]:"" == "NET") {
	    init["instmode"] = "nfs";
	}
	if (size(aliceConf["SYS_INST_DIR"]:"") > 0) {
	    string serverdir = regexpsub( aliceConf["SYS_INST_DIR"]:"", "(.*)\%version(.*)", "\\1" + aliceConf["SYS_OS_VERSION"]:"" + "\\2");
	    y2milestone("serverdir: %1", serverdir);
	    init["serverdir"] = regexpsub( serverdir, "(.*)\%arch(.*)", "\\1" + aliceConf["SYS_ARCH"]:"" + "\\2");

	}
	if (haskey(aliceConf,"SYS_INSMOD_MODULES")) {
	    list modules = splitstring(aliceConf["SYS_INSMOD_MODULES"]:"", "\n");
	    init["insmod"]=modules;
	}
	if (haskey(aliceConf,"SYS_KEYTABLE")) {
	    init["keytable"]=aliceConf["SYS_KEYTABLE"]:"";
	}
	if (haskey(aliceConf,"SYS_LANGUAGE")) {
	    init["language"]=aliceConf["SYS_LANGUAGE"]:"";
	}
	if (haskey(aliceConf,"SYS_INST_SERVER")) {
	    init["server"]=aliceConf["SYS_INST_SERVER"]:"";
	}

	if (haskey(aliceConf,"NET_INST_DEV")) {
	    init["netdevice"]=aliceConf["NET_INST_DEV"]:"";
	}

	list ifaces = networking["interfaces"]:[];
	foreach(`iface, ifaces, ``{
	    if (iface["device"]:"" == init["netdevice"]:"")
	    {
		init["ip"] = iface["ipaddr"]:"";
		init["netmask"] = iface["netmask"]:"";
	    }
	});
	init["gateway"] = aliceConf["DEF_GATEWAY"]:"";
	return init;

    }

    /***************************************************************************************
     *
     * KICKSTART
     * 
     ***************************************************************************************/


    
    /**
     * Read a Kickstart file
     */
    global define boolean readKS(string ks)``{

	map ksConfig = SCR::Read(.kickstart, ks);
	SCR::UnmountAgent(.kickstart);
	if (ksConfig == $[])
	{
	    return $[];
	}
	y2debug("Kickstart config raw: %1", ksConfig);

	return ksConfig;

    }
    /**       
     * Kickstart to AutoYaST main
     */
    global define map ks2ay(map ksConfig) ``{

	map profile = $[];
	map general = $[];
	map install = $[];
	map configure = $[];

	// Scripts
	configure["scripts"] 	= ks_scripts(ksConfig);
	configure["networking"] = select(ks_network(ksConfig), 0 , $[]);
	configure["nis"] 	= select(ks_auth(ksConfig), 0 , $[]);
	configure["ldap"] 	= select(ks_auth(ksConfig), 1 , $[]);
	configure["security"] 	= select(ks_auth(ksConfig), 2 , $[]);
	configure["users"]	= ks_users (ksConfig);

	install["init"] 	= select(ks_network(ksConfig), 1 , $[]);
	install["software"] 	=  ks_software(ksConfig);
	install["partitioning"] = ks_part(ksConfig);
	install["raid"] 	= ks_raid(ksConfig);
	install["bootloader"] 	= ks_bootloader(ksConfig);
	install["general"] 	= ks_general(ksConfig);

	profile["install"] 	= install;
	profile["configure"] 	= configure;
	Profile::changed 	= true;

	y2debug("Profile : %1", profile);
	return profile;

    }

    
    /**       
     * KS Users
     */
    global define map ks_users (map ksConfig)
	``{

	map ks_user =  ksConfig["users"]:$[];
	list users = [];
	map root = $[];
	root["username"] = "root";
	root["user_password"] = ks_user["password"]:"";
	root["encrypted"] = (ks_user["iscrypted"]:0 == 1);

	users = add(users, root);
	return users;


    }
    /**       
     * KS X11
     */
    global define map kx_x11(map ksConfig)
	``{
	if (ksConfig["skipx"]:0 != 1 && haskey(ksConfig,"xconfig"))
	{
	    map x11 = $[];
	    map ks_x = ksConfig["xconfig"]:$[];

	    if (haskey(ks_x, "depth"))
		x11["color_depth"] = ks_x["depth"]:0;

	    if (haskey(ks_x, "resolution"))
		x11["resolution"] = ks_x["resolution"]:"";

	    if (haskey(ks_x, "startxonboot"))
		x11["startxonboot"] = ks_x["startxonboot"]:"";

	    if (haskey(ks_x, "defaultdesktop"))
		x11["default_desktop"] = ks_x["defaultdesktop"]:"";

	    map monitor = $[];
	    if (haskey(ks_x, "vsync") || ks_x["monitor"]:"")
	    {

		map display = $[];
		list hsync = splitstring(ks_x["hsync"]:"", "-");
		list vsync = splitstring(ks_x["vsync"]:"", "-");
		display["min_hsync"] = select(hsync,0,"");
		display["min_vsync"] = select(vsync,0,"");
		display["max_hsync"] = select(hsync,1,"");
		display["max_vsync"] = select(vsync,1,"");
		monitor["monitor_vendor"] = select(splitstring(ks_x["monitor"]:"", " "), 0 , "");
		monitor["monitor_device"] = select(splitstring(ks_x["monitor"]:"", " "), 1 , "");
		monitor["display"] = display;

	    }
	    if (size(monitor) > 0 )
	    {
		x11["monitor"] = monitor;
	    }
	    x11["configure_x11"] = true;
	    return x11;
	}
	else
	{
	    return $[];
	}
    }
    /**       
     * KS General
     */
    global define map ks_general(map ksConfig)
	``{
	map general = $[];

	// Language
	general["language"] = ksConfig["language"]:"";

	// Keyboard
	map keyboard = $[];
	if (haskey( ksConfig , "keyboard"))
	{
	    import "Keyboard";
	    map keyboards =  Keyboard::keymap2yast();
	    keyboard["keymap"] = keyboards[ksConfig["keyboard"]:""]:"";
	}

	general["keyboard"] = keyboard;

	// Mouse
	map mouse = $[];

	if(haskey(ksConfig, "mouse"))
	{
	    map ks_mouse 	= ksConfig["mouse"]:$[];
	    mouse["device"] 	= ks_mouse["device"]:"";
	    mouse["xemu3"]	= ( ks_mouse["emulthree"]:0 == 1);
	    if (ks_mouse["type"]:"" == "none")
	    {
		mouse["id"]	= "non";
	    }
	}
	general["mouse"] = mouse;

	// Clock
	map  clock = $[];
	if (haskey(ksConfig, "timezone"))
	{
	    map ks_clock = ksConfig["timezone"]:$[];
	    clock["timezone"] 	= ks_clock["timezone"]:"";
	    clock["hwclock"]	= ( ks_clock["utc"]:0 == 1 ) ? "GMT" : "localtime";
	}
	general["clock"] = clock;


	// Mode
	map mode = $[];
	if (haskey(ksConfig, "mode"))
	{
	    mode["installation"] 	= ( ksConfig["mode"]:"" == "install" );
	    mode["upgrade"] 		= ( ksConfig["mode"]:"" == "upgrade" );

	}
	mode["reboot"] 		= ( ksConfig["reboot"]:0 == 1 );
	mode["interactive"] 	=  ( ksConfig["interactive"]:0 == 1 );
	general["mode"] = mode;


	return general;

    }

    /**       
     * KS Scripts
     */
    global define map ks_scripts(map ksConfig)
	``{
	map scripts = $[];
	list postscripts = [];
	list prescripts = [];

	if (haskey(ksConfig, "post-script"))
	{
	    map script = $[];
	    script["source"] = SCR::Read(.target.string, ksConfig["post-script"]:"");
	    map post = ksConfig["post"]:$[];
	    script["interpreter"] = post["interpreter"]:"shell";
	    script["filename"] = "kspost";
	    postscripts = add(postscripts, script);
	}
	scripts["post-scripts"] =   postscripts;
	if (haskey(ksConfig, "pre-script"))
	{
	    map script = $[];
	    script["source"] = SCR::Read(.target.string, ksConfig["pre-script"]:"");

	    script["interpreter"] = "/bin/sh";
	    script["filename"] = "kspre";
	    prescripts = add(prescripts, script);
	}
	scripts["pre-scripts"] =   prescripts;
	return scripts;
    }



    /**
     * StringFS2Symbol()
     * @param any filesystem string
     * @return symbol filesystem type
     */
    global define StringFS2Symbol(any fs)``{
	if (is(fs,symbol)) {
	    return fs;
	}
	map filesystems =
	    $[
	      "ext2":	`ext2,
	      "ext3":	`ext3,
	      "reiser":	`reiser,
	      "lvm":	`lvm,
	      "raid":	`raid,
	      "jfs":	`jfs,
	      "fat32":	`fat32,
	      "xfs":	`xfs,
	      "fat16":	`fat16,
	      "swap":	`swap
	    ];
	return filesystems[fs]:`ext2;
    }

    
    /**       
     * KS Partitioning
     */
    global define list ks_part (map ksConfig) ``{
	y2milestone("KS Partitioning: %1", ksConfig["partitioning"]:$[]);
	
	import "Partitions";
	list drives = [];
	list part1 = maplist(`k, `v, ksConfig["partitioning"]:$[],   ``{
	    map drive = $[];
	    if (haskey(v, "ondisk"))
	    {
		drive["device"] = sformat("/dev/%1", v["ondisk"]:"");
	    }
	    drive["partitions"] = [];

	    drives=add(drives, drive);
	});
	drives = toset(drives);
	y2milestone("Drives: %1", drives);
	
	foreach(`k, `v, ksConfig["partitioning"]:$[],   ``{
	    
	    map partition = $[];
	    list mountlist = splitstring(k, "_");
	    string mount = mountlist[0]:"/data";
	    integer order = tointeger(mountlist[1]:"0");
	    
	    string fstype = (mount == "swap") ? "swap" :  v["fstype"]:"";

	    integer partition_id = Partitions::fsid_native;
	    integer raiddevice = 0;

	    if (regexpmatch(mount, "^raid\..*"))
	    {
		y2milestone("device: %1", mount);
		partition_id =  Partitions::fsid_raid;
		partition["partition_id"] = partition_id;
		raiddevice = tointeger(substring(mount, 5, 1)) ;

		partition["raid_name"] = sformat("/dev/md%1", raiddevice);
		partition["format"] = false;

	    }
	    else
	    {
		partition["mount"] = mount;
		partition["order"] = order;
		partition["format"] = (v["noformat"]:-1 == -1 );
		partition["filesystem"] = StringFS2Symbol(fstype);
	    }

	    partition["size"] = sformat("%1mb", v["size"]:-1);

	    // Remove those later
	    partition["maxsize"] = sformat("%1mb", v["maxsize"]:0);	   
	    partition["grow"] =  ( v["grow"]:-1 == 1);
	    
	    foreach(`d, drives, ``{
		string dev = sformat("/dev/%1", v["ondisk"]:"");
		if ( dev  == d["device"]:"")
		{
		    list part 		= d["partitions"]:[];
		    part 		= add ( part, partition );
		    d["partitions"]	= sort(`x, `y, part, ``(x["order"]:-1 < y["order"]:-1 ));
		    
		}
		y2milestone("KS Drive: %1", d);
	    });
	});

	list newdrives = maplist(map drive, drives, ``{

	    integer numpart = size(drive["partitions"]:[]);
	    y2milestone("partitions: %1", numpart);
	    boolean ismax = false;	    	    
	    if ( drive["partitions", numpart -1 , "grow"]:false )
	    {				
		ismax = true;
	    }
	    integer i = 1;
	    list dp = maplist(map p,  drive["partitions"]:[], ``{
		if (i == numpart && ismax)
		{
		    p ["size"] = "max";
		}
		p = remove(p, "grow");
		p = remove(p, "order");
		i = i + 1;
		return(p);
	    });

	    map clearpart = ksConfig["clearpart"]:$[];
	    string devicetok = select(splitstring(drive["device"]:"","/"), 1, "");
	    if (devicetok != "" && clearpart["drives"]:"" != "")
	    {
		if (issubstring(clearpart["drives"]:"", devicetok))
		{
		    if (clearpart["all"]:-1 == 1)
			drive["use"] = "all";
		    else if (clearpart["linux"]:-1 == 1)
			drive["use"] = "linux";
		    else if (clearpart["initlabel"]:-1 == 1)
			drive["initialize"] = true;
		}		
	    }
	    else if  ( clearpart["drives"]:"" == "" )
	    {
		if (clearpart["all"]:-1 == 1)
		drive["use"] = "all";
		else if (clearpart["linux"]:-1 == 1)
		drive["use"] = "linux";
		else if (clearpart["initlabel"]:-1 == 1)
		drive["initialize"] = true;
	    }
	    
	    drive["partitions"] = dp;
	    return (drive);
	    
	});

	
	y2milestone("Drives: %1", newdrives);
	return newdrives;
	
    }

    /**
     * KS RAID
     */   
    global define list ks_raid (map ksConfig)
	``{

	list raid = maplist(`d,`data, ksConfig["raid"]:$[], ``{
	    map r = $[];
	    r["mount"]		= d;
	    r["format"] 	= (data["nofromat"]:0 == 1) ? false : true;
	    r["name"] 		= sformat("/dev/%1", data["device"]:"md0");
	    r["raid_level"] 	= sformat("raid%1", data["level"]:0);
	    return (r);
	});
	return raid;
    }


    /**
     * KS Network
     */
    global define list  ks_network (map ksConfig) ``{
	include "network/ip.ycp";

	map init = $[];
	map networking = $[];
	map dns = $[];

	list nameserver = [];
	string gateway = "";

	map routing = $[];
	map rawNet = ksConfig["networking"]:$[];
	list interfaces = maplist(`iface, `data, rawNet, ``{
	    map interface = $[];
	    if (data["bootproto"]:"" == "dhcp")
	    {
		interface["bootproto"] = "dhcp";
		interrface["device"] = iface;
		interrface["startmode"] = "onboot";
		init["usedhcp"] = true;
	    }
	    else
	    {
		interface["device"] = iface;
		interface["bootproto"] = "static";
		interface["network"] =  compute_network(data["ip"]:"",data["netmask"]:"");
		interface["ipaddr"] = data["ip"]:"";
		interface["netmask"] = data["netmask"]:"";
		interface["startmode"] = "onboot";
		interface["broadcast"] = compute_broadcast(data["ip"]:"",data["netmask"]:"");

		init["ip"] = data["ip"]:"";
		init["nameserver"] = data["nameserver"]:"";
		init["netmask"] = data["netmask"]:"";
		init["gateway"] = data["gateway"]:"";
		init["netdevice"] = data["device"]:"";
		nameserver = [ data["nameserver"]:""];
		gateway =  data["gateway"]:"";
	    }
	    return (interface);
	});




	list searchlist = [];

	string hostname = "";
	string domain = "";

	dns["hostname"] = hostname;
	dns["domain"] = domain;
	dns["searchlist"] = searchlist;
	dns["nameservers"] = nameserver;

	list routes= [];
	map route = $[];

	if (gateway!="")
	{
	    route["destination"] = "default";
	    route["device"] = "-";
	    route["gateway"] = gateway;
	    route["netmask"] = "-";
	    routes=add(routes, route);
	}
	routing=add(routing, "routes", routes);
	routing=add(routing,"ip_forwarding", false);

	networking["interfaces"] = interfaces;
	networking["dns"] = dns;
	networking["routing"] = routing;


	// init
	if (haskey(ksConfig, "nfs"))
	{
	    map nfs = ksConfig["nfs"]:$[];
	    init["instmode"] = "nfs";
	    init["server"] = nfs["server"]:"";
	    init["serverdir"] = nfs["dir"]:"";
	}

	if (ksConfig["textmode"]:0  == 1)
	{
	    init["textmode"] = true;
	}

	return [networking, init];
    }


    /**
     * KS Authentication
     */
    global define ks_auth(map ksConfig) ``{

	map auth = ksConfig["auth"]:$[];

	// NIS
	map nis = $[];
	map security = $[];
	map ldap = $[];


	if (auth["enablenis"]:0 == 1)
	{
	    nis["start_nis"] = true;
	    if (haskey(auth, "nisdomain"))
		nis["nis_domain"] = auth["nisdomain"]:"";
	    if (haskey(auth, "nisserver"))
	    {
		list nisserver = [ auth["nisserver"]:"" ];
		nis["nis_servers"] = nisserver;
	    }
	}

	if (auth["enablemd5"]:0 == 1)
	{
	    security["encryption"] = "md5";
	}


	if (auth["enableldapauth"]:0 == 1)
	{
	    ldap["start_ldap"] = true;
	    if (haskey(auth, "nisdomain"))
		ldap["ldap_domain"] = auth["ldapbasedn"]:"";
	    if (haskey(auth, "ldapserver"))
		ldap["ldap_server"] = auth["ldapserver"]:"";
	    if ((auth["enableldaptls"]:0 == 1))
		ldap["ldap_tls"] = true;
	}

	return [nis, ldap, security];

    }

    /**
     * KS Bootloader
     */
    global define ks_bootloader (map ksConfig) ``{

	map bl = ksConfig["bootloader"]:$[];
	map bootloader = $[];
	if (bl["location"]:"" != "none")
	{
	    bootloader["location"] = bl["location"]:"";
	}
	else
	{
	    bootloader["write_bootloader"] = false;
	}

	bootloader["kernel_parameters"] = bl["append"]:"";
	if (haskey(bl, "linear") || haskey(bl, "nolinear") )
	{
	    bootloader["linear"] = (bl["linear"]:0 == 1 || !bl["nolinear"]:0 == 1);
	}
	bootloader["lba_support"] = (bl["lba32"]:0 == 1);
	return bootloader;
    }

    /**
     * KS Software
     */
    global define ks_software (map ksConfig)
	``{

	map software = $[];
	list all = ksConfig["packages"]:[];
	list selections = filter(`s, all, ``(issubstring(s, "@")));
	list packages = filter(`s, all, ``(!issubstring(s, "@")));
	list nopackages =  filter(`s, all, ``(regexpmatch( s, "^-.*" )));
	software["base"] = "Minimal";
	software["packages"] = packages;
	software["nopackages"] = nopackages;


	return software;
    }
}
