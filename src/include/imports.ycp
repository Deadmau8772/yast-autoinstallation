/**
 * File:	include/autoinstall/imports.ycp
 * Package:	Autoinstallation Configuration System
 * Summary:	Imports older and foreign format
 * Authors:	Anas Nashif<nashif@suse.de>
 *
 * $Id$
 */
{
    textdomain "autoinst";
    // include "autoinstall/classes.ycp";

    global define aliceImportOptions()
	``{
	Wizard::SetScreenShotName ("autoyast-alice-1");
	string title = _("Import Alice configuration");

	string help = _("<p>Using this feature, you can import <b>Alice</b> configuration
files.</p>");
	help = help + _("<p>System configuration in  <em>Alice</em> files may vary in their scope from what is offered
in <b>AutoYaST</b>, so some limitations should be taken into consideration. A standard <em>Alice</em>
configuration file with no special customization can however be imported without any loss of data.</p>");

	
	term contents =
	    `Top(
		 `VBox(
		       `Left(`HBox(
				   `TextEntry(`id(`alicerep), _("Alice &Home"), AIServer::aliceRep),
				   `HStretch()
				   )
			     ),
		       `VSpacing(1),
		       `Left(`Label(_("What should be done with loaded data?"))),
		       `HBox(
			     `HWeight(10, `Empty()),
			     `HWeight(90, `RadioButtonGroup(`id(`rbg),
							    `VBox(
								  `Left(
									`RadioButton(`id(`hostname), `opt(`notify),_("&Use hostname from alice as profile name"),
										     (AIServer::aliceOutput == `hostname))
									),
								  `Left(
									`RadioButton(`id(`save),`opt(`notify), _("Save result &into Repository"),
										     (AIServer::aliceOutput == `save))
									),
								  `Left(
									`HBox(
									      `HStretch(),
									      `TextEntry(`id(`result), _("Name of resulting &profile"), ""),
									      `HStretch()
							    
									      )
									),
								  `Left(
									`RadioButton(`id(`load), `opt(`notify),_("&Load resulting profile"), (AIServer::aliceOutput == `load) )
									)
								  )
							    )
				      )
			     )
		       )
		 );
		
	Wizard::SetContents(title,
			    contents, help , true, true);

	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();
		AIServer::aliceRep = UI::QueryWidget(`id(`alicerep), `Value);
		AIServer::aliceOutput = UI::QueryWidget(`id(`rbg), `CurrentButton);
		if ( AIServer::aliceOutput == `save && ret == `next)
		{
		    if ( UI::QueryWidget(`id(`result), `Value) != "" )
		    {
			AIConfig::currentFile =  UI::QueryWidget(`id(`result), `Value);
		    }
		    else
		    {
			UI::MessagePopup(_("Please provide a valid profile name"));
			continue;
		    }
		}
		
		
	    } until  (ret == `next ||  ret == `back || (ret == `abort && UI::ReallyAbortPopup (AIConfig::changed)));
	Wizard::RestoreScreenShotName ();
	return ret;
    }
    
    /**
     * Generate control file list
     * @return file list
     */
    global define aliceHostList()
	``{
	
	list files = SCR::Read(.target.dir, AIServer::aliceRep + "/info");
	list extensions = ["sys.tcf"	];
	list hosts = [];
	string host = "";
	foreach(string file, files, ``{
	    foreach(`ext, extensions, ``{
		if (issubstring(file, ext))
		{
		    integer extsize = size(splitstring(ext, "."));
		    list comp = splitstring(file, ".");
		    integer i = 0;
		    while (i < extsize) {
			comp  = remove(comp, size(comp) - 1 );
			i = i + 1;
		    }
		    
		    hosts=add(hosts,mergestring(comp,"."));
		}
	    });
		
	});
	list hostfiles = maplist(string host, toset(hosts), ``{
	    return (`item(`id(host), host));
	});
	
	term contents =
	    `VBox(	
		  `VSpacing(0.5),
		  `Table(`id(`table), `opt(`notify,`immediate), `header("Host"),
			 hostfiles
			 ),

		  `VSpacing(0.5),
		  `VBox(
			`HBox(			      
			      `PushButton(`id(`import), _("&Import"))			      
			      )

			),
		  `VSpacing(0.5)
		  );
	return contents;
    }



    
    global define aliceImportList()
	``{

	Wizard::SetScreenShotName ("autoyast-alice-2");
	
	string help = _("<p>Using this dialog you can select a
host from the <b>ALICE</b> repository.</p>
");
	help = help + _("<p>Converting <b>ALICE</b> data to be used with the new auto-installation
system might take some time, so please be patient while
the configuration files are being read and converted.
</p>");
	Wizard::SetContents(_("Hosts in Alice Repository"),
			    aliceHostList(), help, true, true);
	UI::ChangeWidget(`id(`next), `Label, NextButtonLabel);
	UI::ChangeWidget(`id(`next), `Enabled, false);
	
	any ret = "";
	string host = "";
	repeat
	    {
	    ret = UI::UserInput();
	    if (ret == `import)
	    {
		host = UI::QueryWidget(`id(`table), `CurrentItem);
		if (host != nil && host != "")
		{
		    showFeedback(_("
Reading Alice configuration files,
this may take a while, please wait...
"));

		    map aliceConf = $[];
		    any aliceret = createAliceConf(host);		    
		    if (is(aliceret, map) && aliceret != $[])
		    {
			aliceConf = aliceret;
		    }
		    else
		    {
			UI::ErrorPopup(_("Error while importing ALICE data"));
			clearFeedback();
			continue;			    
		    }
			
		    AIConfig::Import(createProfile(aliceConf));
		    clearFeedback();
		    UI::ChangeWidget(`id(`next), `Enabled, true);
		}
	    }
	} until (ret == `next ||  ret == `back || (ret == `abort && UI::ReallyAbortPopup (AIConfig::changed)));
	
	if (ret == `next) {
	    if (AIServer::aliceOutput == `hostname)
	    {
		AIConfig::currentFile = sformat("%1.xml", host);
		ret = `save;
	    }	  
	    else
	    {
		ret = AIServer::aliceOutput;
	    }
	}
	Wizard::RestoreScreenShotName ();
	return ret;
    }

    global define any createAliceConf(string host)
	``{
	
	string MakeinfoCommand = "alice make_info_file --yast2 ";
	MakeinfoCommand = MakeinfoCommand + host;	
	map out = SCR::Execute(.target.bash_output, MakeinfoCommand, $["YAST2_TMPDIR":AIServer::tmpDir, "ALICE_HOME":AIServer::aliceRep]);
	string filelist = SCR::Read(.target.string, AIServer::tmpDir + "/filelist");
	list files = splitstring(filelist, "\n");
	y2milestone("files: %1", files);
	
	any ret =  mergeFiles(files, AIServer::tmpDir);
	SCR::Execute(.target.remove,  AIServer::tmpDir + "/filelist");
	y2milestone("alice conf %1", ret);
	return ret;
    }

    global define map mergeFiles(list files, string dir)
	``{
	include "autoinstall/xml.ycp";
	aliceXmlSetup();
	integer cnt = 0;
	string base = "";
	foreach (`f, files, ``{	    
	    if (f!="") {
		
		string filename = sformat("%1/%2", dir, f);
		y2milestone("Working on %1", filename);
		base = sformat("%1/base.xml", dir);
		if (cnt == 0)
		{
		    _cleanup(filename, base);
		}
		else
		{
		
		    string MergeCommand = "/usr/bin/xsltproc --param replace \"'true'\" --param with ";	
		    MergeCommand = MergeCommand + "\"'" + filename + "'\"  ";
		    MergeCommand = MergeCommand + "--output " +  dir + "/mergeOutput ";
		    MergeCommand = MergeCommand + " /usr/share/autoinstall/xslt/merge.xslt ";
		    MergeCommand = MergeCommand +   base + " ";
	
		    y2milestone("Merge command: %1", MergeCommand);
	
		    map out = SCR::Execute(.target.bash_output, MergeCommand, $[]);
		    y2milestone("Merge stdout: %1, stderr: %2", out["stdout"]:"", out["stderr"]:"");
		    _cleanup(sformat("%1/mergeOutput", dir), base);
		}
		
		cnt = cnt + 1;
	    }
	    
	});
	any ret = XML::XMLToYCPFile(base);
	
	return (ret);	
    }

    
    global define _cleanup(string in, string out)
	``{	
	map ycpin = XML::XMLToYCPFile(in);
	y2milestone("Writing file as %1", out);

	map sortedMap = $[];
	list keys = toset(maplist(`k,`v, ycpin, ``(k)));
	foreach(`k, keys, ``{
	    sortedMap[k]=ycpin[k]:"";
	});
	return XML::YCPToXMLFile(`alice, sortedMap, out);
    }
    
    /**
     * Create the profile from Alice data
     * @param map alice data
     * @return map Profile
     */

    global define map createProfile(map aliceConf)
	``{	
	import "Misc";
	// General resource
	////////////////////////////////////////////////////////
	map keymap2yast1 = $[
			     "us"		:"english-us",
			     "de-lat1-nd"	:"german",
			     "fr-latin1"	:"french",			    
			     "it"		:"italian",
			     "es"		:"spanish",
			     "nl"		:"dutch",
			     "pt2"		:"portugese",
			     "br-abnt2"		:"portugese-br",
			     "hu"		:"hungarian",
			     "Pl02"		:"polish" ,
			     "gr"		:"greek"  ,
			     "trq"		:"turkish",
			     "ru1"		:"russian",
			     "cz-lat2"		:"czech" 
	];
	map lang2iso = SCR::Read( .target.yast2, "lang2iso.ycp");

	map general = $[];
	map install = $[];
	map configure = $[];
	
	// SYS_LANGUAGE, SYS_KEYTABLE, SYS_TIMEZONE, SYS_MOUSE_DEVICE, SYS_HWC_GMT
	string language = aliceConf["SYS_LANGUAGE"]:"english";
	general["language"] = lang2iso[language]:"en_US";
	string keymap = aliceConf["SYS_KEYTABLE"]:"us";
	general["keyboard"] = keymap2yast1[keymap]:"english-us";
	general["timezone"] =  aliceConf["SYS_TIMEZONE"]:"CET";
	if ( aliceConf["SYS_HWC_GMT"]:"no" == "yes")
	    general["hwclock"] = "GMT";
	else
	    general["hwclock"] = "localtime";

	map mice = Misc::ReadAlternateFile ("mouse_db.ycp", "mouse_raw.ycp");
        y2debug("Mice %1", mice);	
	boolean found = false;
	foreach(`k,`v, mice, ``{
	    map data = select(v,1,$[]);
	    y2debug("yours %1, mine %2",  data["device"]:"", aliceConf["SYS_MOUSE_DEVICE"]:"none");
	    if ( data["wheels"]:0 == 0 && data["device"]:"" == aliceConf["SYS_MOUSE_DEVICE"]:"none")
	    {
		general["mouse"] = k;
		found = true;
	    }
	});
	if (!found)
	    general["mouse"] = "probe";


	
	list drives = [];
	map newDrive = $[];
	foreach(`k,`v, aliceConf , ``{
	    if (issubstring(k, "SYS_PART")) {	
		string device =  "/dev/" + select(splitstring(k,"_"), 2, "");		
		list partitions  = createAlicePartitions(v);
		y2milestone("Partitions for %1: %2", device , partitions );
		drives = add(drives, $["device":device, "partitions": partitions]);
	    }
	});
	


	install["partitioning"] = drives;	
	install["general"] = general;
	install["software"] = createAliceSoftware(aliceConf);	
	configure["networking"] = createAliceNetwork(aliceConf);

	install["init"] = aliceInit(aliceConf, 	configure["networking"]:$[]);
	configure["users"] =  createAliceUsers(aliceConf);
	if (aliceConf["NETWORK_NIS_YPDOMAIN"]:"" != "")
	    configure["nis"] =  createAliceNis(aliceConf);
	
	map profile = $[];
	profile["install"] = install;
	profile["configure"] = configure;
	y2milestone("Profile : %1", profile);
	return profile;
    }

    /**
     * create partition list from alice data
     * @param string partition
     * @return list  list of partitions
     */    
    global define list createAlicePartitions(string partitions)
	``{
	SCR::Write(.target.string, "/tmp/alice_part", partitions);
	
	list raw_part =  SCR::Read(.tmp.alice.part);
	
	list part =filter(`pe, raw_part, ``(!haskey(pe, "path")));
	y2milestone("and parts again: %1", part);
	list newPartitions = maplist(`p, part, ``{
	    map newPart = $[];
	    
	    if (p["mount"]:""!="NONE" && p["mount"]:""!="SWAP")
	    {
		newPart["mount"] = p["mount"]:"";
	    }
	    else if (p["mount"]:"" == "SWAP")
	    {
		newPart["partition_id"]= tointeger(sformat("0x%1","82"));		
	    }
	    
	    if (p["size"]:-1 == 0)
	    {
		newPart["size"]= "max";
	    }
	    else
	    {
		newPart["size"]= sformat("%1mb", p["size"]:0);
	    }
		
	    if (haskey(p,"id")) {
		string hex = sformat("0x%1", p["id"]:"83");
		newPart["partition_id"]= tointeger(hex);
	    }
	    if (haskey(p,"num")) {
		newPart["partition_nr"]= tointeger(p["num"]:"0");
	    }

	    return newPart;	    	
	});
	SCR::Execute(.target.remove,  "/tmp/alice_part");
	SCR::UnmountAgent(.tmp.alice.part);
	y2milestone("Alice Partitions %1", newPartitions);
	return  newPartitions;
    }

    /**
     * create software map from alice data
     * @param map aliceConf alice configuration
     * @return map  software map
     */
    
    global define map createAliceSoftware(map aliceConf) ``{

	map software= $[];
	string base = "";
	if (size(aliceConf["SYS_SW_SELLIST"]:"")>0)
	{
	    string SYS_SW_SELLIST = aliceConf["SYS_SW_SELLIST"]:"";	    
	    software["packages"] = readSelection(SYS_SW_SELLIST);
	}
	else if (aliceConf["SYS_SW_SELECTION"]:"" != "")
	{
	    list tmpsel = splitstring(aliceConf["SYS_SW_SELECTION"]:"", "/");
	    base = select(tmpsel, size(tmpsel) - 1 , "");
	    software["base"] = select(splitstring(base, "."), 0, "Minimal");
	}
	
	if (aliceConf["SYS_INST_KERNEL"]:"" != "")
	{
	    software["kernel"] = aliceConf["SYS_INST_KERNEL"]:"";
	}
	if (aliceConf["SYS_SW_ADDLIST"]:"" != "")
	{
	    string SYS_SW_ADDLIST = aliceConf["SYS_SW_ADDLIST"]:"";	    
	    software["packages"] = readSelection(SYS_SW_ADDLIST);
	}
	if (aliceConf["SYS_SW_AUXLIST"]:"" != "")
	{
	    string SYS_SW_AUXLIST = aliceConf["SYS_SW_AUXLIST"]:"";
	    map extra = $[];
	    extra["packages"] = readSelection(SYS_SW_AUXLIST);
	    extra["package_location"] = "custom";
	    software["extra_packages"] = extra;
	}
	return software;
	
    }
    /**
     * Read package selection from a file
     * @param string selection as string
     * @return list package selection list
     */
    global define list readSelection(string selection) ``{
	SCR::Write(.target.string, "/tmp/alice_software", "Toinstall:\n" + selection + "\nLlatsniot:\n");
	list sel = filter(`p, SCR::Read(.yast1sel.selection,"/tmp/alice_software"), ``(p!=""));	    
	SCR::Execute(.target.remove, "/tmp/alice_software");
	SCR::UnmountAgent(.tmp.alice.software);
	return sel;
    }


    
    /**
     * create network map from alice data
     * @param map aliceConf alice configuration
     * @return map  network map
     */ 
    global define map createAliceNetwork(map aliceConf) ``{ 
	 include "network/ip.ycp";
	 string network =  aliceConf["NET_IP_CONFIG"]:"";
	 string DNS_NAMESERVER = aliceConf["DNS_NAMESERVER"]:"";
	 string DNS_SEARCHLIST = aliceConf["DNS_SEARCHLIST"]:"";
	 string SYS_NAME = aliceConf["SYS_NAME"]:"";
	 string DEF_GATEWAY = aliceConf["DEF_GATEWAY"]:"";
	 string ROUTES = aliceConf["ROUTES"]:"";
	 
	 
	 map networking = $[];
	 map dns = $[];
	 map routing = $[];


	 
	 SCR::Write(.target.string, "/tmp/alice_network", network);
	 map raw_interfaces =SCR::Read(.tmp.alice.network);
	 list interfaces = maplist(`iface, `data, raw_interfaces, ``{
	     map interface = $[];
	     if (data["bootproto"]:"" == "dhcpclient")
	     {
		 interface["bootproto"] = "dhcp";
		 interrface["device"] = iface;
		 interrface["startmode"] = "onboot";
	     }
	     else
	     {
		 interface["device"] = iface;
		 interface["bootproto"] = "static";
		 interface["network"] =  compute_network(ip2string(data["ipaddr"]:""),ip2string(data["netmask"]:""));
		 interface["ipaddr"] = ip2string(data["ipaddr"]:"");
		 interface["netmask"] = ip2string(data["netmask"]:"");
		 interface["startmode"] = "onboot";
		 interface["broadcast"] = compute_broadcast(ip2string(data["ipaddr"]:""),ip2string(data["netmask"]:""));
	     }
	     return (interface);
	 });

	 list nameserver = filter(`n, splitstring(DNS_NAMESERVER, " "), ``(n!= "" && n!= " "));
	 list searchlist = filter(`s, splitstring(DNS_SEARCHLIST, " "), ``(s!= "" && s!= " "));
	 
	 string hostname = select(splitstring( SYS_NAME, "."), 0 , "");
	 string domain = mergestring(remove(splitstring( SYS_NAME, "."), 0), ".");
	 
	 dns["hostname"] = hostname;
	 dns["domain"] = domain;
	 dns["searchlist"] = searchlist;
	 dns["nameservers"] = nameserver;

	 list routes= [];
	 map route = $[];

	 if (DEF_GATEWAY!="") {
	     route["destination"] = "default";
	     route["device"] = "-";
	     route["gateway"] = DEF_GATEWAY;
	     route["netmask"] = "-";
	     routes=add(routes, route);
	 }
	 if (ROUTES!="") {
	     SCR::Write(.target.string, "/tmp/alice_routes", ROUTES);
	     list raw_routes =SCR::Read(.tmp.alice.routes);
	     routes = union(routes, raw_routes);
	 }
	 routing=add(routing, "routes", routes);
	 routing=add(routing,"ip_forwarding", false);
	 
	 networking["interfaces"] = interfaces;
	 networking["dns"] = dns;
	 networking["routing"] = routing;
	 
	 return networking;
     }



    /**
     * create NIS map from alice data
     * @param map aliceConf alice configuration
     * @return map  NIS map
     */
    global define map createAliceNis (map aliceConf) ``{
	map nis = $[];
	string nis_domain = aliceConf["NETWORK_NIS_YPDOMAIN"]:"";
	list nis_servers = splitstring( aliceConf["NETWORK_NIS_YPSERVER"]:"", " ");
	nis["nis_domain"] = nis_domain;
	nis["nis_servers"] = nis_servers;
	nis["start_nis"] = true;
	
	return nis;
    }

    /**
     * create users list from alice data
     * @param map aliceConf alice configuration
     * @return list  List of users
     */
    global define list  createAliceUsers (map aliceConf) ``{
	list users = [];
	// root
	map root = $[];
	root["encrypted"] = true;
	root["username"] = "root";
	root["user_password"] =  aliceConf["SYS_ROOT_START_PWD"]:"";
	users=add(users,root);

	return users;
    }

    global define aliceInit(map aliceConf, map networking)``{
	map init = $[];
	y2milestone("networking %1", networking);
	if ( aliceConf["SYS_BOOT_MODE"]:"" == "NET") {
	    init["instmode"] = "nfs";
	}
	if (size(aliceConf["SYS_INST_DIR"]:"") > 0) {
	    string serverdir = regexpsub( aliceConf["SYS_INST_DIR"]:"", "(.*)\%version(.*)", "\\1" + aliceConf["SYS_OS_VERSION"]:"" + "\\2");
	    y2milestone("serverdir: %1", serverdir);	    
	    init["serverdir"] = regexpsub( serverdir, "(.*)\%arch(.*)", "\\1" + aliceConf["SYS_ARCH"]:"" + "\\2");
	   
	}
	if (haskey(aliceConf,"SYS_INSMOD_MODULES")) {
	    list modules = splitstring(aliceConf["SYS_INSMOD_MODULES"]:"", "\n");
	    init["insmod"]=modules;
	}
	if (haskey(aliceConf,"SYS_KEYTABLE")) {	    
	    init["keytable"]=aliceConf["SYS_KEYTABLE"]:"";
	}
	if (haskey(aliceConf,"SYS_LANGUAGE")) {	    
	    init["language"]=aliceConf["SYS_LANGUAGE"]:"";
	}
	if (haskey(aliceConf,"SYS_INST_SERVER")) {	    
	    init["server"]=aliceConf["SYS_INST_SERVER"]:"";
	}

	if (haskey(aliceConf,"NET_INST_DEV")) {	    
	    init["netdevice"]=aliceConf["NET_INST_DEV"]:"";
	}

	list ifaces = networking["interfaces"]:[];
	foreach(`iface, ifaces, ``{
	    if (iface["device"]:"" == init["netdevice"]:"")
	    {
		init["ip"] = iface["ipaddr"]:"";
		init["netmask"] = iface["netmask"]:"";		
	    }
	});
	init["gateway"] = aliceConf["DEF_GATEWAY"]:"";
	return init;
	
    }

    
    global define kickstartImport()
	``{
	Wizard::SetScreenShotName ("autoyast-kickstart");
	
	string title = _("Import Kickstart files");
	string help = _("<p>Using this feature, you can import <b>Kickstart</b> configuration
files.</p>");
	help = help + _("<p>System configuration in a <em>Kickstart</em> file may vary in it's scope from what is offered
in <b>AutoYaST</b>, so some limitations should be taken into consideration. A standard <em>Kickstart</em>
configuration file with no distribution specific configuration options can still be imported without
much loss of data</p>");

	help = help + _("<p>The main problem you will be facing when importing a <em>Kickstart</em> file
is the different package and package selection names used, those have to be adapted manually!</p>");

	term contents =
	    `Top(
		 `VBox(
		       `VSquash(
				`HBox(
					
				      `TextEntry(`id(`filename), _("Kickstart file name"), ""),
				      `VBox(
					    `VSpacing(),
					    `PushButton(`id(`open), `opt(`notify), _("Select File"))
					    )
				      )
				),
			 
		       `VSpacing(1),
		       `Left(`Label(_("What should be done with loaded data?"))),
		       `HBox(
			     `HWeight(10, `Empty()),
			     `HWeight(90, `RadioButtonGroup(`id(`rbg),
							    `VBox(
								  `Left(
									`RadioButton(`id(`hostname), `opt(`notify),_("&Use  file name as new profile name"),
										     (AIServer::ksOutput == `hostname))
									),
								  `Left(
									`RadioButton(`id(`save),`opt(`notify), _("Save result &into Repository"),
										     (AIServer::ksOutput == `save))
									),
								  `Left(
									`HBox(
									      `HStretch(),
									      `TextEntry(`id(`result), _("Name of resulting &profile"), ""),
									      `HStretch()
							    
									      )
									),
								  `Left(
									`RadioButton(`id(`load), `opt(`notify),_("&Load resulting profile"), (AIServer::ksOutput == `load) )
									)
								  )
							    )
				      )
			     )
		       )
		 );	

		
	Wizard::SetContents(title,
			    contents, help , true, true);
	UI::ChangeWidget(`id(`next), `Label, NextButtonLabel);
	string filename = "";
	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();
		
		filename = UI::QueryWidget(`id(`filename), `Value);
		AIServer::ksOutput = UI::QueryWidget(`id(`rbg), `CurrentButton);
		
		if ( AIServer::ksOutput == `save && ret == `next)
		{
		    if ( UI::QueryWidget(`id(`result), `Value) != "" )
		    {
			AIConfig::currentFile =  UI::QueryWidget(`id(`result), `Value);
		    }
		    else
		    {
			UI::MessagePopup(_("Please provide a valid profile name"));
			continue;
		    }
		}
		
		if (ret == `open)
		{
		    filename = PopupFile(AIConfig::Repository + "/");
		    if (filename!="")
		    {
			UI::ChangeWidget(`id(`filename), `Value, filename);
		    }
		}
		else if (ret == `next && filename != "")
		{
		    
		    map ksConfig = readKS(filename);
		    AIConfig::Import(ks2ay(ksConfig));
		    UI::WarningPopup(_("
Importing foreign configuration files means that
you need to go through the package and software configuration
to make sure that the packages and selections are compatible with
SuSE package names and package groups."));
		    
		}
		else if (ret == `next && filename == "")
		{
		    UI::MessagePopup(_("Please select a file first!"));
		    UI::SetFocus(`id(`filename));
		    continue;
		}
		
	    } until  (ret == `next ||  ret == `back || (ret == `abort && UI::ReallyAbortPopup (AIConfig::changed)));

	
	if (ret == `next)
	{
	    if (AIServer::ksOutput == `hostname)
	    {
		AIConfig::currentFile = filename;
		ret = `save;
	    }	  
	    else
	    {
		ret = AIServer::ksOutput;
	    }
	}
	return ret;
	Wizard::RestoreScreenShotName ();
    }


    global define boolean readKS(string ks)``{

	map ksConfig = SCR::Read(.kickstart, ks);
	SCR::UnmountAgent(.kickstart);
	if (ksConfig == $[])
	{
	    return $[];
	}
	y2milestone("Kickstart config raw: %1", ksConfig);
	
	return ksConfig;
	
    }

    global define map ks2ay(map ksConfig) ``{

	map profile = $[];
	map general = $[];
	map install = $[];
	map configure = $[];

	// Scripts
	configure["scripts"] 	= ks_scripts(ksConfig);
	configure["networking"] = select(ks_network(ksConfig), 0 , $[]);
	configure["nis"] 	= select(ks_auth(ksConfig), 0 , $[]);
	configure["ldap"] 	= select(ks_auth(ksConfig), 1 , $[]);
	configure["security"] 	=  select(ks_auth(ksConfig), 2 , $[]);
	
	install["init"] 	= select(ks_network(ksConfig), 1 , $[]);
	install["software"] 	=  ks_software(ksConfig);
	install["partitioning"] = ks_part(ksConfig);
	install["raid"] 	= ks_raid(ksConfig);
	install["bootloader"] 	=  ks_bootloader(ksConfig);
	install["general"] 	= ks_general(ksConfig);
	
	profile["install"] 	= install;
	profile["configure"] 	= configure;
	AIConfig::changed 	= true;
	
	y2milestone("Profile : %1", profile);
	return profile;
	
    }

    global define map ks_users (map ksConfig)
	``{

	map ks_user =  ksConfig["users"]:$[];
	list users = [];
	map root = $[];
	root["username"] = "root";
	root["password"] = ks_user["password"]:"";
	root["encrypted"] = (ks_user["iscrypted"]:0 == 1);

	users = add(users, root);
	return users;
	
	
    }

    global define map kx_x11(map ksConfig)
	``{
	if (ksConfig["skipx"]:0 != 1 && haskey(ksConfig,"xconfig"))
	{
	    map x11 = $[];
	    map ks_x = ksConfig["xconfig"]:$[];

	    if (haskey(ks_x, "depth"))
		x11["color_depth"] = ks_x["depth"]:0;
	    
	    if (haskey(ks_x, "resolution"))
		x11["resolution"] = ks_x["resolution"]:"";

	    if (haskey(ks_x, "startxonboot"))
		x11["startxonboot"] = ks_x["startxonboot"]:"";

	    if (haskey(ks_x, "defaultdesktop"))
		x11["default_desktop"] = ks_x["defaultdesktop"]:"";

	    map monitor = $[];
	    if (haskey(ks_x, "vsync") || ks_x["monitor"]:"")
	    {
		
		map display = $[];
		list hsync = splitstring(ks_x["hsync"]:"", "-");
		list vsync = splitstring(ks_x["vsync"]:"", "-");
		display["min_hsync"] = select(hsync,0,"");
		display["min_vsync"] = select(vsync,0,"");
		display["max_hsync"] = select(hsync,1,"");
		display["max_vsync"] = select(vsync,1,"");
		monitor["monitor_vendor"] = select(splitstring(ks_x["monitor"]:"", " "), 0 , "");
		monitor["monitor_device"] = select(splitstring(ks_x["monitor"]:"", " "), 1 , "");
		monitor["display"] = display;
		
	    }
	    if (size(monitor) > 0 )
	    {
		x11["monitor"] = monitor;
	    }
	    x11["configure_x11"] = true;
	    return x11;
	}
	else
	{
	    return $[];
	}
    }
    
    global define map ks_general(map ksConfig)
	``{
	map general = $[];
	
	// Language	
	general["language"] = ksConfig["language"]:"";

	// Keyboard
	map keyboard = $[];	
	if (haskey( ksConfig , "keyboard"))
	{
	    import "Keyboard";
	    map keyboards =  Keyboard::keymap2yast();	
	    keyboard["keymap"] = keyboards[ksConfig["keyboard"]:""]:"";
	}
	
	general["keyboard"] = keyboard;
	
	// Mouse
	map mouse = $[];
	
	if(haskey(ksConfig, "mouse"))
	{
	    map ks_mouse 	= ksConfig["mouse"]:$[];
	    mouse["device"] 	= ks_mouse["device"]:"";
	    mouse["xemu3"]	= ( ks_mouse["emulthree"]:0 == 1);
	    if (ks_mouse["type"]:"" == "none")
	    {
		mouse["id"]	= "non";
	    }
	}
	general["mouse"] = mouse;

	// Clock
	map  clock = $[];
	if (haskey(ksConfig, "timezone"))
	{
	    map ks_clock = ksConfig["timezone"]:$[];
	    clock["timezone"] 	= ks_clock["timezone"]:"";
	    clock["utc"]	= ( ks_clock["utc"]:0 == 1 );
	}
	general["clock"] = clock;

	
	// Mode
	map mode = $[];
	if (haskey(ksConfig, "mode"))
	{	    
	    mode["installation"] 	= ( ksConfig["mode"]:"" == "install" );
	    mode["upgrade"] 		= ( ksConfig["mode"]:"" == "upgrade" );
	  
	}
	mode["reboot"] 		= ( ksConfig["reboot"]:0 == 1 );
	mode["interactive"] 	=  ( ksConfig["interactive"]:0 == 1 );
	general["mode"] = mode;
			
	   
	return general;
	
    }

    
    global define map ks_scripts(map ksConfig)
	``{
	map scripts = $[];
	list postscripts = [];
	list prescripts = [];
	
	if (haskey(ksConfig, "post-script"))
	{
	    map script = $[];
	    script["source"] = SCR::Read(.target.string, ksConfig["post-script"]:"");
	    map post = ksConfig["post"]:$[];
	    script["interpreter"] = post["interpreter"]:"shell";
	    script["filename"] = "kspost";
	    postscripts = add(postscripts, script);	    
	}
	scripts["post-scripts"] =   postscripts;
	if (haskey(ksConfig, "pre-script"))
	{
	    map script = $[];
	    script["source"] = SCR::Read(.target.string, ksConfig["pre-script"]:"");
	    
	    script["interpreter"] = "/bin/sh";
	    script["filename"] = "kspre";
	    prescripts = add(prescripts, script);	    
	}
	scripts["pre-scripts"] =   prescripts;
	return scripts;	
    }


    
    /**
     * StringFS2Symbol()     
     * @param any filesystem string
     * @return symbol filesystem type
     */
    global define StringFS2Symbol(any fs)``{
	if (is(fs,symbol)) {
	    return fs;
	}
	map filesystems =
	    $[
	      "ext2":	`ext2,
	      "ext3":	`ext3,
	      "reiser":	`reiser,
	      "lvm":	`lvm,
	      "raid":	`raid,
	      "jfs":	`jfs,
	      "fat32":	`fat32,
	      "xfs":	`xfs,
	      "fat16":	`fat16,
	      "swap":	`swap	
	    ];
	return filesystems[fs]:`ext2;	
    }
    
    global define list ks_part (map ksConfig) ``{
	import "Partitions";
	list drives = [];
	list part1 = maplist(`k, `v, ksConfig["partitioning"]:$[],   ``{
	    map drive = $[];
	    if (haskey(v, "ondisk"))
	    {
		drive["device"] = v["ondisk"]:"";
	    }
	    drive["partitions"] = [];
	    
	    drives=add(drives, drive);
	});
	drives=toset(drives);

	
	foreach(`k, `v, ksConfig["partitioning"]:$[],   ``{
	    map partition = $[];
	    string mount = select(splitstring(k, "_"), 0 , "");
	    string fstype = (mount == "swap") ? "swap" :  v["fstype"]:"";
	    
	    integer partition_id = Partitions::fsid_native;	    
	    integer raiddevice = 0;
	    
	    if (regexpmatch(mount, "^raid\..*"))
	    {
		y2milestone("device: %1", mount);
		partition_id =  Partitions::fsid_raid;
		partition["partition_id"] = partition_id;
		raiddevice = tointeger(substring(mount, 5, 1)) ;
		
		partition["raid_name"] = sformat("/dev/md%1", raiddevice);
		partition["format"] = false;
		
	    }
	    else
	    {
		partition["mount"] = mount;
		partition["format"] = true;
		partition["filesystem"] = StringFS2Symbol(fstype);
	    }
	    
	   
	 

	    partition["size"] = sformat("%1mb", v["size"]:-1);
	    
	    if (v["grow"]:0 == 1)
	    {
		partition["size"] = "max";

	    }
	    foreach(`d, drives, ``{
		if (v["ondisk"]:"" == d["device"]:"")
		{
		    list part 		= d["partitions"]:[];
		    part 		= add(part, partition);
		    d["partitions"]	= part;
		}
	    });
	});
	



	return drives;
    }


    // $["/scr":$["device":"md0", "level":0]]
    global define list ks_raid (map ksConfig)
	``{
	
	list raid = maplist(`d,`data, ksConfig["raid"]:$[], ``{
	    map r = $[];
	    r["mount"]		= d;
	    r["format"] 	= (data["nofromat"]:0 == 1) ? false : true;
	    r["name"] 		= sformat("/dev/%1", data["device"]:"md0");
	    r["raid_level"] 	= sformat("raid%1", data["level"]:0);
	    return (r);
	});
	return raid;
    }

    global define list  ks_network (map ksConfig) ``{
	include "network/ip.ycp";
	
	map init = $[];		 
	map networking = $[];
	map dns = $[];

	list nameserver = [];
	string gateway = "";
	
	map routing = $[];
	map rawNet = ksConfig["networking"]:$[];
	list interfaces = maplist(`iface, `data, rawNet, ``{
	    map interface = $[];
	    if (data["bootproto"]:"" == "dhcp")
	    {
		interface["bootproto"] = "dhcp";
		interrface["device"] = iface;
		interrface["startmode"] = "onboot";
		init["usedhcp"] = true;
	    }
	    else
	    {
		interface["device"] = iface;
		interface["bootproto"] = "static";
		interface["network"] =  compute_network(data["ip"]:"",data["netmask"]:"");
		interface["ipaddr"] = data["ip"]:"";
		interface["netmask"] = data["netmask"]:"";
		interface["startmode"] = "onboot";
		interface["broadcast"] = compute_broadcast(data["ip"]:"",data["netmask"]:"");
		
		init["ip"] = data["ip"]:"";
		init["nameserver"] = data["nameserver"]:"";
		init["netmask"] = data["netmask"]:"";
		init["gateway"] = data["gateway"]:"";
		init["netdevice"] = data["device"]:"";
		nameserver = [ data["nameserver"]:""];
		gateway =  data["gateway"]:"";
	    }
	    return (interface);
	});


	
	
	list searchlist = [];
	 
	string hostname = "";
	string domain = "";
	 
	dns["hostname"] = hostname;
	dns["domain"] = domain;
	dns["searchlist"] = searchlist;
	dns["nameservers"] = nameserver;

	list routes= [];
	map route = $[];

	if (gateway!="")
	{
	    route["destination"] = "default";
	    route["device"] = "-";
	    route["gateway"] = gateway;
	    route["netmask"] = "-";
	    routes=add(routes, route);
	}
	routing=add(routing, "routes", routes);
	routing=add(routing,"ip_forwarding", false);
	 
	networking["interfaces"] = interfaces;
	networking["dns"] = dns;
	networking["routing"] = routing;


	// init
	if (haskey(ksConfig, "nfs"))
	{
	    map nfs = ksConfig["nfs"]:$[];
	    init["instmode"] = "nfs";
	    init["server"] = nfs["server"]:"";
	    init["serverdir"] = nfs["dir"]:"";
	}

	if (ksConfig["textmode"]:0  == 1)
	{
	    init["textmode"] = true;
	}

	return [networking, init];
    }

    global define ks_auth(map ksConfig) ``{

	map auth = ksConfig["auth"]:$[];

	// NIS
	map nis = $[];
	map security = $[];
	map ldap = $[];

	
	if (auth["enablenis"]:0 == 1)
	{
	    nis["start_nis"] = true;
	    if (haskey(auth, "nisdomain"))
		nis["nis_domain"] = auth["nisdomain"]:"";
	    if (haskey(auth, "nisserver"))
	    {
		list nisserver = [ auth["nisserver"]:"" ];
		nis["nis_servers"] = nisserver;
	    }
	}
	
	if (auth["enablemd5"]:0 == 1)
	{
	    security["encryption"] = "md5";
	}

	
	if (auth["enableldapauth"]:0 == 1)
	{
	    ldap["start_ldap"] = true;
	    if (haskey(auth, "nisdomain"))
		ldap["ldap_domain"] = auth["ldapbasedn"]:"";
	    if (haskey(auth, "ldapserver"))
		ldap["ldap_server"] = auth["ldapserver"]:"";
	    if ((auth["enableldaptls"]:0 == 1))
		ldap["ldap_tls"] = true;
	}	

	return [nis, ldap, security];
	
    }


    global define ks_bootloader (map ksConfig) ``{

	map bl = ksConfig["bootloader"]:$[];
	map bootloader = $[];
	if (bl["location"]:"" != "none")
	{
	    bootloader["location"] = bl["location"]:"";
	}
	else
	{
	    bootloader["write_bootloader"] = false;
	}
	
	bootloader["kernel_parameters"] = bl["append"]:"";
	if (haskey(bl, "linear") || haskey(bl, "nolinear") )
	{
	    bootloader["linear"] = (bl["linear"]:0 == 1 || !bl["nolinear"]:0 == 1);
	}
	bootloader["lba_support"] = (bl["lba32"]:0 == 1);
	return bootloader;				     
    }

    global define ks_software (map ksConfig)
	``{

	map software = $[];
	list all = ksConfig["packages"]:[];
	list selections = filter(`s, all, ``(issubstring(s, "@")));
	list packages = filter(`s, all, ``(!issubstring(s, "@")));
	list nopackages =  filter(`s, all, ``(regexpmatch( s, "^-.*" )));
	software["base"] = "Minimal";
	software["packages"] = packages;
	software["nopackages"] = nopackages;

	
	return software;
    }
}
