/**
 * File:		conftree.ycp
 * Module:		Autoinstall
 * Summary:		This module handles the configuration for auto-installation
 * Authors:		Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{

    textdomain "autoinst";
    import "HTML";
    import "XML";
    import "Call";
    import "Label";
    import "Popup";
    import "Wizard";
    import "Report";
    import "AutoinstConfig";
    import "Profile";
    import "Mode";
    import "Stage";
    import "AutoinstSoftware";

    /* Stores the item list for popuplating the group selection box */
    list<term> Groups = [];
    map<string,string> cachedSummaries = $[];

    any SaveAs() {
        any filename = UI::AskForSaveFileName(AutoinstConfig::Repository,  "*", _("Save as..."));
        if ( filename != nil && (string)filename!="")
        {
            AutoinstConfig::currentFile = (string)filename;
            if ( Profile::Save( AutoinstConfig::currentFile ))
            {
                Popup::Message(sformat(_("File %1 was saved successfully."), AutoinstConfig::currentFile));
//                Profile::checkProfile();
                Profile::changed=false;
                list pathComponents = splitstring(  (string)filename, "/");
                integer s = size(pathComponents) - 1;
                string base = pathComponents[s]:"default";
            }
            else
            {
                Popup::Warning(_("An error occured while saving the file."));
            }
        }
        return `next;
    }



    /**
     * Create a list to be used with the table widget
     * @param current String defining the currently selected item/group
     * @return term The selection box widget.
     */
    define term CreateSelectionBox( string current ){
      /* select the item identified by 'current' */
      list<term> groups = maplist( term i, Groups, {
	list args = argsof( i );
	term id = args[0]:`Empty();
	string title = args[1]:"";
	if( id == `id( current ) ){
	  return `item( id, title, true );
	}
	else{
	  return i;
	}
      });
      term selectionBox = `SelectionBox( `id(`wizardTree), `opt(`notify), "", groups );
      return selectionBox;
    }

    /*
     * Wrapper functions for replacing tree wizard by a selection box.
     */
    define void SelectTreeItem( string item ){
      y2milestone( "Selecting %1", `id(item) );
      UI::ChangeWidget( `id(`wizardTree), `CurrentItem, `id(item) );
    }

    define string QueryTreeItem(){
      return (string) UI::QueryWidget( `id(`wizardTree), `CurrentItem );
    }

    define void SetContents(  string title,  term contents,
			      string help_text, boolean has_back,
			      boolean has_next ){
	string current = "System";
	/* remember selected group */
	if( UI::WidgetExists( `id(`wizardTree) )){
	  current = (string) UI::QueryWidget(`id(`wizardTree),`CurrentItem);
	}
	/* add selection box */
	contents = `HBox( `HWeight(25, CreateSelectionBox(current) ),
			  `HWeight(75, contents ));
	Wizard::SetContents( title, contents, help_text, has_back, has_next);
    }

    /**
     * Reset Configuration
     * @param resource Resource
     * @return any
     */
    any resetModule(string resource)
    {
        y2debug("resource: %1", resource);
        map resourceMap = Y2ModuleConfig::ModuleMap[resource]:$[];
	string module_auto = resourceMap["X-SuSE-YaST-AutoInstClient"]:"none";
        if( haskey( Profile::current, resource ) ) {
            Profile::current = remove( Profile::current, resource );
        }
        string profile_resource = Y2ModuleConfig::getResource(resource);
        WFM::CallFunction(module_auto, ["Reset"]);

        return `next;
    }

    /**
      * Configure module
      */
    any configureModule(string resource)
    {
        map resourceMap = Y2ModuleConfig::ModuleMap[resource]:$[];
        resource = Y2ModuleConfig::getResource(resource);
        y2debug("resource: %1", resource);

	string module_auto = resourceMap["X-SuSE-YaST-AutoInstClient"]:"none";
        y2debug("module_auto: %1", module_auto );

	any original_settings = WFM::CallFunction(module_auto, ["Export"]);
        any seq = WFM::CallFunction(module_auto, ["Change"]);
        y2debug("Change response: %1", seq);
        if (seq == `accept || seq == `next || seq == `finish)
        {
	    any new_settings = WFM::CallFunction(module_auto, ["Export"]);
            if (new_settings == nil)
            {
                Popup::Error(_("The module returned invalid data."));
                WFM::CallFunction(module_auto, ["Import", original_settings]);
                return `abort;
            } else {
                y2debug("original=%1", original_settings);
                y2debug("new=%1", new_settings);
                if (original_settings!=new_settings )
                {
                    WFM::CallFunction(module_auto, ["SetModified"]);
                    Profile::changed = true;
                    Profile::prepare = true;
                }
            }
        } else {
            WFM::CallFunction(module_auto, ["Import", original_settings]);
        }
        return (seq);
    }


    /**
     * @return menu term
     */
    define void  menus () 
    {
        list<map> Menu = [];
        Menu = Wizard::AddMenu( Menu ,  _("&File"),        "file-menu" );
        Menu = Wizard::AddMenu( Menu ,  _("&View"),        "view-menu" );
        Menu = Wizard::AddMenu( Menu ,  _("&Classes"),        "class-menu" );
        Menu = Wizard::AddMenu( Menu ,  _("&Tools"),        "tools-menu" );

        Menu = Wizard::AddMenuEntry     ( Menu ,  "file-menu", _("&New"),
                    "menu_new"      );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "file-menu", _("&Open"),
                    "menu_open"      );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "file-menu", _("&Save"),
                    "menu_save"      );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "file-menu", _("Save &As"),
                    "menu_saveas"      );
        Menu = Wizard::AddSubMenu       ( Menu ,  "file-menu", _("Im&port"),
                    "file-import"   );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "file-import", _("Import &Kickstart File"),
                    "menu_kickstart"      );
        Menu = Wizard::AddMenuEntry     ( Menu , "file-menu" , _("Settin&gs"),
                "menu_settings" );
        Menu = Wizard::AddMenuEntry     ( Menu , "file-menu" , AutoinstConfig::ProfileEncrypted ? _("change to decrypted"):_("change to encrypted"),
                "change_encryption" );
         Menu = Wizard::AddMenuEntry     ( Menu , "file-menu" , _("Apply Profile to this System"),
                "write_to_system");
        Menu = Wizard::AddMenuEntry     ( Menu ,  "file-menu", _("E&xit"),
                    "menu_exit"      );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "view-menu", _("Configu&ration Tree"),
                    "menu_tree"      );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "view-menu", _("So&urce"),
                    "menu_source"     );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "class-menu", _("Cla&sses"),
                    "menu_classes"      );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "class-menu", _("Me&rge Classes"),
                    "menu_merge"      );

        Menu = Wizard::AddMenuEntry     ( Menu ,  "tools-menu", _("Create Reference Pro&file"),
                    "menu_clone"      );
        Menu = Wizard::AddMenuEntry     ( Menu ,  "tools-menu", _("Check &Validity of Profile"),
                    "menu_valid"      );
        Wizard::CreateMenu(Menu);
        return;
    }

    /**
     * Get Group name
     */
    string groupName (string tree_item) {
        list<string> tok = splitstring(tree_item, "@");
        string type = tok[0]:"";
        if (type == "group")
            return tok[1]:"";
        else
            return "";
    }

    /**
     * Get module name
     */
    string moduleName (string tree_item) {
        list<string> tok = splitstring(tree_item, "@");
        string type = tok[0]:"";
        if (type == "module")
            return tok[1]:"";
        else
            return "";
    }

    /**
     * Return HTML list of available modules with summaries
     *
     * @param string group_name - group to display
     * @param string module_name  - module to refresh. use:
     *		      o "ALL" to refresh all
     *		      o	"" or a non-existant module name to refresh non (use cache for all)
     *		      o "<module nam> refresh that module
     *
     * @return term VBox widget containing:
     *		      o	richtext window with modules listed and linked
     *		      o three ComboBoxes for configuring, writing and resetting modules
     */
    term modules (string group_name, string module_name) {
	y2milestone( "group_name: %1", group_name );
        string html = "";
	list<term> moduleItems = [];
	list<term> writeNowModules = [];
	boolean useCache = true;
	boolean feedBackVisible = false;
	if( module_name == "ALL" ){
	  useCache = false;
	}

        foreach(string k , map v, Y2ModuleConfig::ModuleMap, ``{
	      if (v["X-SuSE-YaST-Group"]:"" == group_name)
	      {
		string typedModulename = "module@"  + k;
                string colored = HTML::Colorize( HTML::Link(v["Name"]:"", typedModulename), "#8BC460");
		term i = `item( `id(typedModulename), v["Name"]:"", false );
		moduleItems = add( moduleItems, i );
		if( !contains( AutoinstConfig::noWriteNow, k ) ){
		  writeNowModules = add( writeNowModules, i );
		}
                html = html + "<li>" +HTML::Heading(colored);
		string summary = cachedSummaries[k]:"";
		if( useCache == true && module_name != k && summary != "" ){
		  y2debug("Using cached summary for %1", k );
		}
		else{
		  map resourceMap = Y2ModuleConfig::ModuleMap[k]:$[];
		  if( resourceMap != $[] ){
		    y2debug("Refreshing summary for %1", k );
		    if( ! feedBackVisible ){
		      Popup::ShowFeedback(_("Refreshing summary"),
			    _("Please wait while summary information is gathered.") );
		      feedBackVisible = true;
		    }
		    summary =  (string) WFM::CallFunction( resourceMap["X-SuSE-YaST-AutoInstClient"]:"none",
							    ["Summary"]);
		    if( nil == summary ){
		      summary = "";
		    }
		    cachedSummaries[k] = summary;
		  }
		  else{
		    summary = HTML::Para(v["GenericName"]:"");
		  }
		}
		// add <UL> only if it's not already there
		string summary_start = substring(summary,0,3);
		if(summary_start != "<UL" && summary_start != "<ul"){
		  summary = HTML::ListStart() + summary + HTML::ListEnd();
		}
		//y2milestone("Summary for %1: %2", k, summary);
		html = html + summary;
	      }
	});
        if (html == "")
        {
            html = HTML::Heading(_("No modules available in this group."));
        }
	term resetBox = `ComboBox( `id(`reset), `opt(`notify), "",
			merge( [ `item(`id(`none), _("Reset..."), true) ], moduleItems ));

	term writeBox = `ComboBox( `id(`writeNow), `opt(`notify), "",
			merge( [ `item(`id(`none), _("Write to system..."), true) ], writeNowModules ));

	term configureBox = `ComboBox( `id(`configure), `opt(`notify), "",
			merge( [ `item(`id(`none), _("Configure..."), true) ], moduleItems ));
        term contents =
	    `VBox(
		  `RichText( html ),
		  `HBox(
			configureBox,
			writeBox,
			`HStretch(),
			resetBox
			)
		  );
	if(feedBackVisible){
	  Popup::ClearFeedback();
	}
        return contents;
    }

    /**
     * Create the complete dialog (called in wizard.ycp)
     * @param current Module to select.
     * @return void
     */
    define void CreateDialog(string current ) ``{

	Groups = maplist( map e, Y2ModuleConfig::MenuTreeData, {
	  string title=   e["title"]:"" ;
	  string entry = "group@" + e["entry"]:"";
	  return `item(`id(entry), title );
	});
	SetContents(_("Available modules"),
                   modules( current, "ALL" ), AutoinstConfig::MainHelp(), true , true);
	Wizard::HideNextButton();
	Wizard::HideBackButton();
	Wizard::HideAbortButton();

	return;
    }




    /**
     * Show Source
     */
    void ShowSource() {
        Profile::Prepare();
        string source = XML::YCPToXMLString(`profile, Profile::current);
        term sourceView =
            `RichText( `id(`class_source ),
                    `opt(`plainText),
                    source
                    );

        Wizard::SetTitleIcon("autoyast");
        SetContents(_("Source"),
                sourceView , AutoinstConfig::MainHelp(), true , true);
        return;
    }

    /**
     * Menu interface
     * @param list menu items
     * @return symbol
     */
    any MainDialog()
	``{

        map Icons = $[];
        Icons["Net_advanced"] = "network_advanced";

        string tree_item ="group@System";
        term contents = modules(groupName(tree_item), moduleName(tree_item));
        SelectTreeItem( tree_item );
	SetContents(_("Available modules"),
	    contents, AutoinstConfig::MainHelp(), true , true);
        Wizard::SetTitleIcon("system");

	any func_ret = "";
        any ret = nil;

        while(true)
        {
            if( AutoinstConfig::runModule != "" ) {
                ret = `configure;
                SelectTreeItem( "module@"+AutoinstConfig::runModule );
                AutoinstConfig::runModule = "";
            } else {
                map event = UI::WaitForEvent();
                ret = event["ID"]:nil;
                AutoinstConfig::runModule = "";
            }
            if (ret == `wizardTree)
            {
                ret = UI::QueryWidget(`id(`wizardTree), `CurrentItem);
            }
            y2debug("INPUT: %1", ret);
            if (ret == `cancel)
                ret = "menu_exit";

            if (ret == `configure)
            {
                tree_item = QueryTreeItem();
                y2milestone("tree item: %1", tree_item);
                y2debug("tree item: %1", tree_item);
                string group=groupName(tree_item);
		string module_item = (string) UI::QueryWidget(`id(`configure), `Value);
		string modulename = moduleName(module_item);
                y2debug("configure module: %1", modulename);
                if (modulename!="")
                {
                    any configret = configureModule(modulename);
                    y2debug("configureModule ret : %1", configret);
		    SetContents(_("Available modules"),
				modules(group, modulename), AutoinstConfig::MainHelp(), true , true);
		    UI::ChangeWidget( `id(`configure), `Value, `none );
                }
            }
            else if (ret == `reset)
            {
                Profile::prepare = true;
                y2debug("reset");
                tree_item = QueryTreeItem();
                string group=groupName(tree_item);
		string module_item = (string) UI::QueryWidget(`id(`reset), `Value);
                string modulename=moduleName(module_item);
                y2debug("configure module");
                if (modulename!="")
                {
                    any configret = resetModule(modulename);
                    y2debug("configureModule ret : %1", configret);
		    SetContents(_("Available modules"),
				modules(group, modulename), AutoinstConfig::MainHelp(), true , true);
		    UI::ChangeWidget( `id(`reset), `Value, `none );
                }
            }
            else if ( ret == `writeNow )
            {
                string modulename=moduleName((string) UI::QueryWidget(`id(`writeNow), `Value) );
                if (modulename!="") {
                    map d = Y2ModuleConfig::ModuleMap[modulename]:$[];
                    string module_auto = "";
                    if (haskey(d,"X-SuSE-YaST-AutoInstClient"))
                        module_auto = d["X-SuSE-YaST-AutoInstClient"]:"none";
                    else
                        module_auto = sformat("%1_auto", modulename);
                    if( Popup::YesNo( sformat( "Do you really want to apply the settings of the module '%1' to your current system?", modulename ) ))
                        Call::Function(module_auto, ["Write"]);
                }
		UI::ChangeWidget( `id(`writeNow), `Value, `none );
            }
            else if ( issubstring((string)ret,"module@") || issubstring((string)ret,"group@") )
            {
                tree_item = (string)ret;
                y2debug("tree_item: %1", tree_item );
                SelectTreeItem( tree_item );

                string group=groupName(tree_item);
                string modulename=moduleName(tree_item);

                contents = `Empty();

                if (group!="" )
                {
                    contents = modules(group, modulename);
                    string currentFile = AutoinstConfig::currentFile;
                    string label = _("Available modules");
                    if( size(currentFile) > 0 ) {
                        currentFile = substring( currentFile, findlastof(currentFile,"/")+1 );
                        label = label + " - " + currentFile;
                    }
                    SetContents(label,
                        contents, AutoinstConfig::MainHelp(), true , true);
                    Wizard::SetTitleIcon(Icons[group]:tolower(group));
                }
                else if (modulename!="")
                {
		    string group = groupName(QueryTreeItem());
		    any configret = configureModule(modulename);
		    y2debug("configureModule ret : %1", configret);
		    SetContents(_("Available modules"),
				modules(group, modulename), AutoinstConfig::MainHelp(), true , true);
                }
            }
            else if (ret == "menu_tree") // source -> tree
            {
                y2debug("change to tree");
                tree_item = QueryTreeItem();
                if (tree_item == "")
                    tree_item = "group@System";
                y2debug("tree_item: %1", tree_item );
                string group=groupName(tree_item);
                string modulename=moduleName(tree_item);

                contents = `Empty();

                if (group!="" )
                {
                    contents = modules(group, modulename);
                    SetContents(_("Available modules"),
                        contents, AutoinstConfig::MainHelp(), true , true);
                    Wizard::SetTitleIcon(Icons["group"]:tolower(group));
                }
            }
            else if (ret == "menu_open") // OPEN
            {
                any filename = UI::AskForExistingFile( AutoinstConfig::Repository,
                        "*",
                        _("Select a file to load."));
                if (filename != "" && filename != nil)
                {
                    AutoinstConfig::currentFile = (string)filename;

                    list pathComponents = splitstring(  (string)filename, "/");

                    integer s = size(pathComponents) -1;
                    string base = pathComponents[s]:"default";
                    boolean readOkay = Profile::ReadXML((string)filename);
                    y2debug("Profile::ReadXML returned %1",readOkay);
                    if( readOkay ) {
                        Popup::ShowFeedback(_("Reading configuration data"), _("This may take a while"));
                        foreach(string p, map d, Profile::ModuleMap, ``{
                                /* Set resource name, if not using default value */
                                string resource = d["X-SuSE-YaST-AutoInstResource"]:"";
                                if (resource == "")
                                {
                                    resource = p;
                                }
                                y2debug("resource: %1", resource );
                                string tomerge = d["X-SuSE-YaST-AutoInstMerge"]:"";
                                string module_auto =d["X-SuSE-YaST-AutoInstClient"]:"none";
                                any rd = Y2ModuleConfig::getResourceData(d
                                    ,resource);
                                if (rd!=nil) {
                                WFM::CallFunction(module_auto, ["Import",
                                    rd]);
                                }
                                });
                        Popup::ClearFeedback();
                        Wizard::DeleteMenus(); // FIXME: sucks sucks sucks sucks sucks
                        menus();
                    } else {
                        /* opening/parsing the xml file failed */
                        Popup::Error(_("An error occured while opening/parsing the XML file."));
                        Profile::Reset();
                    }

                }
                if (UI::WidgetExists(`id(`class_source)))
                {
                    ShowSource();
                }
                else
                {
                    tree_item = QueryTreeItem();
                    string group=groupName(tree_item);
                    string modulename=moduleName(tree_item);

                    contents = `Empty();

                    if (group!="" )
                    {
                        contents = modules(group, modulename);
                        string caption = _("Available modules");
                        string currentFile = AutoinstConfig::currentFile;
                        currentFile = substring( currentFile, findlastof(currentFile,"/")+1 );
                        if( size(currentFile) > 0 ) {
                            caption = caption + " - " + currentFile;
                        }
                        SetContents(caption,
                                contents, AutoinstConfig::MainHelp(), true , true);
                        Wizard::SetTitleIcon(Icons[group]:tolower(group));
                    }
                }
                ret = `menu_open;
            }
            else if (ret == "menu_source") // Show SOURCE
            {
                ShowSource();
                tree_item = "System";
                ret = `menu_source;
            }
            else if (ret == "menu_save") // SAVE
            {
                if (AutoinstConfig::currentFile == "")
                {
                    any filename = UI::AskForSaveFileName(AutoinstConfig::Repository,  "*", _("Save as..."));
                    if (filename !=  nil )
                    {
                        AutoinstConfig::currentFile = (string)filename;
                    }
                    else
                    {
                        continue;
                    }
                }

                if ( Profile::Save( AutoinstConfig::currentFile ))
                {
                    Popup::Message(sformat(_("File %1 was saved successfully."), AutoinstConfig::currentFile));
                    //Profile::checkProfile();
                    Profile::changed = false;
                }
                else
                {
                    Popup::Warning(_("An error occured while saving the file."));
                }
                ret = `menu_save;
            }
            else if (ret == "menu_saveas") // SAVE AS
            {
                SaveAs();
                ret = `menu_saveas;
            }
            else if (ret == "menu_new") // NEW
            {
                Profile::Reset();
                foreach(string p, map d, Profile::ModuleMap, {
                    string resource = d["X-SuSE-YaST-AutoInstResource"]:"";
                    if (resource == "")
                        resource = p;
                    resetModule(resource);
                });
                AutoinstConfig::currentFile = "";
                if (UI::WidgetExists(`id(`class_source))) {
                    ShowSource();
                }
                tree_item = QueryTreeItem();
                string group=groupName(tree_item);
		SetContents(_("Available Modules"),
                                modules(group, ""), AutoinstConfig::MainHelp(), true , true);
                ret = `menu_new;
            }
            else if (ret == "change_encryption" ) {
                AutoinstConfig::ProfileEncrypted = !AutoinstConfig::ProfileEncrypted;
                AutoinstConfig::ProfilePassword = "";
                Wizard::DeleteMenus(); // FIXME: sucks sucks sucks sucks sucks
                menus();
            }
            else if ( ret == "write_to_system" ) {
                if( Popup::YesNo( "Do you really want to apply the settings of the profile to your current system?" )) {
                    Profile::Prepare();
                    string oldMode = Mode::mode();
                    string oldStage = Stage::stage();
                    Mode::SetMode("autoinstallation");
                    Stage::Set ("continue");
                    WFM::CallFunction("inst_autopost", []);
                    AutoinstSoftware::addPostPackages(Profile::current["software","post-packages"]:[]);

                    // the following is needed since 10.3
                    // otherwise the already configured network gets removed
                    if( !haskey(Profile::current, "networking") ) {
                        Profile::current = add( Profile::current, "networking", $[ "keep_install_network":true ] );
                    }

                    Pkg::TargetInit ("/", false);
                    WFM::CallFunction("inst_rpmcopy", []);
                    WFM::CallFunction("inst_autoconfigure", []);
                    Mode::SetMode(oldMode);
                    Stage::Set(oldStage);
                }
            }
            else if (ret == "menu_exit") // EXIT
            {
                ret = `menu_exit;
                if (Profile::changed)
                {
                    string current = "";
                    if (AutoinstConfig::currentFile == "")
                    {
                        current = "Untitled";
                    }
                    else
                    {
                        current = AutoinstConfig::currentFile;
                    }

                    symbol answer = Popup::AnyQuestion3(_("Control file changed."),
                            sformat(_("Save the changes to %1?"), current),
                            Label::YesButton(),
                            Label::NoButton(),
                            Label::CancelButton(),
                            `focus_yes
                            );
                    if (answer == `no)
                    {
                        break;
                    }
                    else if (answer == `yes)
                    {
                        SaveAs();
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
                else
                {
                    break;
                }
            }
            else
            {
                term s = toterm(ret);
                ret = (symbol)symbolof(s);
                break;
            }
        }
	return (symbol)ret;

    }
}
