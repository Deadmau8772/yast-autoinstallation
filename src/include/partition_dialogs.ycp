/**
 * File:
 *	partition_dialogs.ycp
 *
 * Module:
 *	Partitioning
 *
 * Summary:
 *	Handle Partitioning  data
 *
 * Authors:
 *	Anas Nashif <nashif@suse.de>
 *
 * $Id$
 */
{
    textdomain "autoinst";
    import "Label";
    import "Popup";
    include "partitioning/custom_part_helptexts.ycp";
    include "partitioning/custom_part_lib.ycp";
    include "partitioning/custom_part_dialogs.ycp";
    include "partitioning/partition_defines.ycp";

    /*
     * Partition Dialog
     *
     * @param mode mode of operation
     * @param item item to edit
     * @return symbol
     */
    global define PartitionDialog (symbol mode, string item)
	``{
	list partitioning =  AutoinstStorage::drives;
	list item_id = splitstring(item,":");
	map this_drive = $[];
	string drive = "";
	map new_val = $[];

	if (size(item_id)>1)
	{ //Partition
	    this_drive =
		select(filter(map d,
			      partitioning,
			      ``(lookup(d,"device","") == select(item_id,0,""))),
		       0,
		       $[]
		       );
	    new_val = select(this_drive["partitions"]:[], tointeger(select(item_id,1,"")) - 1, $[]);
	    drive = select(item_id,0,"");
	}
	else
	{
	    this_drive = select(filter(map d, partitioning,``(lookup(d,"device","") == item)),0,$[]);
	    new_val = $[
			"crypt_fs"	: false,
			"crypt_key" : "",
			"partition_id"	: 131,
			"filesystem"	: `reiser
	    ];
	    drive = item;
	}

	new_val["fsid"] = new_val["partition_id"]:Partitions::fsid_native;
	new_val["used_fs"] = new_val["filesystem"]:`reiser;

	
	list other_drives = filter(`d,partitioning,``(lookup(d,"device","") != drive));
	
	map file_systems 	= FileSystems::GetAllFileSystems(true, true);
	boolean create		= lookup ( new_val , "create", false);
	string  partition_size	= lookup ( new_val , "size", "");
	boolean format		= lookup ( new_val , "format", false);
	
	string partition_type	= new_val["partition_type"]:"";
	
	symbol last_option_fs	= lookup ( new_val , "filesystem", `ext2);
	map fs_options      = lookup ( new_val , "fs_options" , $[]);

	list not_used_mountpoints = notUsedMountpoints( getTargets(),  lookup( lookup( file_systems, last_option_fs, $[]), `mountpoints, []));


	string helptext = _("
<P>Enter the partition information according to your
needs. All fields are required.</P>
<P>For more information, refer to the online documentation.
</P>
");
	string title = "";
	if (mode == `create )
	    title = _("Create New Partition");
	else
	    title = _("Edit Partition");

	term field_dlg_right =
	    `VBox(
		  `Top(
		       `VBox(
			     `TextEntry(`id(`partsize), _("&Size"), (partition_size!="auto" && partition_size!="max") ? partition_size : "" ),
			     `RadioButtonGroup(`id(`sizeopt),
					       `VBox(
						     `Left(
							   `RadioButton(`id(`fixed),
									`opt(`notify),
									_("&Fixed Size"),
									(partition_size != "auto"
									 && partition_size != "max") 
									)
							   ),
						     `Left(
							   `RadioButton(`id(`max),
									`opt(`notify),
									_("Fill to &maximum allowable space"),
									( partition_size == "max")
									)
							   ),
						     `Left(
							   `RadioButton(`id(`auto),
									`opt(`notify),
									_("Determine &automatically (only /boot and swap)"),
									( partition_size == "auto")
									)
							   )
						     )
					       ),
			     `VSpacing(0.5),
			     `Left(
				   `CheckBox(`id(`asprimary), _("Create as a Primary Partition"), ( (partition_type =="primary") ? true : false) )
				   )

			     )
		       ),
		  `VSpacing(1),
		       `ReplacePoint( `id(`mount_dlg_rp), MountDlg( new_val , not_used_mountpoints ))
		  );
	y2milestone("New values: %1", new_val);
	
	term field_dlg_left = `Top( `ReplacePoint( `id( `format_dlg_rp), FormatDlg( new_val, file_systems) ));

	UI::OpenDialog(
		       `opt(`decorated  ),
		       `HBox(
			     `HWeight(30, `RichText( helptext)),
			     `HStretch(),
			     `HSpacing(1),
			     `HWeight(70,
				      `VBox(
					    `Heading( title),
					    `VSpacing(1),
					    `VStretch(),
					    `HBox(
						  field_dlg_left,
						  `HSpacing(2),
						  field_dlg_right //,
						  //`HSpacing(2)
						  ),
					    `VSpacing(1),
					    `VStretch(),
					    `HBox(
						  // popup create partition:
						  `PushButton(`id(`ok), `opt(`default),  Wizard::Label::OKButton()   ),
						  // popup create partition:
						  `PushButton(`id(`cancel),  Wizard::Label::CancelButton() )
						  )
					    )
				      ),
			     `HSpacing(1),
			     `HStretch()
			     )
		       );

	map return_value     = new_val;

	if (partition_size == "auto")
	{
	    UI::ChangeWidget(`id(`partsize) , `Enabled, false);
	}

	any ret = nil;
	boolean pdisk = false; // TODO
	boolean pdisk_disk = false; // TODO

	list set_false = [];


	if( ! format )
	{
	    set_false = union( set_false, [ `crypt_fs, `fs, `fs_options] );
	    if( create ) set_false = union( set_false, [`mount_point ] );
	    if( pdisk_disk ) set_false = add( set_false, `fsid_point);
	}
	else
	{
	    set_false = union( set_false, [ `fsid_point]);
	}


	if ( lookup( new_val, "partition_id", 131) == 130  )
	{
	    set_false = union( set_false, [ `crypt_fs ] );

	}

	ChangeExistingSymbolsState( set_false, false);

	repeat{

	    ret = UI::UserInput();
	    if (ret != `cancel)
	    {
		if ( UI::QueryWidget(`id(`sizeopt),  `CurrentButton) == `max
		     || UI::QueryWidget(`id(`sizeopt),  `CurrentButton) == `auto)
		{
		    UI::ChangeWidget(`id(`partsize) , `Enabled, false);
		}
		else
		{
		    UI::ChangeWidget(`id(`partsize) , `Enabled, true);
		}


		if( UI::QueryWidget(`id(`format),  `CurrentButton) == `format_true )
		{
		    symbol filesystem  =  UI::QueryWidget(`id(`fs), `Value);
		    map selected_fs =  lookup( file_systems, filesystem , $[] );
		    // y2milestone("filesystems=%1, this fsystem=%2", selected_fs, filesystem );

		    return_value     = add( return_value , "format",  true );
		    return_value     = add( return_value , "filesystem", filesystem );

		    if ( !pdisk_disk )
		    {
			return_value     = add( return_value , "partition_id",  selected_fs[`fsid]:131 );
		    }

		    string mount	=  UI::QueryWidget( `id(`mount_point), `Value);
		    string subStr     	=  substring( CutBlanks(mount) , 0,1  );
		    return_value      	=  add( return_value , "mount" , mount);
		    not_used_mountpoints =  notUsedMountpoints( getTargets(), lookup(selected_fs, `mountpoints, []));

		    if( filesystem == `swap )
		    {
			not_used_mountpoints = add( not_used_mountpoints , "swap" );
			if( mount != "" && mount != "swap" )
			{
			    return_value = add (return_value , "mount" , "swap" );
			    UI::ReplaceWidget(`id(`mount_dlg_rp), MountDlg( return_value ,not_used_mountpoints));
			}
			if( mount == "" )
			{
			    UI::ReplaceWidget(`id(`mount_dlg_rp), MountDlg( return_value ,not_used_mountpoints));
			}
		    }
		    else
		    {
			if( mount == "swap" || mount == "")
			{
			    if( mount == "swap")
				return_value = add (return_value , "mount" ,GetMountPointProposal( getTargets(), [] ) );

			    UI::ReplaceWidget(`id(`mount_dlg_rp), MountDlg( return_value, not_used_mountpoints ));
			}
		    }


		    ChangeExistingSymbolsState( [ `mount_point, `fs ], true);
		    UI::ChangeWidget(`id(`fsid_point) , `Value  , lookup( selected_fs , `fsid_item, ""));
		    UI::ChangeWidget(`id(`fsid_point) , `Enabled, false);
		    UI::ChangeWidget(`id(`fs_options) , `Enabled, (lookup( selected_fs, `options, []) != [] ));
		    if( lookup( selected_fs, `crypt, false))
		    {
			UI::ChangeWidget(`id(`crypt_fs) , `Enabled, true);
		    }
		    else
		    {
			UI::ChangeWidget(`id(`crypt_fs) , `Enabled, false);
			UI::ChangeWidget(`id(`crypt_fs),  `Value,   false );
		    }

		    if( filesystem != last_option_fs )
		    {
			fs_options = $[];
		    }
		    last_option_fs = filesystem;
		    
		    if( ret == `fs_options )
		    {
			fs_options =  FileSystemOptions( fs_options, selected_fs );
		    }
		    else if( ret == `fstab_options )
		    {
			map new = $[];
			FstabOptions( new, return_value);
			y2milestone("fstab %1", return_value);
		    }

		}
		else
		{
		    map fs_options     = $[];
		    list set_true  = [ `fsid_point ];

		    if(pdisk_disk ) set_true = [];

		    list set_false = [ `crypt_fs, `fs, `fs_options];
		    // list set_false = [ `crypt_fs, `fs];

		    if( create )  set_false = add( set_false, `mount_point );
		    else          set_true  = add( set_true , `mount_point );

		    ChangeExistingSymbolsState( set_true  ,true );
		    ChangeExistingSymbolsState( set_false ,false );

		    UI::ChangeWidget(`id(`crypt_fs),    `Value,   false );

		    return_value     = filter(`k, `v , return_value , ``( k != "filesystem" && k != "fs_options"));
		    string fs_string = UI::QueryWidget(`id(`fsid_point ) , `Value);
		    fs_string        = substring( fs_string, 0, 4  );
		    integer fs_int   = tointeger( fs_string        );

		    if( fs_int >= 0 && fs_int <= 255 )
		    {
			return_value = add( return_value, "format",  false );
			return_value = add( return_value, "partition_id", fs_int   );
			return_value = add( return_value, "crypt_fs", false);
			return_value = add( return_value, "crypt_key", "");
			if( create )
			{
			    return_value = add( return_value, "filesystem", `unknown);
			}
		    }
		    else
		    {
			Report::Warning(_("The partition ID must be between 0x00 and 0xff."));
			UI::SetFocus(`id(`fsid_point));
			continue;
		    }
		}
	    }

	    if ( ret == `ok )
	    {

		if (UI::QueryWidget(`id(`sizeopt),  `CurrentButton) == `max )
		{
		    return_value= add(return_value,"size","max");
		}
		else if (UI::QueryWidget(`id(`sizeopt),  `CurrentButton) == `auto )
		{
		    return_value = add (return_value,"size","auto");
		}
		else
		{
		    string partitionSize =  UI::QueryWidget(`id(`partsize),   `Value);
		    if (  partitionSize == "") {
			Report::Warning(_("Enter the partition size."));
			continue;
		    }
		    else
		    {
			return_value=add(return_value,"size", partitionSize);
		    }
		}
		if (UI::QueryWidget(`id(`asprimary),  `Value))
		{
		    return_value= add(return_value, "partition_type" ,"primary");
		}

		// save mountpoint
		if ( create && (! lookup( return_value, "format" , true )))
		{
		    change( return_value, "mount", "");
		}
		else
		{
		    change( return_value, "mount",  CutBlanks( UI::QueryWidget(`id(`mount_point),   `Value)));
		}

		// add fstype to return_value

		if ( !pdisk_disk )
		{
		    integer fs_id =  lookup( return_value, "partition_id", 0 );
		    if (haskey(return_value, "fsid"))
			return_value=remove(return_value,"fsid");
		}


		if( !check_crypt_fs_mount_points(lookup(return_value, "mount", ""),
						     UI::QueryWidget(`id(`crypt_fs), `Value ) ))
		{
		    UI::SetFocus(`id(`mount_point));
		    continue;
		}

		// crypto settings
		boolean crypt_fs = UI::QueryWidget(`id(`crypt_fs), `Value );
		return_value = add( return_value, "crypt_fs",   crypt_fs );

		if ( crypt_fs )
		{
		    string fs_passwd = DlgCreateCryptFs();
		    // Ask the user for a password for cryptofs, else set crypto to nil??
		    if ( fs_passwd != nil )
		    {
			return_value = add( return_value, "crypt_key",  fs_passwd);
		    }
		    else
		    {
			ret = `retry;
			UI::ChangeWidget(`id(`crypt_fs), `Value, false);
		    }
		}
		if( fs_options != $[] && lookup( return_value, "format" ,false))
		{
		    return_value = add( return_value, "fs_options", fs_options);
		}
		else
		{
		    return_value = filter(`key, `value, return_value, ``( key != "fs_options"));
		}


	    }

	} until (ret == `ok || ret == `cancel);
	
	UI::CloseDialog();
	
	if ( ret != `cancel )
	{
	    list partitions = lookup(this_drive,"partitions",[]);
	    if (mode == `create)
	    {
		partitions=add(partitions,return_value);
	    }
	    else if (mode == `edit)
	    {
		partitions[tointeger(select(item_id,1,"")) - 1] = return_value;
	    }
	    change(this_drive,"partitions",partitions);
	    AutoinstStorage::drives=add(other_drives,this_drive);
	}
	return ret;
    }



    /*
     * Create Drive dialog
     * @param mode mode of operation
     * @param item item to edit
     * @return symbol
     */
    global define DriveDialog(symbol mode, string item)
	``{

	list devices = ["/dev/hda", "/dev/hdb", "/dev/hdc", "/dev/sda","/dev/sdb"];
	if (issubstring(item, "dev")) {
	    devices=add(devices, item);
	}

	list drives = AutoinstStorage::drives;
	list configured_drives = maplist(`c, drives, ``{
	    return(lookup(c,"device","***"));
	});

	if (item == nil || item == "") {
	    item = "none";
	}
	map current_drive = select(filter(`d, drives,``(d["device"]:"" == item)), 0, $[]);
	boolean usefree = (current_drive["use"]:"" == "free");
	boolean init = current_drive["initialize"]:false;
	
	boolean reuse_all = (current_drive["use"]:"" == "all");
	list partitions = splitstring(current_drive["use"]:"", ",");

	if (filterchars(partitions[0]:"", "1234567890") != partitions[0]:"")
	    partitions = [];

	map drive = $[];
	if (!(usefree || reuse_all || size(partitions)>0)) {
	    reuse_all = true;
	}

	string help = _("
<P>
Specify the drive name to configure
and how the partitioning should be performed.
</P>
<P>
For more information, consult the documentation.
</P>
");
	string title = _("Configure Drives");
	term contents =
	    `Top(
		 `VBox(
		       `Left(
			     `ComboBox(`id(`target),
				       `opt(`editable),
				       _("&Drive"),
				       maplist(`dd, toset(devices), ``{
					   return(`item(`id(dd), dd, ((dd == item) ? true : false)));
				       })
				       )
			     ),
		       `VSpacing(1),
		       `RadioButtonGroup( `id(`bgroup2),
					  `VBox(
						`Left(`RadioButton(`id(`usefree),`opt(`notify),
								   _("Use available &free space only"),
								   usefree
								   )
						      ),
						`Left(`RadioButton(`id(`reuseall), `opt(`notify),
								   _("&Reuse all existing partitions"),
								   reuse_all
								   )
						      ),
						`Left(`RadioButton(`id(`reuselisted),`opt(`notify),
								   _("&Use the following (comma separated) partitions"),
								   (size(partitions)>0)
								   )
						      )
						)
					  ),
		       
		       `HBox(
			     `HSpacing(1),
			     `Left(
				   `TextEntry(
					      `id(`reuse_partitions),
					      _("&Partition Numbers (i.e.,  3,4,5)"),
					      mergestring(partitions, ",")
					      )
				   )
			     ),
		       `VSpacing(1),
		       `Left(`CheckBox(`id(`init), _("Initialize hard dri&ve"), init))
		       )
		 );


	Wizard::CreateDialog();
	string help_text = _("Help");
	Wizard::SetContents( title, contents, help, true , true );
	Wizard::ReplaceAbortButton(`Empty());

	
	if (size(partitions)>0)
	{
	    UI::ChangeWidget(`id(`reuse_partitions), `Enabled, true);
	}
	else
	{
	    UI::ChangeWidget(`id(`reuse_partitions), `Enabled, false);
	}

	any ret = nil;
	repeat {
	    ret = UI::UserInput();

	    if ( UI::QueryWidget(`id(`bgroup2), `CurrentButton) != `reuselisted)
		UI::ChangeWidget(`id(`reuse_partitions), `Enabled, false);
	    else
		UI::ChangeWidget(`id(`reuse_partitions), `Enabled, true);

	    if (ret == `next)
	    {
		string device = UI::QueryWidget(`id(`target),`Value);
		symbol driveopts = UI::QueryWidget(`id(`bgroup2), `CurrentButton);
		string usewhat = "";
		if (mode == `create)
		{
		    if (!contains(configured_drives,device)) {
			drive=add(drive, "device",device);

			if (driveopts == `reuseall)
			    usewhat = "all";
			else if (driveopts == `reuselisted)
			    usewhat = UI::QueryWidget(`id(`reuse_partitions), `Value);
			else if (driveopts == `usefree)
			    usewhat = "free";
			else if (driveopts == `uselinux)
			    usewhat = "linux";

			if (usewhat !="")
			    drive["use"] = usewhat;

			if (UI::QueryWidget(`id(`init), `Value))
			     drive["initialize"] = true;
			else
			    drive["initialize"] = false;

			
			drives=add(drives,drive);
			AutoinstStorage::drives=drives;
		    }
		    else
		    {
			Popup::Message(_("This device is already configured.
Select or enter another device name.
"));
			continue;
		    }

		} else {
		    //remove current drive from list
		    drives=filter(`d, drives,``(d["device"]:"" != item));

		    if (driveopts == `reuseall)
			usewhat = "all";
		    else if (driveopts == `reuselisted)
			usewhat = UI::QueryWidget(`id(`reuse_partitions), `Value);
		    else if (driveopts == `usefree)
			usewhat = "free";
		    else if (driveopts == `uselinux)
			usewhat = "linux";

		    if (usewhat !="")
			current_drive["use"] = usewhat;

		    current_drive["device"] = device;
		    drives=add(drives,current_drive);
		    AutoinstStorage::drives=drives;
		}
	    }
	} until (ret == `next || ret ==`abort || ret == `back);
	Wizard::CloseDialog();
	return ret;


    }


    /**
     * get target
     * @return targets
     */
    global define getTargets ()
	``{
	map auto_targets =  listmap (`d, AutoinstStorage::drives, ``{
	    string device = lookup(d,"device","");
	    return([device,d]);
	});
	return auto_targets;
    }

    /**
     *
     * Remove blanks at begin and end of input string
     * (blanks between remain untouched).
     * @param input string, usually an user input
     *
     * @return string
     * @example CutBlanks ( "  any input     " );
     */

    global define CutBlanks( string input )
	``{
	string  output = input;
	boolean go_on = true;

	if ( size ( output ) > 0 )
	{
	    integer pos = findfirstnotof( output, " " );

	    if ( pos != nil )
	    {
		output = substring( output, pos );
	    }
	    integer last_pos = size ( output ) - 1;

	    while ( go_on )
	    {
		if ( substring( output, last_pos ) == " " )
		{
		    output = substring( output, 0, last_pos );
		    last_pos = last_pos-1;
		}
		else
		{
		    go_on = false;
		}
	    }
	}
	return output;
    };


    /**
     * Main Partitioning Dialog
     * @return symbol
     */

    global define symbol StorageDialog()
	``{

	any ret = nil;
	any action = nil;


	string help_text = "";
	
	help_text =  _("<p> Partition your hard disks... </p>");

	help_text = help_text + _("<p>
The table to the right shows the partitions to be created on the target system.
</p>
");
	help_text = help_text + _("<p><b>Hard disks</b> are designated like this </p>") +
	    _("<tt>/dev/hda </tt>1st EIDE disk
<tt>/dev/hdb </tt>2nd EIDE disk
<tt>/dev/hdc </tt>3rd EIDE disk") +
_("<p>etc.</p>")+
_("<p>- or - </p>")+
_("<p><tt>/dev/sda </tt>1st SCSI disk
<tt>/dev/sdb </tt>2nd SCSI disk
<tt>/dev/sdc </tt>3rd SCSI disk</p>");

	 help_text = help_text + _("If no partitions are defined and the specified drive is also
the drive where the root partition should reside, the following partitions are
created automatically:");
	 help_text = help_text + _(" <tt>/boot</tt>, <tt>swap</tt>, and a root partition <tt>/</tt>.
Sizes are calculated automatically.
");
	 
	 help_text = help_text + _("<p><b>Advanced Options</b></p>");
	 
	help_text = help_text + _("By default, AutoYaST2 will create an extended partition and adds all new partitions as logical devices. It is possible, however, to instruct AutoYaST2 to create a certain partition as a primary partition or as extended partition. Additionally, it is possible to specify the size of a partition using sectors rather than size in MBytes.");
	help_text = help_text + _("These options and other advanced options cannot be configured using this
interface.  Instead, add them manually to the control file.
");
	
	help_text = help_text + _("<p>
For LVM and RAID setup, consult the documentation and add the configuration
to an existing control file. You can only create unformatted LVM and RAID partitions as
a preparation.
</p>
");	      
	
	Wizard::SetContents(_("Partition Plans"),
			    StorageDialogContents() , help_text, true, true);

	Wizard::ReplaceAbortButton(`Empty());
	UI::ChangeWidget(`id(`next), `Label, Label::FinishButton());
	repeat {
	    any item = UI::QueryWidget(`id(`table), `CurrentItem);

	    if (item ==nil)
	    {
		UI::ChangeWidget(`id(`delete), `Enabled, false);
		UI::ChangeWidget(`id(`edit), `Enabled, false);

	    }
	    else
	    {
		list whatitem = splitstring(item,":");
		if (size(whatitem) >1)
		{ //Partition
		    UI::ChangeWidget(`id(`part), `Enabled, false);
		}
	    }
	    ret = UI::UserInput();

	    item = UI::QueryWidget(`id(`table), `CurrentItem);
	    list drives = AutoinstStorage::drives;
	    list configured_drives = maplist(`c, drives, ``{
		return(lookup(c,"device",""));
	    });


	    if (contains(configured_drives, item))
	    {
		UI::ChangeWidget(`id(`part), `Enabled, true);
	    }
	    else
	    {
		UI::ChangeWidget(`id(`part), `Enabled, false);
	    }
	    list whatitem = [];
	    if(item!=nil)
	    {
		whatitem = splitstring( item , ":");
	    }

	    if (ret == `table && size(whatitem) == 0)
	    {
		UI::ChangeWidget(`id(`delete), `Enabled, true);
		UI::ChangeWidget(`id(`edit), `Enabled, true);
	    }
	    else if (ret == `drive)
	    {
		action = DriveDialog(`create, "" );
	    }
	    else if  (ret == `part)
	    {
		if (item != nil) {
		    action = PartitionDialog(`create, item);
		    UI::ChangeWidget(`id(`table), `CurrentItem, item);
		}
		else
		{
		    Popup::Message(_("Select a drive first."));
		    continue;
		}
	    }
	    else if (ret == `edit)
	    {
		list item_id = splitstring(item,":");
		if (size(item_id) >1)
		{ //Partition
		    action = PartitionDialog(`edit, item);
		    UI::ChangeWidget(`id(`table), `CurrentItem, select(item_id,0,""));
		}
		else
		{
		    action = DriveDialog(`edit, item );
		}
	    }
	    else if (ret == `delete)
	    {

		list partitioning =  AutoinstStorage::drives;
		list item_id = splitstring(item,":");
		map this_drive = $[];
		string drive = "";

		if (size(item_id)>1) { //Partition
		    this_drive =
			select(filter(map d,
				      partitioning,
				      ``(lookup(d,"device","") == select(item_id,0,""))),
			       0,
			       $[]
			       );
		    drive= select(item_id,0,"");
		    list drive_partitions = this_drive["partitions"]:[];
		    drive_partitions= remove(drive_partitions, tointeger(select(item_id,1,"")) - 1);
		    change(this_drive,"partitions", drive_partitions);
		    
		    AutoinstStorage::drives= maplist(`d, partitioning,
					       ``{
						   if (d["device"]:"" == drive)
						   {
						       return(this_drive);
						   }
						   else
						   {
						       return(d);
						   }
					       });
		}
		else
		{
		    drive = item;
		    AutoinstStorage::drives = filter(`d,partitioning,``(lookup(d,"device","") != drive));
		}


	    }
	    if (ret !=`table) {
		Wizard::SetContents(_("Partition Plan"),
				    StorageDialogContents() , help_text, true, true);
	    }

	} until (ret == `next  || ret == `back );
	return ret;
    }

    global define term StorageDialogContents()
	``{
			
	list drives_table = [];
	string id = "";
	foreach(`d, AutoinstStorage::drives,
		``{
	    id =lookup(d,"device","");
	    term a = `item(`id(id));
	    a = add(a, lookup(d,"device",""));
	    a = add(a, "");
	    a = add(a, "");
	    a = add(a, "");
	    a = add(a, "");
	    a = add(a, "");
	    
	    drives_table = add(drives_table, a);
	    list part = lookup(d,"partitions",[]);
	    integer start_id = 1;
	    if (size(part)>0)
	    {
		foreach(`p, part,
			``{		    
		    id = build_id(lookup(d,"device",""), start_id );
		    term b = `item(`id(id));
		    b=add(b, "");
			   
		    b=add(b, lookup(p,"mount",""));
		    b=add(b, lookup(p,"size", ""));
		    // integer pid = tohexstring(p["partition_id"]:0) ;

		    y2milestone("p id = %1", p["partition_id"]:0 );
		    if (!haskey(p, "filesystem_id"))
		    {
			b=add(b, Partitions::FsIdToString(p["partition_id"]:131));
		    }
		    else
		    {
			b=add(b, Partitions::FsIdToString(p["filesystem_id"]:131));
		    }

		    
		    if (lookup(p,"filesystem",`nothing) == `reiser)
		    {
			b=add(b, "Reiser");
		    }
		    else if (lookup(p,"filesystem",`nothing) == `ext2)
		    {
			b=add(b, "Ext2");
		    }
		    else if (lookup(p,"filesystem",`nothing) == `ext3)
		    {
			b=add(b, "Ext3");
		    }
		    else if (lookup(p,"filesystem",`nothing) == `jfs)
		    {
			b=add(b, "JFS");
		    }
		    else if (lookup(p,"filesystem",`nothing) == `xfs)
		    {
			b=add(b, "XFS");
		    }
		    else
		    {
			b=add(b, "");
		    }

		    if (size(p["region"]:[]) > 0 )
		    {
			b=add(b, sformat("%1 - %2", select(p["region"]:[], 0 , 0), select(p["region"]:[], 1 , 0)));
		    }
		    else
		    {
			b=add(b, "");
		    }
		    
		    drives_table = add(drives_table, b);
		    start_id = start_id + 1;
		});
	    }

	});
	integer entries = size(drives_table);
	list reversed_table = [];
	integer counter = entries;
	term tmp = `item(`id(`empty));	
	while (counter != 0)
	{
	    reversed_table=add(reversed_table, select(drives_table, counter -1, tmp));
	    counter = counter - 1;
			       
	}	
	term contents =	    
	    `VBox(
		  `Table(`id(`table), `opt(`notify, `immediate, `keepSorting),
			 `header(_("Device"), _("Mount"), _("  Size  "),  _("  Type  ") ,_("  File System  "), _("Region   ")),
			 drives_table
			 ),
		  `HBox(
			`PushButton(`id(`drive), _("Add Dri&ve")),
			`PushButton(`id(`part), _("Add &Partition")),
			`PushButton(`id(`edit), _("&Edit")),
			`PushButton(`id(`delete), _("&Delete"))
			)
		  );
	return contents;
    }

   
    /**
     * Build the id for a partition entry in the man table.
     * @parm disk_dev_name name of the devie e.g.: /dev/hda
     * @parm nr number of the partition e.g.: 1
     * @return string e.g.: 01./dev/hda
     */

    global define build_id(  string disk_dev_name , any nr )
	``{       
        return (sformat( "%1:%2", disk_dev_name, nr));        
    };

    
}
