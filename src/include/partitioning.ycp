/**
 * File:		autoinstall/partitioning.ycp
 * Module:		Autoinstallation
 * Authors:             Anas Nashif <nashif@suse.de>
 * Purpose:		functions for partitioning in autoinst mode
 *
 *
 * $Id$
 */

{
    include "partitioning/auto_part_functions.ycp";
    include "partitioning/auto_part_prepare.ycp";
    include "partitioning/auto_part_create.ycp";
    include "partitioning/auto_finish.ycp";
    include "partitioning/raid_lib.ycp";
    include "partitioning/partition_defines.ycp";
    include "partitioning/auto_part_ui.ycp";
    include "partitioning/lvm_ui_lib.ycp";
    include "partitioning/lvm_ui_dialogs.ycp";
    include "partitioning/lvm_pv_lib.ycp";
    include "partitioning/lvm_lib.ycp";
  
    include "partitioning/lvm_lv_lib.ycp";
    include "partitioning/partition_defines.ycp";



    textdomain "autoinst";


    /**
     *  Determine how and where the partitions are added in autoinst mode
     *  modifies targetMap with new partition list for the specified device
     *  @param device name of the target drive
     *  @return true on success
     */
    global define boolean AutoPartition (string target_is)
	``{

	// find the selected target in the map of all possible targets
	map driveMap =  Storage::GetTargetMap();

	// description of the choosen target disk
	map target = driveMap[target_is]:$[];

	if (target == $[])
	{
	    Report::Error(_("The device configured in the control file does not
exist on this system.
"));
	    return false; //
	}

	// user visible name of target
	string targetname = target["name"]:""; // FIXME: Maybe not needed

	// The current list of partitions
	list partitions = target["partitions"]:[];

	integer max_partitions = compute_max_partitions (target);

	// The number of possible primary partitions
	integer max_primary = Partitions::MaxPrimary( target["label"]:"" );


	// The partition number of the first logical partition
	integer first_logical_nr = 5;

	list full_region = [];

	integer bytes_per_unit = 0;
	integer disk_size = 0;

	// fdisk partition ids
	integer	fsid_boot	= Partitions::FsidBoot();
	integer	fsid_root   	= Partitions::fsid_native;

	// How much to allocate for swap
	integer size_of_swap 	= 1024 * 1024 * Partitions::SwapSizeMb(0);

	// calculate size of the /boot partition
	integer size_of_boot = Partitions::MinimalNeededBootsize();

	// this will tell if automatic partitioning if feasible
	boolean can_do_auto = false;

	// this will get the minimal size for a default system
	//   (boot + swap + default root)
	integer minimal_size = 0;

	list unused_region = [ 0, 0 ];

	/**
	 * prepare_partitions
	 */

	map part_data = $[];
	boolean partitions_defined = false;

	foreach(string device, map device_data , AutoinstStorage::targetMap,
		``{
	    if (device == target_is)
	    {
		part_data = device_data;
		if (size(device_data["partitions"]:[]) > 0)
		{
		    partitions_defined = true;
		}
	    }
	});



	partitions = prepare_partitions (target, partitions);

	boolean already_partitioned = false;
	boolean root_created = false;
	string use = "";
	
	if ( haskey(part_data , "use"))
	{
	    use = part_data["use"]:"";
	}

	if (use == "linux")
	{
	    list linuxp = [];
		if( Storage::IsRealDisk( target_is, target ) )
		{
		    list l = filter( map `p, target["partitions"]:[],
				     ``(!p["delete"]:false &&
					!p["format"]:false &&
					Partitions::IsLinuxPartition(p["fsid"]:0)) );
		    l = filter( `p, l, ``(contains( [`xfs, `ext2, `ext3, `jfs, `reiser, `swap],
						    p["used_fs"]:`unknown)));
		    l = filter( `p, l, ``(!contains( FileSystems::system_m_points,
						     p["mount"]:"" )));
		    if( size(l)>0 )
		    {
			linuxp = union( linuxp, l );
		    }
		}

	    list lp = [];

	    if ( size (linuxp ) > 0 )
	    {
		lp = maplist(map p, linuxp, ``{
		    return(sformat("%1", p["nr"]:-1));
		});
		y2debug("linux partitions: %1", lp );
		use = mergestring(lp, ",");
	    }
	    else
	    {
		use = "none";
	    }
	    y2milestone("Using linux partitions only: %1", use );
	}


	// First check if free space should be used
	//
	string no_space_reason = sformat(_("No free space available on %1"), target_is);

	if ( (num_primary ( partitions ) > 0) || contains_extended ( partitions ) )
	{
	    already_partitioned = true;

	    // If there is an unpartitioned area on the disk, check if it should be used.
	    // (this will automatically partition this area)

	    if ( can_do_auto && use == "free")
	    {
		y2milestone("Using free space only");		
		if (!partitions_defined
		    && !root_created
		    && unused_region[1]:0 != 0)
		{
		    partitions = create_partitions (target, partitions, unused_region);
		    root_created = true;
		}
		else if ( unused_region[1]:0 != 0 )
		{
		    partitions = CreatePartitions (partitions, unused_region, target["label"]:"");
		}
		else if ( unused_region[1]:0  == 0)
		{
		    Report::Error(no_space_reason);
		    return (false);
		}

		
		if (!SaneRegionLimits( unused_region, partitions) )
		{
		    Report::Error(no_space_reason);
		    return (false);
		}

		rewrite_settings (partitions, target, driveMap);
		auto_undefine ();
		return (true);
	    }
	    else if ( unused_region[1]:0  == 0 && use == "free" )
	    {
		Report::Error(no_space_reason);
		return (false);
	    }
	}
	else
	{
	    // no partitions found
	    y2milestone ("Partitioning whole disk");
	    Storage::SetWholeDisk( true );
	}

	boolean ok = false;
	while (true)
	{
	    if (!already_partitioned)
	    {
		if (!partitions_defined
		    && !root_created)
		{
		    partitions = create_partitions (target,partitions, unused_region);
		    root_created = true;

		}
		else
		{
		    partitions = CreatePartitions (partitions, unused_region,
		                                   target["label"]:"" );
		}
		rewrite_settings (partitions, target, driveMap);
		if (size(partitions) > 0 )
		{
		    ok = true;
		}
		break;
	    }



	    // The partitions that remain untouched.
	    list old_partitions = [];

	    // The partitions that are deleted.
	    list selected_partitions = [];

	    // The union of both lists.
	    list all_partitions = [];

	    map extended_pentry = $[];


	    list p_to_keep = [];
	    boolean strict_mode = false;

	    list auto_partitions = maplist (map auto_part , AutoinstStorage::targetMap[target_is, "partitions"]:[],
		     ``{

		if ( haskey(auto_part, "create") &&   !auto_part["create"]:true  &&  auto_part["partition_nr"]:-1 != -1 )
		{
		    p_to_keep = add( p_to_keep, auto_part["partition_nr"]:-1);
		    auto_part["kept"] = true;
		    y2milestone("Keeping: %1", auto_part);
		}
		else if (  haskey (auto_part, "create")   &&  ! auto_part["create"]:true  &&  auto_part["partition_id"]:-1 != -1 )
		{
		    /*  No partition numbers given, so we can't delete any partition.
			We will look for first partition of this type and use it, if required format it and mount
			it as described in the control file. If no partitions of this type are available, they will be
			ignored.
		    */
		    strict_mode = true;
		    use = "none";

		    auto_part["kept"] = true;
		}

		return (auto_part);

	    });

	    list selpart = [];
	    if (use!= "" && use != "all" && use != "free" && use != "none")
	    {
		y2milestone("using only selected partitions");
		list selected_partitions = [];
		list tmp_selpart = splitstring(use, ",");

		selpart = maplist (`p, tmp_selpart, ``{
		    if  ( findfirstnotof( p, "0123456789") == nil  )
		    {
			return(tointeger(p));
		    }
		});

	    }

	    // now loop through partitions
	    boolean creating_anything = false;

	    foreach (`pentry, partitions, ``{

		symbol ptype = pentry["type"]:`unknown;

		if (ptype != `extended)
		{
		    boolean to_be_deleted = false;

		    // STRICT Mode: No partitions are deleted or re-created
		    if (strict_mode)
		    {
			pentry["create"] = false;
			foreach (map autopart , auto_partitions , ``{
			    if (pentry["fsid"]:-1 == autopart["partition_id"]:-2)
			    {			
				string dev = Storage::GetDeviceName( target_is, pentry["nr"]:0 );
				y2milestone( "STRICT MODE: Auto-partitioning device: %1", dev );
				if ( pentry["format"]:false)
				{
				    symbol detected_fs = pentry["detected_fs"]:`reiser;
				    pentry["used_fs"] = AutoinstStorage::StringFS2Symbol( autopart["filesystem"]:detected_fs);
				}
				else
				{
				    pentry["used_fs"] = FileSystems::DetectFs( dev );
				}
				string mntpoint = "";
				if (pentry["used_fs"]:`unknown != `unknown )
				    mntpoint = sformat("/data%1", pentry["nr"]:0);

				pentry["mount"] = autopart["mount"]:mntpoint;
				pentry["format"] = autopart["format"]:false;
				
				if ( autopart["lvm_group"]:"" != "" )
				{
				    pentry["lvm_group"]	=  autopart["lvm_group"]:"";
				}				
				pentry["kept"] = true;
			    }
			    else
			    {
				y2milestone("No match -  existing %1, new %2", pentry["fsid"]:-1, autopart["partition_id"]:-2 );
			    }
			});
		    }
		    else if ( use == "all")
		    {
			to_be_deleted = true;
			creating_anything = true;
		    }
		    else if ( contains (selpart, pentry["nr"]:-1) )
		    {
			to_be_deleted = true;
			creating_anything = true;
		    }
		    else if ( contains(p_to_keep, pentry["nr"]:-1) )
		    {
			map drive = AutoinstStorage::targetMap[target_is]:$[];
			list newautoparts = maplist(map autopart , auto_partitions , ``{
			    if (autopart["partition_nr"]:-2 == pentry["nr"]:-1)
			    {
				string mntpoint = "";
				pentry["create"] = false;
				pentry["format"] = autopart["format"]:false;
				string dev = Storage::GetDeviceName( target_is, pentry["nr"]:0 );
				y2milestone( "Auto-partitiong device:%1", dev );

				if ( pentry["format"]:false)
				{
				    symbol detected_fs = pentry["detected_fs"]:`reiser;
				    pentry["used_fs"] = AutoinstStorage::StringFS2Symbol(  autopart["filesystem"]:detected_fs);
				}
				else
				{
				    pentry["used_fs"] = FileSystems::DetectFs( dev );
				}
				if (pentry["used_fs"]:`unknown != `unknown )
				    mntpoint = sformat("/data%1", pentry["nr"]:0);
			
				pentry["mount"] = autopart["mount"]:mntpoint;
				pentry["kept"] = true;
				autopart["kept"] = true;
					
				if ( autopart["lvm_group"]:"" != "" )
				{
				    pentry["lvm_group"]	=  autopart["lvm_group"]:"";
				}
			    }
			    return (autopart);
			});
			drive["partitions"] = newautoparts;
			AutoinstStorage::targetMap[target_is] = drive;

		    }

		    // Mark for deletion
		    pentry["delete"] =  to_be_deleted;
		    
		    if (!to_be_deleted)
		    {
			// Read extended partition if any logical partitions
			// remain
			if ((ptype == `logical)
			    && (size (extended_pentry) > 0))
			{
			    old_partitions = add (old_partitions, extended_pentry);
			    all_partitions = add (all_partitions, extended_pentry);
			    extended_pentry = $[];
			}

			old_partitions = add (old_partitions, pentry);
		    }
		    else
		    {
			pentry["raid_name"] = "";
			selected_partitions = add (selected_partitions, pentry);
		    }
		    all_partitions = add (all_partitions, pentry);
		}
		else
		{
		    extended_pentry = pentry;
		}
	    });

	    if (size (extended_pentry) > 0)
	    {
		// There are no logical partitions left, mark the extended
		// partition for deletion
		extended_pentry = add (extended_pentry, "delete", true);
		all_partitions = add (all_partitions, extended_pentry);
	    }

	    y2milestone ("All Partitions (all_partitions) : '%1'", all_partitions);
	    y2milestone ("Partitions to delete (selected_partitions) : '%1'", selected_partitions);
	    y2milestone ("Partitions to keep (old_partitions) : '%1'", old_partitions);

	    // Check selection for plausability

	    string reason = "";
	    list selected = [];

	    if (!contiguous_selection (selected_partitions))
	    {
		// consistency check: a condition for the installation is not fullfilled
		// this condition is described within the reason
		reason = _("The selected partitions are not contiguous.");
	    }
	    else if (contains_extended (old_partitions) && creating_anything)
	    {
		selected = calculate_selected_region (selected_partitions, extended_region (old_partitions));

		if (!can_create_logical (old_partitions))
		{
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described within the reason
		    reason = _("Too few partitions are marked for removal.
To install Linux, select more partitions to remove.");
		}
		else if (size_of_region (selected) < minimal_size  )
		{
		    y2milestone("selected: %1", selected);
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described within the reason
		    reason = _("The selected partitions are not big
enough to contain a minimal installation.");
		}
		else
		{
		    ok = true;
		    if (!bootable (selected))
			warn_not_bootable ();
		}
	    }
	    else if ( ( ( num_primary (old_partitions) == max_primary ) &&  creating_anything )
		     || ((target["label"]:""=="bsd" || target["label"]:""=="sun")
			 && (size (old_partitions) - size (selected_partitions) + 3 >= max_partitions)))
	    {
		// consistency check: a condition for the installation is not fullfilled
		// this condition is described within the reason
		reason = _("Too few partitions are marked for removal.
To install Linux, select more partitions to remove.");
	    }
	    else
	    {
		selected = calculate_selected_region (selected_partitions, nil);
		if (size_of_region (selected) < minimal_size && creating_anything)
		{
		    y2warning ("selected: %1", selected); // FIXME
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described by the reason
		    reason = _("The selected partitions are not big enough
to contain a minimal installation.");
		}
		else
		{
		    ok = true;
		    if (!bootable (selected))
		    {
			warn_not_bootable ();
		    }
		}
	    }

	    if (ok)
	    {
		if (!partitions_defined
		    && !root_created)
		{
		    partitions = create_partitions (target, all_partitions, selected);
		    root_created = true;
		}
		else
		{
		    partitions = CreatePartitions (all_partitions, selected,
		                                   target["label"]:"" );
		    if (!SaneRegionLimits( selected, partitions) )
		    {
			Report::Error(no_space_reason);
			ok = false;
			break;
		    }
		}
		y2milestone("Final partitions %1", partitions);
		rewrite_settings (partitions, target, driveMap);
		break;
	    }
	    Report::Error(reason);
	    break;

	} // while (true)
	y2milestone("returning=%1", ok );
	return (ok);
    }


    /**
     * Get number of last primary partition
     * @param list partition list
     * @return integer partition number
     */
    global define integer getLastPrimary(list p)``{


	list used_primaries =
	    maplist (`pentry,
		     filter (`pentry, p, ``(!pentry["delete"]:false)),
		     ``(pentry["nr"]:0)
		     );

	integer unused = 1;

	while (contains (used_primaries, unused))
	{
	    unused = unused + 1;
	}
	return unused;
    }


    global define SaneRegionLimits (list unused,  list partitions) ``{
	map lastPart = select(partitions, size(partitions) -1 , $[]);
	y2milestone("last partitions = %1", lastPart );
	list last_region = [  lastPart["region", 0 ]:0  , lastPart["region", 1]:0 ];

	y2milestone("last=%1, unused=%2", end_of_region(last_region) , end_of_region(unused) );

	if ( end_of_region(last_region) > end_of_region(unused)  && end_of_region(unused) != 0 )
	    return false;

	return true;

    }


    /**
     *	Create partitions defined in the Profile
     *	@param list of available partitions on the drive
     *  @param Region on drive where new partitions are added
     * @param label
     *  @return new partitions list
     */

    global define CreatePartitions (list partitions, list selected_region, string label)
	``{

	y2milestone("initial partition list: %1", partitions);
	y2milestone("selected region: %1", selected_region);


	recalculateSizes(selected_region);

	partitions = filter (`pentry,
			     partitions,
			     ``(lookup (pentry, "type", `unknown) != `free)
			     );
	partitions = renumber_logical_partitions (partitions);

	y2milestone("partition list after renumbering: %1", partitions);

	symbol ptype = `primary;
	integer last_pnr = 0;

	list region = [ 0 , 0 ];

	list old = filter (`pentry,
			   partitions,
			   ``(!pentry ["delete"]:false)
			   );

	if ( size(old) > 0 )
	{
	    map lastPart = select(old, size(old) -1 , $[]);
	    region = [  lastPart["region", 0 ]:0  , lastPart["region", 1]:0 ];
	}


	list root_region = [ 0 , 0 ];
	boolean empty_disk = (partitions == []);

	map absd_partition =
	    $[
	      "create":true,
	      "format":true,
	      "type": `primary,
	      "fsid":Partitions::fsid_empty,
	      "nr":3,
	      "region":full_region
	    ];

	// Get new partitions as specified in control file
	list tmp_auto_partitions =  AutoinstStorage::targetMap[target_is, "partitions"]:[];

	list auto_partitions = filter (`pentry,
				       tmp_auto_partitions ,
				       ``(!pentry["kept"]:false )
				       );	

	// First create any primary partitions if specified so in control file.
	// FIXME: use max_primaries instead of fixed number
	list primaries = filter (`pentry, auto_partitions, ``(
							      ( pentry["partition_type"]:"none" == "primary"
								|| pentry["partition_nr"]:99 < Partitions::MaxPrimary(label) )
							      &&  pentry["partition_id"]:-1 != 15
							      &&  pentry["partition_id"]:-1 != 5
							      )
				 );
	if ( size (primaries) > 0 )
	{
	    y2milestone("primary partitions needed");
	    last_pnr = getLastPrimary(partitions);
	    list primary_auto_partitions = maplist(`p, primaries,   ``{
		if ((label=="bsd" || label=="sun")
		    && (last_pnr == 3))
		{
		    last_pnr = last_pnr + 1;
		}
		map newPart = addPartition(p);
		last_pnr = last_pnr + 1;
		return (newPart);
	    });
	    last_pnr = last_pnr - 1;
	    partitions = union(partitions , primary_auto_partitions);
	}

	auto_partitions = filter(`pentry, auto_partitions, ``( ! (
								  (
								   pentry["partition_type"]:"none" == "primary"
								   || pentry["partition_nr"]:99 < Partitions::MaxPrimary(label)
								   )
								  &&  pentry["partition_id"]:-1 != 15
								  &&  pentry["partition_id"]:-1 != 5
								  )
							       )
				 );

	y2milestone("Partitions up to now: %1", partitions);
	y2milestone("Partitions still to be created (other than Primary): %1", auto_partitions);

	if ( size(auto_partitions) == 0)
	{
	    return (partitions);
	}


	if (label == "msdos")
	{
	    ptype = `logical;
	}
	else
	{
	    // If we don't have a FAT partition_type get the
	    // last used partition number
	    integer unused_primary_pnr = getLastPrimary(partitions);
	    last_pnr = unused_primary_pnr - 1;
	}


	// Add the extended partition if necessary

	if (ptype == `logical)
	{
	    if (!contains_extended (partitions))
	    {

		integer unused_primary_pnr = getLastPrimary(partitions);

		// create new extended partition
		// if it starts above cyl 1024, create it as fsid_extended_win

		integer ext_fsid = Partitions::fsid_extended;
		if (start_of_region (selected_region) >= 1024)
		{
		    ext_fsid = Partitions::fsid_extended_win;
		}
		list extended = filter (`pentry, auto_partitions, ``((pentry["partition_type"]:"none" == "extended"
								      || pentry["partition_id"]:0 == 15
								      || pentry["partition_id"]:0 == 5))
					);

		list ext_region = [ 0 , 0 ];

		if ( size(extended) == 1 )
		{
		    y2milestone("extended found");
		    ext_region = extended[0, "region"]:[]; // lookup(select(extended,0,$[]),"region",[]);
		    if (ext_region == [] )
		    {
			ext_region = calcRegion(extended[0]:$[], region);
		    }
		    region  = ext_region;

		    y2milestone("Extended region: %1 - Region: %2", ext_region, region);

		    auto_partitions = filter(`pentry, auto_partitions, ``(!(pentry["partition_type"]:"none" == "extended"
									    || pentry["partition_id"]:0 == 15
									    ||  pentry["partition_id"]:0 == 5))
					     );

		    selected_region = ext_region;
		}
		else
		{
		    ext_region =  [ end_of_region(region), end_of_region(selected_region) -  end_of_region(region)];
		}
		y2milestone("Adding extended partition to: %1",partitions);
		partitions = add (partitions,
				  $[
				    "create":true,
				    "type":`extended,
				    "fsid":ext_fsid,
				    "nr":unused_primary_pnr,
				    "region": ext_region,
				    "device": get_device_name(target_is, unused_primary_pnr)
				  ]);
		y2milestone("Partitions including extended: %1", partitions);

		last_pnr = max_primary;
	    }
	    else
	    {
		// Find the last used logical partition number.
		// We know that these partitions are numbered contiguously

		last_pnr = first_logical_nr - 1;
		foreach (`pentry, partitions, ``{

		    if (!pentry["delete"]:false
			&& (pentry["type"]:`unknown == `logical))

		    {
			last_pnr = pentry["nr"]:0;
		    }
		});
	    }
	} // ptype == `logical


	last_pnr = last_pnr + 1;



	list logical_auto_partitions = maplist(`p, auto_partitions,
					       ``{
						   if ((label == "bsd" || label == "sun")
						       && (last_pnr == 3))
						   {
						       last_pnr = last_pnr + 1;
						   }
						   map newPart = addPartition(p);
						   last_pnr = last_pnr + 1;
						   return(newPart);
					       });

	// Add flag whether using the entire disk

	if ((label == "bsd" || label == "sun")
	    && (last_pnr == 3)
	    && empty_disk)
	{
	    partitions = add (partitions, absd_partition);
	}

	Storage::SetWholeDisk( selected_region == full_region);

	list finalPartitions =  union(partitions,logical_auto_partitions);
	
	y2milestone("FINAL partitions: %1", finalPartitions);
	return( finalPartitions );

    }; // CreatePartitons





    /**
     * Create a partition
     * @param currentPartition partition data as specified in control file
     * @return map partition data ready
     */

    global define map addPartition(map currentPartition) ``{

	string mount_point = currentPartition["mount"]:"";

	region = calcRegion(currentPartition, region);

	integer auto_fsid = currentPartition["partition_id"]:Partitions::fsid_native;

	// LVM
	string lvm_group = currentPartition["lvm_group"]:"";


	// Raid
	string raid_name = currentPartition["raid_name"]:"";


	// Partition Template
	map part =
	    $[
	      "create":	true,
	      "format":	currentPartition["format"]:true,
	      "fs_options": currentPartition["fs_options"]:$[],
	      "type": 	ptype,
	      "fsid": 	auto_fsid,
	      "nr":	last_pnr,
	      "region":	region,
	      "mount": 	mount_point,
	      "device": get_device_name(target_is, last_pnr)
	    ];

	if (currentPartition["crypt_fs"]:false)
	{
	    part["crypt_fs"]  =   currentPartition["crypt_fs"]:false;
	    part["crypt_key"] =   Storage::AddCryptToClassified( currentPartition["crypt_key"]:"");
	}

	if (haskey(currentPartition, "fstopt") && currentPartition["fstopt"]:"" != "")
	{
	    part["fstopt"] 		= currentPartition["fstopt"]:"";
	}

	if (haskey(currentPartition, "label") && currentPartition["label"]:"" != "")
	{
	    part["label"] 		= currentPartition["label"]:"";
	}

	if (haskey(currentPartition, "mountby"))
	{
	    part["mountby"] 	= currentPartition["mountby"]:`device;
	}


	if (mount_point == "swap" || AutoinstStorage::StringFS2Symbol(currentPartition["filesystem"]:"") == `swap)
	{
	    part["fsid"] =  Partitions::fsid_swap;
	    part["mount"] = "swap";
	}
	else if (mount_point == "/boot")
	{
	    if (currentPartition["partition_id"]:0 != 0)
	    {
		part["fsid"] =  currentPartition["partition_id"]:0;
	    }
	    else
	    {
		part["fsid"] =  fsid_boot;
	    }

	    symbol tmpfs = AutoinstStorage::StringFS2Symbol(currentPartition["filesystem"]:"none");
	    if (tmpfs != `none)
	    {
		part["used_fs"] = tmpfs;
	    }
	    else
	    {
		if (fsid_boot == Partitions::fsid_fat32)
		{
		    // for ia64, /boot is FAT32
		    part["used_fs"]:`fat32;
		}
	    }
	}
	else if (mount_point == "/")
	{
	    root_region=region;
	    part["used_fs"] =  AutoinstStorage::StringFS2Symbol(currentPartition["filesystem"]:"reiser");
	}
	else if (lvm_group != "")
	{
	    Storage::SetLvmUse( true );

	    part["used_fs"]		=  `unknown;
	    part["fsid"]		=  Partitions::fsid_lvm;
	    part["format"]		=  false;
	    part["lvm_group"]		=  lvm_group;
	    part["mount"]		=  "";
	    part["fstype"]		=  "Linux LVM";
	}
	else if (raid_name != "")
	{
	    any nr = substring(raid_name, 7);

	    part["used_fs"]		= `unknown;
	    part["fsid"]		= Partitions::fsid_raid;
	    part["format"]		= false;
	    part["raid_name"]		= raid_name;

	    part["mount"]		= "";
	    part["fstype"]		= "Linux RAID";	    
   
	}
	else
	{
	    part["used_fs"] = AutoinstStorage::StringFS2Symbol(  currentPartition["filesystem"]:"reiser");
	}

	y2milestone("Adding partition: %1", part);

	return part;
    }


    /**
     * LVM Configuration
     *
     */


    global define boolean autoLVM () ``{

	import "AutoinstLVM";
	import "Storage";
	Storage::ZeroNewPartitions = true;
	boolean error = false;

	
	foreach (string device, map volume_group, AutoinstStorage::lvm ,
		 ``{

	    string use 		= volume_group["use"]:"none";
	    list selpart = [];
	    string vgname	= substring(device, 5);
	    list new_pvs	= AutoinstLVM::ExistingPVs(vgname);
	    list new_pvs_dev 	= maplist(`pv, new_pvs, ``{
		return(pv["device"]:"");
	    });	   

	    if (AutoinstLVM::OldAvailable )
	    {
	
		y2milestone("Old LVM available");
		
		foreach(`vgdev, `vg, AutoinstLVM::ExistingLVM, ``{

		    string vg = substring(vgdev, 5);
		    boolean delete = false;
		    list deleted_pvs = AutoinstLVM::DeletedPVs(vg);
		    
		    list del_pvs_dev 	= maplist(`pv, deleted_pvs, ``{
			return(pv["device"]:"");
		    });
		    
		    if ( use == "all" && vg == vgname )
		    {			 
			delete = true;
		    }
		    else if (
			     size(deleted_pvs) > 0
			     && size(toset(union(del_pvs_dev,  new_pvs_dev))) < (size(del_pvs_dev) + size( new_pvs_dev))
			     )
		    {
			delete = true;
		    }

		    if (AutoinstLVM::PVsNotConfigured)
		    {
			Report::Error(sformat(_("Logical volumes of group \"%1\" exist on unconfigured devices.
You have to delete old volume groups first or configure all devices containing
physical volumes which belong to this group."), vgname));
			error = true;
			
		    }
			

		    // Delete old LVM
		    if ( delete && !error)
		    {
			map ExistingVG = AutoinstLVM::ExistingLVM[vgdev]:$[];
		
			list ExistingLVs = ExistingVG["partitions"]:[];
			foreach(`lv, ExistingLVs, ``{
			    AutoinstLVM::RemoveLV( vg, lv["nr"]:"");
			});
			
			AutoinstLVM::RemoveVG( vg );
		    }

		    
		    // Delete selected only
		    if (use!= "" && use != "all" && use != "free" && use != "none")
		    {
			y2milestone("using only selected lvs");			
			selpart = splitstring(use, ",");			
		    }
		    
		    if (size(selpart) > 0 && !delete)
		    {
			foreach(`lv, selpart, ``{
			    AutoinstLVM::RemoveLV( vg, lv);
			});
		    }
		
		    
		});
	    }

	  
	    AutoinstLVM::SetPESIZE( volume_group["pesize"]:"4M" );	  		    	   
			
	    y2milestone("Existing PVs: %1",  new_pvs );
	    map new_volume = $[];
	    
	    if (use == "all")
	    {
		new_volume = AutoinstLVM::CreateVG (vgname);

		foreach(map pv, new_pvs, ``{
		    AutoinstLVM::CreatePV (vgname, pv["device"]:"");
		});
	    }
	    else
	    {
		new_volume = AutoinstLVM::ExistingLVM[device]:$[];
	    }
		
	    list new_partitions = maplist(map lv,  volume_group["partitions"]:[], ``{

		list lvlist =  AutoinstLVM::ExistingLVM[device, "partitions"]:[];
		map this_lv = select(filter(`p, lvlist, ``(p["nr"]:"" == lv["lv_name"]:"")), 0, $[]);
		
		y2debug("This LV: %1", this_lv);
		
		lv["used_fs"]	=	this_lv["used_fs"]:`none;

		
		if (lv["create"]:true && !lv["resize"]:false)
		{
		    return (AutoinstLVM::CreateLV( vgname, lv ));		    
		}
		else if (lv["resize"]:false)
		{
		    
		    return (AutoinstLVM::ResizeLV( vgname, lv ));		    
		}	
		else
		{
	
		    return (AutoinstLVM::KeepLV( vgname, lv ));
		}
	    });

	    new_volume["partitions"] = new_partitions;
	    AutoinstLVM::Volumes[device] = new_volume;	  
		
	});


	y2milestone("Volumes: %1", AutoinstLVM::Volumes);
	if (error)
	    return false;
	
	Storage::SetModifyTargets( AutoinstLVM::modify_targets );	
	map new_targetMap = union(Storage::GetTargetMap(), AutoinstLVM::Volumes);
	
	Storage::SetTargetMap(new_targetMap);

	return true;
    }
    

    
    /**
     * Create RAID
     *
     */
    global define void autoRAID()
	``{
	import "AutoinstRAID";
	
	list RaidList =  maplist ( map device, AutoinstStorage::raid["/dev/md", "partitions"]:[],  ``{

	    string use 		= 	AutoinstStorage::raid["/dev/md","use"]:"none";	    
	    string dev 		= 	sformat("/dev/md%1", device["partition_nr"]:0);
	    
	    if (AutoinstRAID::OldAvailable)
	    {
		list mds = AutoinstRAID::ExistingRAID["/dev/md","partitions"]:[];
		list new_mds = maplist( `md, mds ,``{
		    
		    if ( use == "all" && dev == md["device"]:"" )
		    {			 			 
			 md["delete"] = true;
		    }
		    return (md);
		});
		map allmds =  AutoinstRAID::ExistingRAID["/dev/md"]:$[];
		allmds["partitions"]	= new_mds;
		AutoinstRAID::ExistingRAID["/dev/md"] = allmds;
	    }

	    
	    y2milestone("Working on %1", device);

	    device["device"] 	= dev;
	    
	    string chunk_size = "4";  
	    map options = device["raid_options"]:$[];	    
	    string raid_type	= options["raid_type"]:"raid1";	  	    

	    if ( raid_type == "raid5" )
	    {
		chunk_size = "128";
	    }
	    if ( raid_type == "raid0" )
	    {
		chunk_size = "32";
	    }

	   
	    
	    string sel_chunksize = options["chunk_size"]:"";

	    if ( sel_chunksize != "" )
	    {
		chunk_size = sel_chunksize;
		options["chunk_size"]	= chunk_size;
	    }


	    if(  raid_type == "raid5" && options["parity_algorithm"]:"" == "" )
	    {
		options["parity_algorithm"] = "left-symmetric";
	    }

	    device["nr"] = device["partition_nr"]:"0";



	    if (device["lvm_group"]:"" != "")
	    {
		device["fsid"]		= Partitions::fsid_lvm;
	    }
	    else
	    {
		device["fsid"]		= device["partition_id"]:Partitions::fsid_native;
	    }
	    device["region"]		= [0 , 1];

	    if (!haskey(device, "create"))
	    {
		device["create"]		= true;
		device["status"]		= "create";
	    }
	    
	    

	    if (!haskey(device, "format"))
	    {
		device["format"]	= false;
	    }

	    if (device["format"]:false)
	    {
		symbol selected_fs	= AutoinstStorage::StringFS2Symbol(device["filesystem"]:"");
		device["used_fs"]	= selected_fs;
	    }
	    
	    device["type"]		= `sw_raid;


	    if (device["crypt_fs"]:false)
	    {
		device["crypt_key"] =   Storage::AddCryptToClassified( device["crypt_key"]:"");
	    }

	    
	    return (union(device, options));
	});
	

	foreach( `part, RaidList,
		 ``({
		     integer len = raid_size_byte( Storage::GetTargetMap(), part);
		     part["region"] = [0, len / (1024 * 1024)];
		     return( part );
		 }));

	list allraid = [];
	
	if (size (AutoinstRAID::ExistingRAID["/dev/md","partitions"]:[]) > 0 )
	{
	    y2milestone("Existing RAID: %1", AutoinstRAID::ExistingRAID);
	    allraid = union (AutoinstRAID::ExistingRAID["/dev/md", "partitions"]:[], RaidList );
	}
	else
	{
	    allraid =  RaidList;
	}
	
	map RaidMap = $[ "/dev/md" :
			 $[
			   "cyl_count" : 1,                         // typicall 1
			   "cyl_size" : 1048576,                    // const 1MB
			   "name" : "Linux Software RAID",
			   "partitions" : allraid,
			 ]
	];
	y2milestone("RaidMap: %1", RaidMap);

	map new_targetMap = union(Storage::GetTargetMap(), RaidMap);
	Storage::SetTargetMap(new_targetMap);
	
	y2milestone("Targets: %1", Storage::GetTargetMap());
    }




    /**
     * Racalculate sizes
     *
     */
    global define void recalculateSizes ( list region )
	``{
	integer totalsize = size_of_region (region);
	y2milestone("Total available space: %1", totalsize);

	// Get new partitions as specified in control file
	list tmp_auto_partitions =  AutoinstStorage::targetMap[target_is, "partitions"]:[];

	list auto_partitions = filter (`pentry,
				       tmp_auto_partitions ,
				       ``(!pentry["kept"]:false )
				       );
	string psize = "";
	integer realsize = 0;
	integer maxsize = 0;
	boolean grow = false;
	integer min = 0;
	integer max = 0;
	string mount_point = "";
	integer ratio = 0;
	boolean region_active = false;
	boolean grow_possible  = true;

	foreach(map part, auto_partitions, ``{
	    if (size(part["region"]:[]) == 0 )
	    {
		psize = part["size"]:"";
		mount_point = part["mount"]:"";
		ratio = part["ratio"]:0;

		if (part["maxsize"]:"" != "")
		{
		    maxsize = kmgt_str_to_byte(part["maxsize"]:"");
		}

		grow =  part["grow"]:false;
	    }
	    else
	    {
		realsize = size_of_region (part["region"]:[] );
		region_active = true;
	    }

	    if (psize == "auto")
	    {
		if (mount_point == "/boot")
		{
		    realsize = size_of_boot;
		}
		else if  (mount_point == "swap")
		{
		    realsize = size_of_swap;
		}
	    }
	    else if ( psize != "" && psize != "max" )
	    {
		realsize = kmgt_str_to_byte(psize);
	    }
	    else if (ratio != 0 )
	    {
		integer tmp_size = totalsize * ( ratio / 100);
		if (maxsize > 0 )
		    realsize = maxsize;
		else
		    realsize = tmp_size;
	    }
	    else if (!region_active )
	    {
		realsize = 0;
	    }


	    min = min + realsize;
	    max = max + maxsize;
	    region_active = false;
	    maxsize = 0;
	    realsize = 0;
	});


	y2milestone("Minimal size: %1 - Maximal size: %2", min, max);

	if (min < totalsize) {
	    y2milestone("Using default sizes is possible");
	}
	else
	{
	    y2milestone("Not enough space for default size!");
	}

	if (max < totalsize )
	{
	    y2milestone("Using maximal growable sizes is possible");
	    integer  number_of_partitions = size( auto_partitions );
	    integer i = 1;
	    list npartitions = maplist(map part, auto_partitions, ``{

		if ( part["maxsize"]:"" != "" && part["grow"]:false )
		{
		    part["size"] =  part["maxsize"]:"";
		}
		else if ( part["maxsize"]:"" == "" && part["grow"]:false && i == number_of_partitions)
		{
		    part["size"] = "max";
		}

		y2debug ("counter: %1, partitions: %2", i,  number_of_partitions);
		i = i + 1;
		return (part);
	    });
	    y2milestone("Partitions with new sizes: %1", npartitions);
	    map drive = AutoinstStorage::targetMap[target_is]:$[];
	    drive["partitions"] = npartitions;
	    AutoinstStorage::targetMap[target_is] = drive;
	}
	else
	{
	    y2milestone("Growing not possible");
	}


	return;
    }


    /**
     * Calculate new Region
     * @param map partition map
     * @param list region list
     * @return list new region
     */
    global define calcRegion(map currentPartition, list region )
	``{
	y2milestone("Region=%1", region);
	integer units = 0;
	string psize = "";
	if ( size(currentPartition["region"]:[]) == 0 )
	{
	    psize = currentPartition["size"]:"";
	}

	string mount_point = currentPartition["mount"]:"";
	list autoRegion = currentPartition["region"]:[];

	if ( psize != "" && psize != "auto" && psize != "max" )
	{
	    units = size_to_units(kmgt_str_to_byte(psize));
	    if (units == 0)
	    {
		units = end_of_region (selected_region) - end_of_region (region);
	    }
	}
	else if (psize == "auto")
	{
	    if (mount_point == "/boot")
	    {
		units = size_to_units (size_of_boot);
	    }
	    else if  (mount_point == "swap")
	    {
		units = size_to_units (size_of_swap);
	    }
	    else
	    {
		units = end_of_region (selected_region) - end_of_region (region);
	    }

	}
	else if (psize == "max")
	{
	    units = end_of_region (selected_region) - end_of_region (region);
	}
	else if ( psize == ""  &&  size(autoRegion) > 0 )
	{
	    return autoRegion;
	}


	if ( region[1]:-1 == 0 )
	{
	    region = [ selected_region[0]:0 , units];
	}
	else
	{
	    region = [ end_of_region(region), units];
	}
	y2milestone("Region=%1", region);
	return region;
    }






}
