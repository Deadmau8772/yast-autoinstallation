/**
 * File:		autoinstall/partitioning.ycp
 * Module:		Autoinstallation
 * Authors:             Anas Nashif <nashif@suse.de>
 * Purpose:		functions for partitioning in autoinst mode
 *
 *
 * $Id$
 */

{    
    include "partitioning/auto_part_functions.ycp";
    include "partitioning/auto_part_prepare.ycp";
    include "partitioning/auto_part_create.ycp";
    include "partitioning/auto_finish.ycp";    
    include "partitioning/size_calculations.ycp";
    include "partitioning/raid_lib.ycp";
    include "partitioning/partition_defines.ycp";
    include "partitioning/lvm_ui_lib.ycp";
    include "partitioning/lvm_ui_dialogs.ycp";
    include "partitioning/lvm_lib.ycp";
    include "partitioning/lvm_pv_lib.ycp";
    include "partitioning/lvm_lv_lib.ycp";

    
    textdomain "autoinst";
    /**
     *  Determine how and where the partitions are added in autoinst mode
     *  modifies targetMap with new partition list for the specified device
     *  @param device name of the target drive
     *  @return true on success
     */
    
    global define AutoPartition(string target_is)
    ``{

	// find the selected target in the map of all possible targets
	
	map driveMap =  Storage::GetTargetMap();

	// description of the choosen target disk
	map target = driveMap[target_is]:$[];

	// user visible name of target
	string targetname = target["name"]:"";

	// The current list of partitions
	list partitions = target["partitions"]:[];

	symbol partition_type = compute_partition_type (Boot::LoaderType);
	integer max_partitions = compute_max_partitions (target, partition_type);

	// The number of possible primary partitions
	integer max_primary = compute_max_primary (partition_type);

	
	// The partition number of the first logical partition
	integer first_logical_nr = 5;


	// fdisk partition ids
	
	list full_region = [];
	integer bytes_per_unit = 0;
	integer disk_size = 0;
	
	integer 	fsid_boot      	= Partitions::FsidBoot();
	integer        	fsid_root       = Partitions::fsid_native;

	// How much to allocate for swap
	integer size_of_swap = calculate_needed_swap ();

	// calculate size of the /boot partition
	integer size_of_boot = Partitions::MinimalNeededBootsize(); 



	// this will tell if automatic partitioning if feasible
	boolean can_do_auto = false;

	// this will get the minimal size for a default system
	//   (boot + swap + default root)
	integer minimal_size = 0;

	list unused_region = [ 0, 0 ];

	/**
	 * prepare_partitions
	 */
	map part_data = $[];
	boolean partitions_defined = false;
	foreach(`dev, `v , AutoInstall::targetMap, 
	``{
	    if (dev == target_is)
	    {
		part_data=v;
		if (size(v["partitions"]:[])>0)
		{
		    partitions_defined = true;
		}
	    }
	});

	partitions = prepare_partitions (target, partitions);
	
	SCR::Write (.dumpto.tmp.prepared_partitions, partitions);
	
	boolean already_partitioned = false;	
	boolean root_created = false;
	string use = "";
	if ( haskey(part_data, "use"))
	{
	    use= part_data["use"]:"";
	}
	else if ( haskey(part_data, "reuse"))
	{
	    use= part_data["reuse"]:"";
	}


	if ( (num_primary ( partitions ) > 0) || contains_extended ( partitions ) )
	{
	    already_partitioned = true;

	    // If there is an unpartitioned area on the disk, check if it should be used.
	    // (this will automatically partition this area)
	    
	    if ( can_do_auto && use == "free")
	    {
		// Note: CreatePartitions changes targetMap
		if (!partitions_defined
		    && !root_created
		    && select(unused_region,1,0) != 0)
		{		
		    partitions = create_partitions (target, partitions, unused_region);
		    root_created = true;
		}
		else if (select(unused_region,1,0) != 0)
		{			
		    partitions = CreatePartitions (partitions, unused_region);
		}
		else if (select(unused_region,1,0) == 0)
		{
		    string reason = sformat(_("No free space available on %1"), target_is);
		    Report::Error(reason);
		    return (true);
		}
		rewrite_settings (partitions, target, driveMap); 
		auto_undefine ();
		return (true);
	    }	
	}
	else
	{
	    // no partitions found	    
	    y2milestone ("Partitioning whole disk");
	    Storage::SetWholeDisk( true );
	}

	while (true)
	{
	    if (!already_partitioned)
	    {
		if (!partitions_defined
		    && !root_created)
		{
		    partitions = create_partitions (target,partitions, unused_region);
		    root_created = true;
		    
		}
		else
		{
		    partitions = CreatePartitions (partitions, unused_region);
		}
		rewrite_settings (partitions, target, driveMap);
		break;
	    }



	    // The partitions that remain untouched.
	    list old_partitions = [];

	    // The partitions that are deleted.
	    list selected_partitions = [];

	    // The union of both lists.
	    list all_partitions = [];

	    map extended_pentry = $[];
	    
	    list selpart = [];
	    if (use!= "" && use != "all" && use != "free")
	    {
		y2milestone("using only selected partitions");
		list selected_partitions = [];
		list tmp_selpart = splitstring(use, ",");

		selpart = maplist (`p, tmp_selpart, ``{
		    if  ( findfirstnotof( p, "0123456789") == nil  )
		    {
			return(tointeger(p));
		    }
		});

	    }
	    

	    // now loop through partitions	    
	    foreach (`pentry, partitions, ``{
		symbol ptype = lookup (pentry, "type", `unknown);
		if (ptype != `extended) {
		    boolean selection = false;
		    if (use == "all")
		    {
			selection = true;
		    }
		    else if (contains(selpart, pentry["nr"]:-1))
		    {
			selection = true;
		    }
		    pentry = add (pentry, "delete", selection);

		    if (!selection)
		    {
			// Read extended partition if any logical partitions
			// remain
			if ((ptype == `logical)
			    && (size (extended_pentry) > 0))
			{
			    old_partitions = add (old_partitions, extended_pentry);
			    all_partitions = add (all_partitions, extended_pentry);
			    extended_pentry = $[];
			}

			old_partitions = add (old_partitions, pentry);
		    }
		    else
		    {
			selected_partitions = add (selected_partitions, pentry);
		    }
		    all_partitions = add (all_partitions, pentry);
		}
		else
		{
		    extended_pentry = pentry;
		}
	    });

	    if (size (extended_pentry) > 0)
	    {
		// There are no logical partitions left, mark the extended
		// partition for deletion

		extended_pentry = add (extended_pentry, "delete", true);
		all_partitions = add (all_partitions, extended_pentry);
	    }

	    y2milestone ("all_partitions '%1'", all_partitions);
	    y2milestone ("selected_partitions '%1'", selected_partitions);
	    y2milestone ("old_partitions '%1'", old_partitions);

	    // Check selection for plausability
	    boolean ok = false;
	    string reason = "";
	    list selected = [];

	    if (!contiguous_selection (selected_partitions))
	    {
		// consistency check: a condition for the installation is not fullfilled
		// this condition is described within the reason
		reason = _("The selected partitions are not contiguous.");
	    }
	    else if (contains_extended (old_partitions))
	    {
		selected = calculate_selected_region (selected_partitions, extended_region (old_partitions));
		
		if (!can_create_logical (old_partitions))
		{
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described within the reason
		    reason = _("Too few partitions are marked for removal.
To install Linux, select more partitions to remove.");
		}
		else if (size_of_region (selected) < minimal_size)
		{
		    y2milestone("selected: %1", selected);
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described within the reason
		    reason = _("The selected partitions are not big
enough to contain a minimal installation.");
		}
		else
		{
		    ok = true;
		    if (!bootable (selected))
			warn_not_bootable ();
		}
	    }
	    else if ((num_primary (old_partitions) == max_primary)
		     || ((partition_type == `ABSD || partition_type == `SBSD)
			 && (size (old_partitions) - size (selected_partitions) + 3 >= max_partitions)))
	    {
		// consistency check: a condition for the installation is not fullfilled
		// this condition is described within the reason
		reason = _("Too few partitions are marked for removal.
To install Linux, select more partitions to remove.");
	    }
	    else
	    {
		selected = calculate_selected_region (selected_partitions, nil);
		if (size_of_region (selected) < minimal_size)
		{
		    y2warning ("selected: %1", selected); // FIXME
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described by the reason
		    reason = _("The selected partitions are not big enough
to contain a minimal installation.");
		}
		else
		{
		    ok = true;
		    if (!bootable (selected))
		    {
			warn_not_bootable ();
		    }
		}
	    }

	    if (ok)
	    {
		if (!partitions_defined
		    && !root_created)
		{
		    partitions = create_partitions (target, all_partitions, selected);
		    root_created = true;
		}
		else
		{
		    partitions = CreatePartitions (all_partitions, selected);
		}
		y2debug("final partitions %1", partitions);
		rewrite_settings (partitions, target, driveMap); 
		break;
	    }
	    Report::Error(reason);
	    break;

	} // while (true)
	return (true);
    }

    /**
     * Get number of last primary partition
     * @param list partition list
     * @return integer partition number
     */    
    global define integer getLastPrimary(list p)``{


	list used_primaries =
	    maplist (`pentry,
		     filter (`pentry, p, ``(!pentry["delete"]:false)),
		     ``(pentry["nr"]:0)
		     );

	integer unused = 1;

	while (contains (used_primaries, unused))
	{
	    unused = unused + 1;
	}
	return unused;
    }
    
    /**  
     *	Create partitions defined in the machine Profile
     *	@param list of available partitions on the drive
     *  @param Region on drive where new partitions are added
     *  @return new partitions list
     */
    
    global define CreatePartitions (list partitions, list selected_region)
    ``{
	y2debug("initial partition list: %1", partitions);
	y2debug("selected region: %1", selected_region);
	partitions = filter (`pentry,
			     partitions,
			     ``(lookup (pentry, "type", `unknown) != `free)
			     );
	
	partitions = renumber_logical_partitions (partitions);
	y2debug("partition list after renumbering: %1", partitions);
	symbol ptype = `primary;
	integer last_pnr = 0;		
	list region = [ 0 , 0 ];
	
	list old = filter (`pentry,
			   partitions,
			   ``(!pentry ["delete"]:false)
			   );

	if (size(old) > 0 )
	{
	    map lastPart = select(old, size(old) -1 , $[]);
	    region = [  select(lastPart["region"]:[], 0, 0) , select(lastPart["region"]:[], 1, 0) ];
	}
	
	
	list root_region = [ 0 , 0 ];
	boolean empty_disk = (partitions == []);

	map absd_partition =
	    $[
	      "create":true,
	      "format":true,
	      "type": `primary,
	      "fsid":Partitions::fsid_empty,
	      "nr":3,
	      "region":full_region
	    ];

	// Get new partitions as specified in control file	
	list auto_partitions =  lookup(AutoInstall::targetMap[target_is]:$[], "partitions",[]);
	y2debug("auto part (1): %1", auto_partitions);
	
	// First create any primary partitions if specified so in control file.
	// FIXME: use max_primaries instead of fixed number
	list primaries = filter (`pentry, auto_partitions, ``(
							      ( pentry["partition_type"]:"none" == "primary" || pentry["partition_nr"]:6 < 5 )
							      &&  pentry["partition_id"]:-1 != 15
							      &&  pentry["partition_id"]:-1 != 5
							      )
				 );
	if (size(primaries)>0)
	{
	    y2milestone("primaries needed");
	    last_pnr = getLastPrimary(partitions);
	    list primary_auto_partitions = maplist(`p, primaries,
						   ``{	    
						       if ((partition_type == `ABSD || partition_type == `SBSD)
							   && (last_pnr == 3))
						       {
							   last_pnr = last_pnr + 1;
						       }
						       map newPart = addPartition(p);
						       last_pnr = last_pnr + 1;
						       return(newPart);
						   });
	    last_pnr = last_pnr - 1;
	    partitions = union(partitions , primary_auto_partitions);
	}
	
	auto_partitions = filter(`pentry, auto_partitions, ``( ! (
								  (
								   pentry["partition_type"]:"none" == "primary" || pentry["partition_nr"]:6 < 5
								   )
								   &&  pentry["partition_id"]:-1 != 15
								   &&  pentry["partition_id"]:-1 != 5
								  )
							       )
				 );
	
	y2milestone("auto part (2): %1", auto_partitions);
	
	if (size(auto_partitions) == 0) {
	    return (partitions);
	}

	
	if (partition_type == `FAT)
	{
	    ptype = `logical;
	}
	else
	{
	    // If we don't have a FAT partition_type get the
	    // last used partition number
	    integer unused_primary_pnr = getLastPrimary(partitions);
	    last_pnr = unused_primary_pnr - 1;
	}


	// Add the extended partition if necessary

	if (ptype == `logical)
	{
	    if (!contains_extended (partitions))
	    {
	
		integer unused_primary_pnr = getLastPrimary(partitions);

		// create new extended partition
		// if it starts above cyl 1024, create it as fsid_extended_win
		
		integer ext_fsid = Partitions::fsid_extended;
		if (start_of_region (selected_region) >= 1024)
		{
		    ext_fsid = Partitions::fsid_extended_win;
		}
		list extended = filter (`pentry, auto_partitions, ``((pentry["partition_type"]:"none" == "extended" || pentry["partition_id"]:0 == 5)));
		list ext_region = [0,0];
		if (size(extended) == 1)
		{
		    y2milestone("extended found");
		    ext_region = lookup(select(extended,0,$[]),"region",[]);
		    auto_partitions = filter(`pentry, auto_partitions, ``(!(pentry["partition_type"]:"none" == "extended" ||  pentry["partition_id"]:0 == 5)));
		    selected_region = ext_region;
		}
		else
		{
		    ext_region =  [ end_of_region(region), end_of_region(selected_region) -  end_of_region(region)];
		}
		y2milestone("Adding extended partition to: %1",partitions);
		partitions = add (partitions,
				$[
				  "create":true,
				  "type":`extended,
				  "fsid":ext_fsid,
				  "nr":unused_primary_pnr,
				  "region": ext_region,
				  "device": get_device_name(target_is, unused_primary_pnr)
				]);
		y2debug("Partitions including extended: %1", partitions);

		last_pnr = max_primary;
	    }
	    else
	    {
		// Find the last used logical partition number.
		// We know that these partitions are numbered contiguously
		last_pnr = first_logical_nr - 1;
		foreach (`pentry, partitions, ``{
		    if (!pentry["delete"]:false
			&& (pentry["type"]:`unknown == `logical))
		    {
			last_pnr = pentry["nr"]:0;
		    }
		});
	    }
	} // ptype == `logical
	

	last_pnr = last_pnr + 1;
	

	
	list logical_auto_partitions = maplist(`p, auto_partitions,
        ``{	    
	    if ((partition_type == `ABSD || partition_type == `SBSD)
		&& (last_pnr == 3))
	    {
		    last_pnr = last_pnr + 1;
	    }
	    map newPart = addPartition(p);
	    last_pnr = last_pnr + 1;
	    return(newPart);
	});

	// Add flag whether using the entire disk
	if ((partition_type == `ABSD || partition_type == `SBSD)
		&& (last_pnr == 3)
		&& empty_disk)
	{
	    partitions = add (partitions, absd_partition);
	}
	Storage::SetWholeDisk(selected_region == full_region);
	
	list finalPartitions =  union(partitions,logical_auto_partitions);
	y2milestone("partitions: %1", finalPartitions);	
	return( finalPartitions );
	
    }; // CreatePartitons



    

    /**
     * Create a partition
     * @param currentPartition partition data as specified in control file
     * @return map partition data ready 
     */

    global define map addPartition(map currentPartition) ``{
		    
	string mount_point = currentPartition["mount"]:"";
	
	region = calcRegion(currentPartition, region);
	    
	integer auto_fsid = currentPartition["partition_id"]:Partitions::fsid_native;

	// LVM
	string lvm_group = currentPartition["lvm_group"]:"";
	 

	// Raid
	string raid_name = currentPartition["raid_name"]:"";
	    
	    
	// Partition Template
	map part =
	    $[
	      "create":	true,	      	    
	      "format":	currentPartition["format"]:true,
	      "fs_options": currentPartition["fs_options"]:$[],	      	      
	      "type": 	ptype,
	      "fsid": 	auto_fsid,
	      "nr":	last_pnr,
	      "region":	region,
	      "mount": 	mount_point,
	      "device": get_device_name(target_is, last_pnr)
	    ];

	if (currentPartition["crypt_fs"]:false)
	{
	    part["crypt_fs"]  =   currentPartition["crypt_fs"]:false;
	    part["crypt_key"] =   Storage::AddCryptToClassified( currentPartition["crypt_key"]:"");
	}
	    
	if (haskey(currentPartition, "fstopt") && currentPartition["fstop"]:"" != "")
	{
	    part["fstopt"] 		= currentPartition["fstop"]:"";
	}
	    
	if (haskey(currentPartition, "label") && currentPartition["label"]:"" != "")
	{
	    part["label"] 		= currentPartition["label"]:"";
	}

	if (haskey(currentPartition, "mountby"))
	{
	    part["mountby"] 	= currentPartition["mountby"]:`device;
	}
	    
	    

	    
	if (mount_point == "swap" || StringFS2Symbol(p["filesystem"]:"") == `swap)
	{
	    part["fsid"] =  Partitions::fsid_swap;
	    part["mount"] = "swap";
	}
	else if (mount_point == "/boot")
	{
	    part["fsid"] =  fsid_boot;
	    if (fsid_boot == Partitions::fsid_fat16)
	    {
		// for ia64, /boot is FAT16
		boot_part["used_fs"]:`fat16;
	    }
	}
	else if (mount_point == "/")
	{
	    root_region=region;
	    part["used_fs"] =  StringFS2Symbol(currentPartition["filesystem"]:"reiser");
	}
	else if (lvm_group != "")
	{
	    Storage::SetLvmUse( true );
		
	    part["used_fs"] 	=  `unknown;
	    part["fsid"]		=  Partitions::fsid_lvm;
	    part["format"] 		=  false;
	    part["lvm_group"] 	=  lvm_group;
	    part["mount"] 		=  "";
	    part["fstype"] 		=  "Linux LVM";
	
	
		
	}
	else if (raid_name != "")
	{
	    any nr = substring(raid_name, 7);			
	
	    part["used_fs"] 	= `unknown;
	    part["fsid"]		= Partitions::fsid_raid;
	    part["format"] 		= false;
	    part["raid_name"] 	= raid_name;

	    part["mount"] 		= "";
	    part["fstype"] 		= "Linux RAID";
	    part["raid_type"]	= currentPartition["raid_type"]:"raid";
		
	    // part["region"] 		= [0, raid_size_byte(Storage::GetTargetMap(), 
	    //                                 part) / (1024 * 1024)];
	}
	else
	{
	    part["used_fs"] = StringFS2Symbol(  currentPartition["filesystem"]:"reiser");
	}

	    
	    
	return part;
    }


    global define autoLVM() ``{
	
	map LvmVolumes = $[];
	map tmap = Storage::GetTargetMap();
	map modify_targets	= Storage::GetModifyTargets();

	
	foreach (map group, AutoInstall::LVM,
		 ``{
	    string vg 			= group["lvm_name"]:"";				     
	    integer pesize		= pesize_str_to_byte( lookup( group, "pesize", "4M" ));

				     
	    list existing_pvs  	= filter( `part, get_possible_pvs( tmap ),
					  ``( lookup( part, "lvm_group", "") == vg ));

	    if (size(existing_pvs) > 0 )
	    {
				     
		map new_create_vg = $[
				      "use_module" : "lvm_ll",
				      "type"       : "create_vg",
				      "vgname"     : vg,
				      "pesize"     : pesize,
				      "devices"    : []
		];
		modify_targets = addTargetModification( modify_targets, new_create_vg );


		foreach(`pv, existing_pvs, ``{
		    map new_create_pv = $[
					  "use_module" : "lvm_ll",
					  "type"       : "create_pv",
					  "vgname"     : vg,
					  "device"     : pv["device"]:""							       
		    ];
		    modify_targets = addTargetModification( modify_targets, new_create_pv );
		});

		// LVs
				     
		list part = group["logical_volumes"]:[];
		list region 		= [0,0];
				   
		map new_volume = $[
				   "name"      : vg,
				   "cyl_count" : 0,
				   "cyl_size"  : pesize,
				   "is_lvm_vg" : true,
				   "partitions": []
		];
		list new_partitions = maplist(map lv, part, ``{

		    integer lv_size = kmgt_str_to_byte(lv["lv_size"]:"");
		    if (pesize == 0 )
		    {
			pesize = 1;
		    }

		    integer virtual_cyl_end   = lv_size / pesize;
		    region = [0, virtual_cyl_end ];
					 
		    integer bytes_of_part = 0;
		    integer cyl_size   = pesize;
		    integer nb_cyl = select (region, 1, 0 );
					 
		    bytes_of_part =  ( nb_cyl ) * cyl_size;
					
		    map new_create_lv = $[
					  "use_module" : "lvm_ll",
					  "type"       : "create_lv",
					  "name"       : lookup(lv, "lv_name", ""),
					  "size"       : bytes_of_part,
					  "vgname"     : vg,
					  "stripes"    : 1,
					  "order"	     : 3
		    ];
		    modify_targets = addTargetModification( modify_targets, new_create_lv );
					 
		    return ($[
			      "create"	: true,
			      "fs_options" : $[] ,
			      "use_module" : "lvm_ll",
			      "fsid"   : 142,
			      "fstype" : "LV",
			      "nr"     : lookup(lv, "lv_name", ""),
			      "ori_nr"	: lookup(lv, "lv_name", ""),
			      "region" : [0, virtual_cyl_end ],
			      "size_bytes":  bytes_of_part,
			      "mount"  : lookup( lv, "lv_mount", ""),
			      "used_fs": StringFS2Symbol(lookup(lv, "lv_fs","ext2")),
			      "format" : lookup( lv, "lv_format" , true),
			      "crypt_fs" : lookup( lv, "lv_crypt", false ),
			      "crypt_key":"",
			      "type"   :`lvm,
			      "device" : "/dev/" + vg + "/" + lookup(lv, "lv_name", "")
			    ]);
		});
				     
		Storage::SetModifyTargets( modify_targets );
		new_volume = change(new_volume, "partitions", new_partitions);
		LvmVolumes = add(LvmVolumes, "/dev/" + vg, new_volume);
	    }
	});
	
	if (LvmVolumes!= $[])
	{
	    map new_targetMap = union(Storage::GetTargetMap(), LvmVolumes);
	    Storage::SetTargetMap(new_targetMap);
	}
    }


    /**
     * Create RAID
     *
     */
    global define autoRAID()
	``{
	list RaidList =  maplist (map device, AutoInstall::RAID,
				  ``{

				      string chunk_size = "4";
				      string raid_type = device["raid_level"]:"raid1";
				      if ( raid_type == "raid5" ) chunk_size = "128";
				      if ( raid_type == "raid0" ) chunk_size = "32";
				      string sel_chunksize = device["chunk_size"]:"";
				      if ( sel_chunksize != "" )
				      {
					  chunk_size = sel_chunksize;
				      }

				      
				      if(  raid_type == "raid5" && device["parity_algorithm"]:"" == "" )
				      {
					  device["parity_algorithm"] = "left-symmetric";
				      }

				      device["nr"] =tointeger(substring(device["raid_device"]:"/dev/md0", 7));
				      
				      
				      device["device"]		= device["raid_device"]:"/dev/md0";
				      device["fsid"] 		= device["partition_id"]:Partitions::fsid_native;
				      device["region"] 		= [0 , 1];
				      device["create"] 		= true;
				      device["status"] 		= "create";
				      device["raid_type"] 	= device["raid_level"]:"raid1";
				      device["chunk_size"]	= chunk_size;
				      
				      if (!haskey(device, "format"))
				      {
					  device["format"] 	= false;
				      }
				      
				      symbol selected_fs 	= StringFS2Symbol(device["filesystem"]:"");				      
				      
				      device["used_fs"] 	= selected_fs;
				      device["type"]		= `sw_raid;
				   
				      return(device);
				  });

	map RaidMap = $[ "/dev/md" :
			 $[
			   "cyl_count" : 1,                         // typicall 1 
			   "cyl_size" : 1048576 * 2,                    // const 1MB
			   "name" : "Linux Software RAID",
			   "partitions" : RaidList
			 ]
	];
	y2milestone("RaidMap: %1", RaidMap);
	
	map new_targetMap = union(Storage::GetTargetMap(), RaidMap);
	Storage::SetTargetMap(new_targetMap);
	y2milestone("Targets: %1", Storage::GetTargetMap());
    }


    
    /**
     * Caclculate new Region
     * @param map partition map
     * @param list region list
     * @return list new region
     */
    global define calcRegion(map currentPartition, list region )
	``{
	integer units = 0;
	string psize = "";
	if (size(currentPartition["region"]:[]) == 0 )
	{	    
	    psize = currentPartition["size"]:"";
	}
	
	string mount_point = currentPartition["mount"]:"";
	list autoRegion = currentPartition["region"]:[];
	
	if (psize!= "" && psize!="auto" && psize != "max")
	{
	    units = size_to_units(kmgt_str_to_byte(psize));
	    if (units == 0) 
	    {
		units = end_of_region (selected_region) - end_of_region (region);
	    }
	}
	else if (psize == "auto") 
	{
	    if (mount_point == "/boot") 
	    {
		units = size_to_units (size_of_boot);
	    }
	    else if  (mount_point == "swap")
	    {
		units = size_to_units (size_of_swap);
	    }
	    else {
		units = end_of_region (selected_region) - end_of_region (region);
	    }
	}
	else if (psize == "max")
	{
	    units = end_of_region (selected_region) - end_of_region (region);		
	}
	else if (psize == "" && size(autoRegion)>0)	    
	{
	    return autoRegion;
	}

	
	if (select(region,1, -1)==0)
	{
	    region = [select(selected_region, 0, 0), units];
	}
	else
	{
	    region = [ end_of_region(region), units];
	}
	return region;
    }
    
    /**
     * StringFS2Symbol()     
     * @param any filesystem string
     * @return symbol filesystem type
     */
    global define StringFS2Symbol(any fs)``{
	if (is(fs,symbol)) {
	    return fs;
	}

	map filesystems =
	    $[
	      "ext2":	`ext2,
	      "ext3":	`ext3,
	      "reiser":	`reiser,
	      "lvm":	`lvm,
	      "raid":	`raid,
	      "jfs":	`jfs,
	      "fat32":	`fat32,
	      "xfs":	`xfs,
	      "fat16":	`fat16,
	      "swap":	`swap	
	];
	return filesystems[fs]:Partitions::default_fs;	
  }

    global define integer InitDevice(string del_device)
	``{
	
	string zero_string = sformat( "/bin/dd if=/dev/zero of=%1 bs=2k count=100", del_device );
	integer ret_zero   = SCR::Execute(.target.bash, zero_string );
	integer ret_reread = SCR::Execute(.target.bash, sformat("/sbin/blockdev --rereadpt %1", del_device ));
	y2milestone( "Partitiontable of device %1 deleted (%2-%3)", del_device, ret_zero, ret_reread);
	return (ret_zero + ret_reread);
    }

}
