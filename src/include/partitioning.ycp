/**
 * File:		autoinstall/partitioning.ycp
 * Module:		Autoinstallation
 * Authors:             Anas Nashif <nashif@suse.de>
 * Purpose:		functions for partitioning in autoinst mode
 *
 *
 * $Id$
 */

{
    include "partitioning/auto_part_functions.ycp";
    include "partitioning/auto_part_prepare.ycp";
    include "partitioning/auto_part_create.ycp";
    include "partitioning/auto_finish.ycp";   
    include "partitioning/partition_defines.ycp";
    include "partitioning/auto_part_ui.ycp";
    include "partitioning/partition_defines.ycp";
    
    textdomain "autoinst";


    /**
     *  Determine how and where the partitions are added in autoinst mode
     *  modifies targetMap with new partition list for the specified device
     *  @param device name of the target drive
     *  @return true on success
     */
    global define boolean AutoPartition (string TargetDevice)
	``{

	// For compatibility
	string target_is = TargetDevice;
	
	// find the selected target in the map of all possible targets
	map driveMap =  Storage::GetTargetMap();

	// description of the choosen target disk
	map target = driveMap[TargetDevice]:$[];

	if (target == $[])
	{
	    Report::Error(_("The device configured in the control file does not
exist on this system.
"));
	    return false;
	}

	// The current list of partitions
	list partitions = target["partitions"]:[];

	integer max_partitions = compute_max_partitions (target);

	// The number of possible primary partitions
	integer max_primary = Partitions::MaxPrimary( target["label"]:"" );


	// The partition number of the first logical partition
	integer first_logical_nr = max_primary + 1;

	list full_region = [];

	integer bytes_per_unit = 0;
	integer disk_size = 0;

	// fdisk partition ids
	integer	fsid_boot	= Partitions::FsidBoot();
	integer	fsid_root	= Partitions::fsid_native;

	// How much to allocate for swap
	integer size_of_swap	= 1024 * 1024 * Partitions::SwapSizeMb(0);

	// calculate size of the /boot partition
	integer size_of_boot = Partitions::MinimalNeededBootsize();

	// this will tell if automatic partitioning if feasible
	boolean can_do_auto = false;

	// this will get the minimal size for a default system
	//   (boot + swap + default root)
	integer minimal_size = 0;

	list unused_region = [ 0, 0 ];

	/**
	 * prepare_partitions
	 */

	boolean partitions_defined = false;
	if (size(target["partitions"]:[]) > 0)
	{
	    partitions_defined = true;
	}

	string no_space_reason = sformat(_("No free space available on %1"), TargetDevice);

	partitions = prepare_partitions (target, partitions);

	boolean already_partitioned = false;
	boolean root_created = false;
	string use = "";
	map AutoTarget = AutoinstStorage::AutoTargetMap[TargetDevice]:$[];

	if ( haskey( AutoTarget  , "use"))
	{
	    use = AutoTarget["use"]:"";
	}

	if (use == "linux")
	{
	    list linuxp = [];
	    if( Storage::IsRealDisk( TargetDevice, target ) )
	    {
		list l = filter( map `p, target["partitions"]:[],
				 ``(!p["delete"]:false &&
				    !p["format"]:false &&
				    Partitions::IsLinuxPartition(p["fsid"]:0)) );
		
		l = filter( `p, l, ``(contains( [`xfs, `ext2, `ext3, `jfs, `reiser, `swap],
						p["used_fs"]:`unknown)));
		l = filter( `p, l, ``(!contains( FileSystems::system_m_points,
						 p["mount"]:"" )));
		
		if( size(l)>0 )
		{
		    linuxp = union( linuxp, l );
		}
	    }

	    list lp = [];
	    
	    string seq = "1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19";
	    
	    integer s = size(target["partitions"]:[]);
	    
	    if ( size (linuxp ) > 0 )
	    {
		lp = maplist(map p, linuxp, ``{
		    return(sformat("%1", p["nr"]:-1));
		});		
		use = mergestring(lp, ",");		
		if (!contains(lp, target["partitions", s-1, "nr"]:0 ) || !issubstring(seq, use ) )
		{		
		    use = "none";
		    Report::Error(no_space_reason);
		    return (false);
		}		
	    }
	    else
	    {
		use = "none";
	    }
	    y2milestone("Using linux partitions only: %1", use );
	}


	// First check if free space should be used
	//	

	if ( (num_primary ( partitions ) > 0) || contains_extended ( partitions ) )
	{
	    already_partitioned = true;

	    // If there is an unpartitioned area on the disk, check if it should be used.
	    // (this will automatically partition this area)

	    if ( can_do_auto && use == "free")
	    {
		y2milestone("Using free space only");
		if (!partitions_defined
		    && !root_created
		    && unused_region[1]:0 != 0)
		{
		    partitions = create_partitions (target, partitions, unused_region);
		    root_created = true;
		}
		else if ( unused_region[1]:0 != 0 )
		{
		    partitions = CreatePartitions (partitions, unused_region, target["label"]:"");
		}
		else if ( unused_region[1]:0  == 0)
		{
		    Report::Error(no_space_reason);
		    return (false);
		}


		if (!SaneRegionLimits( unused_region, partitions) )
		{
		    Report::Error(no_space_reason);
		    return (false);
		}

		rewrite_settings (partitions, target, driveMap);
		auto_undefine ();
		return (true);
	    }
	    else if ( unused_region[1]:0  == 0 && use == "free" )
	    {
		Report::Error(no_space_reason);
		return (false);
	    }
	}
	else
	{
	    // no partitions found
	    y2milestone ("Partitioning whole disk");
	    Storage::SetWholeDisk( true );
	}

	boolean ok = false;
	while (true)
	{
	    if (!already_partitioned)
	    {
		if (!partitions_defined
		    && !root_created)
		{
		    partitions = create_partitions (target,partitions, unused_region);
		    root_created = true;
		}
		else
		{
		    partitions = CreatePartitions (partitions, unused_region, target["label"]:"" );
		}
		rewrite_settings (partitions, target, driveMap);
		if (size(partitions) > 0 )
		{
		    ok = true;
		}
		break;
	    }

	    // The partitions that remain untouched.
	    list old_partitions = [];

	    // The partitions that are deleted.
	    list selected_partitions = [];

	    // The union of both lists.
	    list all_partitions = [];

	    map extended_pentry = $[];

	    list KeepPartitions = [];
	    
	    boolean StrictMode = false;

	    list AutoPartitions = maplist (map part , AutoinstStorage::AutoTargetMap[TargetDevice, "partitions"]:[],
		     ``{
		if ( haskey(part, "create") && !part["create"]:true  && part["partition_nr"]:-1 != -1 )
		{
		    KeepPartitions = add( KeepPartitions, part["partition_nr"]:-1);
		    part["kept"] = true;
		    y2milestone("Keeping Partition: %1", part);
		}
		else if (  haskey (part, "create")   &&  !part["create"]:true  && part["partition_id"]:-1 != -1 )
		{
		    /*
		      No partition numbers given, so we can't delete any partition.
		      We will look for first partition of this type and use it, if required, format it and mount
		      it as described in the control file. If no partitions of this type are available, they will be
		      ignored.
		    */	
		    StrictMode = true;
		    use = "none";

		    part["kept"] = true;
		}
		return (part);
	    });

	    list SelectedPartitions = [];
	    if (use!= "" && use != "all" && use != "free" && use != "none")
	    {
		y2milestone("Using only selected partitions");
		list selected_partitions = [];
		list tmp_selpart = splitstring(use, ",");

		SelectedPartitions = maplist (`p, tmp_selpart, ``{
		    if  ( findfirstnotof( p, "0123456789") == nil  )
		    {
			return(tointeger(p));
		    }
		});
	    }

	    // now loop through partitions
	    boolean creating_anything = false;

	    foreach (`pentry, partitions, ``{
		
		y2milestone("Working on %1", pentry);
		
		symbol ptype = pentry["type"]:`unknown;

		if (ptype != `extended)
		{
		    boolean to_be_deleted = false;
		    
		    // STRICT Mode: No partitions are deleted or re-created
		    if (StrictMode)
		    {
			pentry["create"] = false;
			foreach (map autopart , AutoPartitions , ``{
			    if (pentry["fsid"]:-1 == autopart["partition_id"]:-2)
			    {
				string dev = Storage::GetDeviceName( TargetDevice, pentry["nr"]:0 );
				y2milestone( "STRICT MODE: Auto-partitioning device: %1", dev );
				if ( pentry["format"]:false)
				{
				    symbol detected_fs = pentry["detected_fs"]:`reiser;
				    pentry["used_fs"] = AutoinstStorage::StringFS2Symbol( autopart["filesystem"]:detected_fs);
				}
				else
				{
				    pentry["used_fs"] = FileSystems::DetectFs( dev );
				}
				string mntpoint = "";
				if (pentry["used_fs"]:`unknown != `unknown )
				    mntpoint = sformat("/data%1", pentry["nr"]:0);

				pentry["mount"] = autopart["mount"]:mntpoint;
				pentry["format"] = autopart["format"]:false;

				if ( autopart["lvm_group"]:"" != "" )
				{
				    pentry["lvm_group"]	=  autopart["lvm_group"]:"";
				}
				pentry["kept"] = true;
			    }
			    else
			    {
				y2milestone("No match -  existing %1, new %2", pentry["fsid"]:-1, autopart["partition_id"]:-2 );
			    }
			});
		    } // Strict mode
		    else if ( use == "all")
		    {
			to_be_deleted = true;
			creating_anything = true;
		    }
		    else if (CheckDeleteTag(pentry, AutoPartitions))
		    {
			to_be_deleted = true;
			creating_anything = true;
		    }
		    else if ( contains (SelectedPartitions, pentry["nr"]:-1) )
		    {
			to_be_deleted = true;
			creating_anything = true;
		    }
		    else if ( contains(KeepPartitions, pentry["nr"]:-1) )
		    {
			map drive = AutoinstStorage::AutoTargetMap[TargetDevice]:$[];
			list newautoparts = maplist(map autopart , AutoPartitions , ``{
			    if (autopart["partition_nr"]:-2 == pentry["nr"]:-1)
			    {
				string mntpoint = "";
				pentry["create"] = false;
				pentry["format"] = autopart["format"]:false;
				string dev = Storage::GetDeviceName( TargetDevice, pentry["nr"]:0 );
				if ( pentry["format"]:false)
				{
				    symbol detected_fs = pentry["detected_fs"]:`reiser;
				    pentry["used_fs"] = AutoinstStorage::StringFS2Symbol(  autopart["filesystem"]:detected_fs);
				}
				else
				{
				    pentry["used_fs"] = FileSystems::DetectFs( dev );
				}
				
				if (pentry["used_fs"]:`unknown != `unknown )
				    mntpoint = sformat("/data%1", pentry["nr"]:0);

				pentry["mount"] = autopart["mount"]:mntpoint;
				pentry["kept"] = true;
				autopart["kept"] = true;

				if ( autopart["lvm_group"]:"" != "" )
				{
				    pentry["lvm_group"]	=  autopart["lvm_group"]:"";
				}
			    }
			    return (autopart);
			});
			drive["partitions"] = newautoparts;
			AutoinstStorage::AutoTargetMap[TargetDevice] = drive;

		    }

		    // Mark for deletion
		    pentry["delete"] =  to_be_deleted;

		    if (!to_be_deleted)
		    {
			// Read extended partition if any logical partitions
			// remain
			if ((ptype == `logical)
			    && (size (extended_pentry) > 0))
			{
			    old_partitions = add (old_partitions, extended_pentry);
			    all_partitions = add (all_partitions, extended_pentry);
			    extended_pentry = $[];
			}

			old_partitions = add (old_partitions, pentry);
		    }
		    else
		    {
			pentry["old_raid_name"] =  pentry["raid_name"]:"";
			pentry["raid_name"] = "";			
			selected_partitions = add (selected_partitions, pentry);
		    }
		    all_partitions = add (all_partitions, pentry);
		}
		else
		{
		    extended_pentry = pentry;
		}
	    });
	    // There are no logical partitions left, mark the extended
	    // partition for deletion
	    if (size (extended_pentry) > 0)
	    {	
		extended_pentry = add (extended_pentry, "delete", true);
		all_partitions = add (all_partitions, extended_pentry);
	    }

	    y2milestone ("All Partitions (all_partitions) : '%1'", all_partitions);
	    y2milestone ("Partitions to delete (selected_partitions) : '%1'", selected_partitions);
	    y2milestone ("Partitions to keep (old_partitions) : '%1'", old_partitions);

	    // Check selection for plausability

	    string reason = "";
	    list selected = [];

	    if (!contiguous_selection (selected_partitions))
	    {
		// consistency check: a condition for the installation is not fullfilled
		// this condition is described within the reason
		reason = _("The selected partitions are not contiguous.");
	    }
	    else if (contains_extended (old_partitions) && creating_anything)
	    {
		selected = calculate_selected_region (selected_partitions, extended_region (old_partitions));

		if (!can_create_logical (old_partitions))
		{
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described within the reason
		    reason = _("Too few partitions are marked for removal.
To install Linux, select more partitions to remove.");
		}
		else if (size_of_region (selected) < minimal_size  )
		{
		    y2milestone("selected: %1", selected);
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described within the reason
		    reason = _("The selected partitions are not big
enough to contain a minimal installation.");
		}
		else
		{
		    ok = true;
		    if (!bootable (selected))
			warn_not_bootable ();
		}
	    }
	    else if ( ( ( num_primary (old_partitions) == max_primary ) &&  creating_anything )
		     || ((target["label"]:""=="bsd" || target["label"]:""=="sun")
			 && (size (old_partitions) - size (selected_partitions) + 3 >= max_partitions)))
	    {
		// consistency check: a condition for the installation is not fullfilled
		// this condition is described within the reason
		reason = _("Too few partitions are marked for removal.
To install Linux, select more partitions to remove.");
	    }
	    else
	    {
		selected = calculate_selected_region (selected_partitions, nil);
		if (size_of_region (selected) < minimal_size && creating_anything)
		{
		    y2warning ("selected: %1", selected); // FIXME
		    // consistency check: a condition for the installation is not fullfilled
		    // this condition is described by the reason
		    reason = _("The selected partitions are not big enough
to contain a minimal installation.");
		}
		else
		{
		    ok = true;
		    if (!bootable (selected))
		    {
			warn_not_bootable ();
		    }
		}
	    }

	    if (ok)
	    {
		if (!partitions_defined
		    && !root_created)
		{
		    partitions = create_partitions (target, all_partitions, selected);
		    root_created = true;
		}
		else
		{
		    partitions = CreatePartitions (all_partitions, selected, target["label"]:"" );
		    if (!SaneRegionLimits( selected, partitions) )
		    {
			Report::Error(no_space_reason);
			ok = false;
			break;
		    }
		}
		y2milestone("Final partitions %1", partitions);
		rewrite_settings (partitions, target, driveMap);
		break;
	    }
	    Report::Error(reason);
	    break;

	} // while (true)
	y2milestone("returning=%1", ok );
	return (ok);
    }


    /**
     * CheckDeleteTag
     */

    global define CheckDeleteTag (map e, list a) ``{
	boolean delete = false;
	foreach (map p , a , ``{
	    if (p["partition_nr"]:-1 == e["nr"]:-2 && !delete) {
		delete = p["delete"]:false;
	    }
	});
	return (delete);
    }
    
    /**
     * Get number of last primary partition
     * @param list partition list
     * @return integer partition number
     */
    global define integer getLastPrimary(list p)``{
	list used_primaries =
	    maplist (`pentry,
		     filter (`pentry, p, ``(!pentry["delete"]:false)),
		     ``(pentry["nr"]:0)
		     );

	integer unused = 1;

	while (contains (used_primaries, unused))
	{
	    unused = unused + 1;
	}
	y2milestone("Using primary: %1", unused);
	return unused;
    }

    /**
     * SaneRegionLimits
     */ 

    global define SaneRegionLimits (list unused,  list partitions) ``{
	
	map lastPart = select(partitions, size(partitions) -1 , $[]);
	y2milestone("last partitions = %1", lastPart );
	list last_region = [  lastPart["region", 0 ]:0  , lastPart["region", 1]:0 ];

	y2milestone("last=%1, unused=%2", end_of_region(last_region) , end_of_region(unused) );

	if ( end_of_region(last_region) > end_of_region(unused)  && end_of_region(unused) != 0 )
	{
	    return false;
	}
	return true;
    }


    /**
     *	Create partitions defined in the Profile
     *	@param list of available partitions on the drive
     *  @param Region on drive where new partitions are added
     *  @param label
     *  @return new partitions list
     */

    global define CreatePartitions (list partitions, list selected_region, string label)
	``{

	y2milestone("Initial partition list: %1", partitions);
	y2milestone("Selected region: %1", selected_region);

	recalculateSizes(selected_region);

	partitions = filter (`pentry,
			     partitions,
			     ``(pentry["type"]:`unknown != `free)
			     );	
	
	partitions = renumber_logical_partitions (partitions);

	// y2milestone("partition list after renumbering: %1", partitions);

	symbol ptype = `primary;
	integer last_pnr = 0;

	list region = [0,0];

	if (selected_region[0]:0 != 0 )
	{
	    list old = filter (`pentry,
			       partitions,
			       ``(!pentry ["delete"]:false)
			       );

	    if ( size(old) > 0 )
	    {
		map lastPart = select(old, size(old) -1 , $[]);
		region = [  lastPart["region", 0 ]:0  , lastPart["region", 1]:0 ];
	    }

	}


	list root_region = [ 0 , 0 ];
	boolean empty_disk = (partitions == []);

	map absd_partition =
	    $[
	      "create":true,
	      "format":true,
	      "type": `primary,
	      "fsid":Partitions::fsid_empty,
	      "nr":3,
	      "region":full_region
	    ];

	// Get new partitions as specified in control file
	list TmpAutoPartitions =  AutoinstStorage::AutoTargetMap[TargetDevice, "partitions"]:[];

	list AutoPartitions = filter (`pentry,
				      TmpAutoPartitions ,
				       ``(!pentry["kept"]:false )
				       );

	// First create any primary partitions if requested in control file.

	list primaries = filter (`pentry, AutoPartitions,
				 ``(
				    ( pentry["partition_type"]:"none" == "primary"
				      || pentry["partition_nr"]:99 < Partitions::MaxPrimary(label) )
				    && pentry["partition_id"]:-1 != 15
				    && pentry["partition_id"]:-1 != 5
				    && pentry["create"]:true 
				    )
				 );
	
	if ( size (primaries) > 0 )
	{
	    y2milestone("Primary partitions needed");
	    list tmp_p = partitions;
	    last_pnr = getLastPrimary(partitions);
	    
	    list PrimaryAutoPartitions = maplist(`p, primaries,   ``{
		if ((label=="bsd" || label=="sun")
		    && (last_pnr == 3))
		{
		    last_pnr = last_pnr + 1;
		}
		map newPart = addPartition(p);
		tmp_p = union(tmp_p, [newPart]);
		last_pnr = getLastPrimary(SortPartitions(tmp_p));
		return (newPart);
	    });
	    last_pnr = last_pnr - 1;
	    partitions = union(partitions , PrimaryAutoPartitions);
	}

	// Filter primaries
	AutoPartitions = filter(`pentry, AutoPartitions,
				``( ! (
				       (
					pentry["partition_type"]:"none" == "primary"
					|| pentry["partition_nr"]:99 < Partitions::MaxPrimary(label)
					)
				       &&  pentry["partition_id"]:-1 != 15
				       &&  pentry["partition_id"]:-1 != 5
				       )
				    )
				);

	y2milestone("Partitions up to now: %1", partitions);
	y2milestone("Pending Partitions: %1", AutoPartitions);

	if ( size(AutoPartitions) == 0)
	{
	    return (partitions);
	}

	if (label == "msdos")
	{
	    ptype = `logical;
	}
	else
	{
	    // If we don't have a FAT partition type get the
	    // last used partition number
	    integer unused_primary_pnr = getLastPrimary(partitions);
	    last_pnr = unused_primary_pnr - 1;
	}


	// Add the extended partition if necessary

	if (ptype == `logical)
	{
	    if (!contains_extended (partitions))
	    {
		integer unused_primary_pnr = getLastPrimary(partitions);
		// create new extended partition
		// if it starts above cyl 1024, create it as fsid_extended_win

		integer ext_fsid = Partitions::fsid_extended;
		if (start_of_region (selected_region) >= 1024)
		{
		    ext_fsid = Partitions::fsid_extended_win;
		}
		list extended = filter (`pentry, AutoPartitions,
					``(
					   (
					    pentry["partition_type"]:"none" == "extended"
					    || pentry["partition_id"]:0 == 15
					    || pentry["partition_id"]:0 == 5))
					);

		list extended_region = [ 0 , 0 ];

		if ( size(extended) == 1 )
		{
		    y2milestone("Extended found");
		    extended_region = extended[0, "region"]:[];
		    
		    map ExtendedPartition = extended[0]:$[];
		    if (haskey(ExtendedPartition, "partition_id"))
		    {
			ext_fsid = ExtendedPartition["partition_id"]:ext_fsid;
		    }
		    
		    if (extended_region == [] )
		    {
			extended_region = calcRegion(extended[0]:$[], region);
		    }
		    region  = extended_region;

		    y2milestone("Extended region: %1 - Region: %2", extended_region, region);

		    AutoPartitions = filter(`pentry, AutoPartitions,
					    ``(!(pentry["partition_type"]:"none" == "extended"
						 || pentry["partition_id"]:0 == 15
						 ||  pentry["partition_id"]:0 == 5))
					    );	
		    selected_region = extended_region;
		}
		else
		{
		    extended_region =  [ end_of_region(region), end_of_region(selected_region) -  end_of_region(region)];
		}
		y2milestone("Adding extended partition to: %1",partitions);
		
		partitions = add (partitions,
				  $[
				    "create":true,
				    "type":`extended,
				    "fsid":ext_fsid,
				    "nr":unused_primary_pnr,
				    "region": extended_region,
				    "device": get_device_name(TargetDevice, unused_primary_pnr)
				  ]);
		y2milestone("Partitions including extended: %1", partitions);

		last_pnr = max_primary;
	    }
	    else
	    {
		// Find the last used logical partition number.
		// We know that these partitions are numbered contiguously

		last_pnr = first_logical_nr - 1;
		foreach (`pentry, partitions, ``{

		    if (!pentry["delete"]:false
			&& (pentry["type"]:`unknown == `logical))

		    {
			last_pnr = pentry["nr"]:0;
		    }
		});
	    }
	} // ptype == `logical


	last_pnr = last_pnr + 1;


	list LogicalAutoPartitions = maplist(`p, AutoPartitions,
					       ``{
						   if ((label == "bsd" || label == "sun")
						       && (last_pnr == 3))
						   {
						       last_pnr = last_pnr + 1;
						   }
						   map newPart = addPartition(p);
						   last_pnr = last_pnr + 1;
						   return(newPart);
					       });

	// Add flag whether using the entire disk

	if ((label == "bsd" || label == "sun")
	    && (last_pnr == 3)
	    && empty_disk)
	{
	    partitions = add (partitions, absd_partition);
	}

	Storage::SetWholeDisk( selected_region == full_region);

	list finalPartitions =  union(partitions,LogicalAutoPartitions);

	y2milestone("FINAL Partitions: %1", finalPartitions);
	return( finalPartitions );

    }; // CreatePartitons





    /**
     * Create a partition
     * @param currentPartition partition data as specified in control file
     * @return map partition data ready
     */

    global define map addPartition(map currentPartition) ``{

	string mount_point = currentPartition["mount"]:"";

	region = calcRegion(currentPartition, region);

	integer auto_fsid = currentPartition["partition_id"]:Partitions::fsid_native;

	// LVM
	string lvm_group = currentPartition["lvm_group"]:"";


	// Raid
	string raid_name = currentPartition["raid_name"]:"";


	// Partition Template
	map part =
	    $[
	      "create":	true,
	      "format":	currentPartition["format"]:true,
	      "fs_options": currentPartition["fs_options"]:$[],
	      "type":	ptype,
	      "fsid":	auto_fsid,
	      "nr":	last_pnr,
	      "region":	region,
	      "mount":	mount_point,
	      "device": get_device_name(TargetDevice, last_pnr)
	    ];

	if (currentPartition["loop_fs"]:false || currentPartition["crypt_fs"]:false)
	{
	    part["loop_fs"]  =    currentPartition["loop_fs"]:false;
	    part["crypt_key"] =   Storage::AddCryptToClassified( currentPartition["crypt_key"]:"");
	    part["crypt"] =		currentPartition["crypt"]:"twofish";
	}

	if (haskey(currentPartition, "fstopt") && currentPartition["fstopt"]:"" != "")
	{
	    part["fstopt"]		= currentPartition["fstopt"]:"";
	}

	if (haskey(currentPartition, "label") && currentPartition["label"]:"" != "")
	{
	    part["label"]		= currentPartition["label"]:"";
	}

	if (haskey(currentPartition, "mountby"))
	{
	    part["mountby"]	= currentPartition["mountby"]:`device;
	}


	if (mount_point == "swap" || AutoinstStorage::StringFS2Symbol(currentPartition["filesystem"]:"") == `swap)
	{
	    part["fsid"] =  Partitions::fsid_swap;
	    part["mount"] = "swap";
	}
	else if (mount_point == "/boot")
	{
	    if (currentPartition["partition_id"]:0 != 0)
	    {
		part["fsid"] =  currentPartition["partition_id"]:0;
	    }
	    else
	    {
		part["fsid"] =  fsid_boot;
	    }

	    symbol tmpfs = AutoinstStorage::StringFS2Symbol(currentPartition["filesystem"]:"none");
	    if (tmpfs != `none)
	    {
		part["used_fs"] = tmpfs;
	    }
	    else
	    {
		if (fsid_boot == Partitions::fsid_fat32)
		{
		    // for ia64, /boot is FAT32
		    part["used_fs"]:`fat32;
		}
	    }
	}
	else if (mount_point == "/")
	{
	    root_region=region;
	    part["used_fs"] =  AutoinstStorage::StringFS2Symbol(currentPartition["filesystem"]:"reiser");
	}
	else if (lvm_group != "")
	{
	    Storage::SetLvmUse( true );

	    part["used_fs"]		=  `unknown;
	    part["fsid"]		=  Partitions::fsid_lvm;
	    part["format"]		=  false;
	    part["lvm_group"]		=  lvm_group;
	    part["mount"]		=  "";
	    part["fstype"]		=  "Linux LVM";
	}
	else if (raid_name != "")
	{
	    any nr = substring(raid_name, 7);

	    part["used_fs"]		= `unknown;
	    part["fsid"]		= Partitions::fsid_raid;
	    part["format"]		= false;
	    part["raid_name"]	= raid_name;
        part["raid_type"]   = currentPartition["raid_type"]:"raid";
	    part["mount"]		= "";
	    part["fstype"]		= "Linux RAID";

	}
	else
	{
	    part["used_fs"] = AutoinstStorage::StringFS2Symbol(  currentPartition["filesystem"]:"reiser");
	}

	y2milestone("Adding partition: %1", part);

	return part;
    }



    /**
     * Racalculate sizes
     *
     */
    global define void recalculateSizes ( list region )
	``{
	integer totalsize = size_of_region (region);
	y2milestone("Total available space: %1", totalsize);

	// Get new partitions as specified in control file
	list TmpAutoPartitions =  AutoinstStorage::AutoTargetMap[TargetDevice, "partitions"]:[];

	list AutoPartitions = filter (`pentry,
				       TmpAutoPartitions ,
				       ``(!pentry["kept"]:false )
				       );
	string psize = "";
	integer realsize = 0;
	integer maxsize = 0;
	boolean grow = false;
	integer min = 0;
	integer max = 0;
	string mount_point = "";
	integer ratio = 0;
	boolean region_active = false;
	boolean grow_possible  = true;

	foreach(map part, AutoPartitions, ``{
	    if (size(part["region"]:[]) == 0 )
	    {
		psize = part["size"]:"";
		mount_point = part["mount"]:"";
		ratio = part["ratio"]:0;

		if (part["maxsize"]:"" != "")
		{
		    maxsize = kmgt_str_to_byte(part["maxsize"]:"");
		}

		grow =  part["grow"]:false;
	    }
	    else
	    {
		realsize = size_of_region (part["region"]:[] );
		region_active = true;
	    }

	    if (psize == "auto")
	    {
		if (mount_point == "/boot")
		{
		    realsize = size_of_boot;
		}
		else if  (mount_point == "swap")
		{
		    realsize = size_of_swap;
		}
	    }
	    else if ( psize != "" && psize != "max" )
	    {
		realsize = kmgt_str_to_byte(psize);
	    }
	    else if (ratio != 0 )
	    {
		integer tmp_size = totalsize * ( ratio / 100);
		if (maxsize > 0 )
		    realsize = maxsize;
		else
		    realsize = tmp_size;
	    }
	    else if (!region_active )
	    {
		realsize = 0;
	    }


	    min = min + realsize;
	    max = max + maxsize;
	    region_active = false;
	    maxsize = 0;
	    realsize = 0;
	});


	y2milestone("Minimal size: %1 - Maximal size: %2", min, max);

	if (min < totalsize) {
	    y2milestone("Using default sizes is possible");
	}
	else
	{
	    y2milestone("Not enough space for default size!");
	}

	if (max < totalsize )
	{
	    y2milestone("Using maximal growable sizes is possible");
	    integer  number_of_partitions = size( AutoPartitions );
	    integer i = 1;
	    list npartitions = maplist(map part, AutoPartitions, ``{

		if ( part["maxsize"]:"" != "" && part["grow"]:false )
		{
		    part["size"] =  part["maxsize"]:"";
		}
		else if ( part["maxsize"]:"" == "" && part["grow"]:false && i == number_of_partitions)
		{
		    part["size"] = "max";
		}

		y2debug ("counter: %1, partitions: %2", i,  number_of_partitions);
		i = i + 1;
		return (part);
	    });
	    y2milestone("Partitions with new sizes: %1", npartitions);
	    map drive = AutoinstStorage::AutoTargetMap[TargetDevice]:$[];
	    drive["partitions"] = npartitions;
	    AutoinstStorage::AutoTargetMap[TargetDevice] = drive;
	}
	else
	{
	    y2milestone("Growing not possible");
	}


	return;
    }


    /**
     * Calculate new Region
     * @param map partition map
     * @param list region list
     * @return list new region
     */
    global define calcRegion(map currentPartition, list region )
	``{
	y2milestone("Region in=%1", region);
	integer units = 0;
	string psize = "";
	if ( size(currentPartition["region"]:[]) == 0 )
	{
	    psize = currentPartition["size"]:"";
	}

	string mount_point = currentPartition["mount"]:"";
	list autoRegion = currentPartition["region"]:[];

	if ( psize != "" && psize != "auto" && psize != "max" )
	{
	    units = size_to_units(kmgt_str_to_byte(psize));
	    if (units == 0)
	    {
		units = end_of_region (selected_region) - end_of_region (region);
	    }
	}
	else if (psize == "auto")
	{
	    if (mount_point == "/boot")
	    {
		units = size_to_units (size_of_boot);
	    }
	    else if  (mount_point == "swap")
	    {
		units = size_to_units (size_of_swap);
	    }
	    else
	    {
		units = end_of_region (selected_region) - end_of_region (region);
	    }

	}
	else if (psize == "max")
	{
	    units = end_of_region (selected_region) - end_of_region (region);
	   
	    y2milestone("units: %1", units);
	}
	else if ( psize == ""  &&  size(autoRegion) > 0 )
	{
	    return autoRegion;
	}


	if ( region[1]:-1 == 0 )
	{
	    region = [ selected_region[0]:0 , units];
	}
	else
	{
	    region = [ end_of_region(region), units];
	}
	y2milestone("Region=%1", region);
	return region;
    }



    global define list SortPartitions(list p) ``{
	p = sort( `p1, `p2, p,
			   ``(start_of_region (p1["region"]:[])
			      <= start_of_region(p2["region"]:[])));
	return (p);	
    }

}
