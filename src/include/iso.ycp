/**
 * File:	include/autoinstall/iso.ycp
 * Package:	Autoinstallation Configuration System
 * Summary:	ISO creation
 * Authors:	Anas Nashif<nashif@suse.de>
 *
 * $Id$
 */

{
    textdomain "autoinst";

    import "Label";

    /**
     * Compute packages needed for autoinstallation
     * @return list packages
     */

    global define list autoinstPackages(list packageList, string kernel )
	``{

	map configure = Profile::current["configure"]:$[];
	list packages = [];

	packages = union (packages, packageList);

	if (size(kernel)==0)
	{
	    packages =union (packages, ["k_deflt", "k_athlon", "k_smp"]);
	}

	if (haskey(configure, "nis")) {
		map nis = configure["nis"]:$[];
		if (nis["start_nis"]:false)
			packages = add(packages, "ypbind");
		if (nis["start_autofs"]:false)
			packages = add(packages, "autofs");
	}

	if (haskey(configure, "ldapclient")) {
		map ldapclient = configure["ldapclient"]:$[];
		if (ldapclient["start_ldapclient"]:false)
			packages = union(packages, ["pam_ldap","nss_ldap"]);
	}

	if (haskey(configure, "nfs_server"))
	{
	    boolean start_nfsserver = configure["nfs_server", "start_nfsserver"]:false;
	    if (start_nfsserver)
		packages = union(packages, ["yast2-nfs-server", "nfs-utils"]);
	}

	if (haskey(configure, "inetd")) {
		map inetd = configure["inetd"]:$[];
		if (inetd["start_inetd"]:false)
			packages = add(packages, "inetd");
	}

	if (haskey(configure, "nisplus")) {
		map nisplus = configure["nisplus"]:$[];
		if (nisplus["start_nisplus"]:false)
			packages = add(packages, "nis-utils");
	}
	if (haskey(configure, "mail")) {
		map mail = configure["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			packages = add(packages, "postfix");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			packages = add(packages, "sendmail");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-sendmail");
		}
	}
	y2milestone("package list needed during auto-installation: %1", packages);
	return packages;
    }

    /**
     * Check profile for consistency
     */
    global define string checkProfile() ``{
	import "Profile";

	map software = Profile::Flat["software"]:$[];

	string base = software["base"]:"";
	list addons = software["addons"]:[];
	list packs  = software["packages"]:[];
	list postpacks  = software["post-packages"]:[];
	string kernel = software["kernel"]:"";


	string error_msg = "";

	if (base == "" && size( packs ) < 50)
	{
	    error_msg = _("Base selection not defined.");
	}
	else if (size(software) == 0)
	{
	    error_msg = _("Software resource not defined.");
	}
	return error_msg;
    }


    global define  getRpmPath(string pac, boolean full) ``{

	string dataDir	= ISO::productData["datadir"]:"./suse";

	list tok = splitstring( pac , " ");
	string pacname = "";
	if (full)
	    pacname = tok[0]:"error" + "-" + tok[1]:"1.0"  + "-" + tok[2]:"0" + "." + tok[3]:"noarch" + ".rpm";
	else
	     pacname = tok[0]:"error" +  ".rpm";
	string location = tok[3]:"noarch" + "/" + pacname;
	string localpath =  ISO::sourceDir + "/" + dataDir + "/" + location;

	return localpath;
    };

    /**
     * Check if selected packages are available
     */
    global define string checkPackageAvail() ``{

	string descrDir	= ISO::productData["descrdir"]:"suse/setup/descr";
	string dataDir	= ISO::productData["datadir"]:"./suse";
	string sourceDir	= ISO::sourceDir;
	string packDB		= descrDir + "/packages";
	Progress::Title(sformat(_("Checking for package database: %1"), packDB));

	string error_msg = "";
	if (SCR::Read(.target.size, sourceDir + "/" + packDB) == -1 ) {
	    error_msg = _("Package database not found.");
	}

	Progress::Title(_("Checking for package availability..."));

	list selPacs = Pkg::GetPackages (`selected , false);
	list failed = [];
	foreach(string pac, selPacs, ``{

	    integer pacsize = SCR::Read(.target.size, getRpmPath(pac, true));
	    integer pacsize1 = SCR::Read(.target.size, getRpmPath(pac, false));
	    if (pacsize == -1 && pacsize1 == -1)
	    {
		failed = add (failed, getRpmPath(pac, true));
	    }
	});
	ISO::missing_packages = failed;
	if (size(failed) > 0 )
	{
	    integer num = size(failed);
	    error_msg = sformat(_("%1 package not available.", "%1 packages not available.", num), num);
	}

	return error_msg;
    }


    /**
     * Set packages
     */

    global define boolean setPackages() ``{
	import "Profile";

	map _prof = Profile::current;

	map _conf = _prof["install"]:$[];
	map _soft = _conf["software"]:$[];

	string base = _soft["base"]:"";
	list addons = _soft["addons"]:[];
	list packs  = _soft["packages"]:[];
	list postpacks  = _soft["post-packages"]:[];
	string kernel = _soft["kernel"]:"";


	if (base!="")
	{
	    Pkg::SetSelection(base);
	}
	else
	{
	    Pkg::SetSelection("Minimal");
	}

	// Addons
	if (size(addons) > 0 )
	{
	    foreach(`s, addons, ``{
		Pkg::SetSelection(s);
	    });
	}

	packs = union(packs, postpacks);
	Pkg::DoProvide(autoinstPackages(packs, kernel));
	boolean ret = Pkg::ActivateSelections();
	Pkg::PkgSolve();

	return (ret);

    }


    /**
     * ISO size dialog
     *
     */
    global define isoSizeDialog(integer expectedSize, string filename)``{

	// heading
	string headline = _("Creating ISO File...");
	// message
	string message = _("This may take several minutes.");

	term contents = `HBox(
			   `HSpacing(1),
			   `HCenter (
				     `HSquash(
					      `VBox (
						     `HCenter (
							       `HSquash(
									`VBox(
									      `Left( `Heading( headline )),
									      `VSpacing(0.2),
									      `Left(`Label(message))
									      )
									)
							       ),
						     `VSpacing(0.2),
						     `DownloadProgress(ISO::isoFile, filename, expectedSize - 5000000),
						     `HSquash(
							      `PushButton(`id(`close), Label::CloseButton())
							      ),
						     `VSpacing(0.2)
						     )
					      )
				     ),
			   `HSpacing(1)
			   );



	if (UI::HasSpecialWidget(`DownloadProgress)) {
	    UI::OpenDialog(
			   contents
			   );
	    UI::UserInput();
	    UI::CloseDialog();
	}
	else
	{
	    showFeedback(iso_msg);
	    while (true) {
		integer expect = expectedSize - 1000000;
		integer isosize = SCR::Read(.target.size, ISO::isoFile);
		if (isosize > expect) {
		    break;
		}
		sleep (5);
	    }
	    clearFeedback();
	}

	return;
    }



    /**
     * Sequence for ISO
     */
    global define symbol isoSequence () ``{

	map iso_dlg =  $[
			    "verify"	:	``(isoDialog()),
			    "summary"	:	``(isoSummary()),
			    "options"	:	``(isoOptions()),
			    "create"	:	``(createISO() )
	];

	map sequence = $[
			 "ws_start" 	: "options",
			 "options"	: $[
					    `next	: "verify",
					    `abort	: `ws_finish
			 ],
			 "verify"	: $[
					    `next	: "summary",
					    `abort	: `ws_finish
			 ],
			 "summary"	: $[
					    `next	: "create",
					    `abort	: `ws_finish
					    ],
			 "create"	: $[
					    `next	: `ws_finish,
					    `abort	: `ws_finish
					    ]

	];
	// Translators: dialog caption
	string caption = _("Custom ISO Image");
	term contents = `Label (_("Initializing ..."));

	Wizard::CreateDialog ();
	Wizard::SetContents ( caption,
			      contents,
			      "",
			      true,
			      true);


	any ret = WizardSequencer (iso_dlg, sequence);

	Wizard::CloseDialog ();
	return ret;
    }



    /**
     * ISO Options
     */
    global define isoOptions()``{

	// caption
	string caption = _("ISO Options");
	// help
	string help= _("Enter the desired name of the ISO image to create and
select any of the listed options.
");

	term contents =
	    `Top(
		 `VBox(
		       `HBox(
			     `TextEntry(`id(`file), _("Save ISO &File as:"), ISO::isoFile)
			     )
		       )
		 );

	Wizard::SetContents ( caption,
			      contents,
			      help,
			      true,
			      true);

	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();
		if ( ret == `next)
		{
		    string f  = UI::QueryWidget(`id(`file), `Value);
		    if (   f == "" || f == nil)
		    {
			Popup::Error(invalidFileName());
			continue;
		    }
		    ISO::isoFile = f;
		}

	    }  until (ret == `next || ret == `back);

	return ret;
    }


    /**
     * ISO Summary
     */

    global define isoSummary() ``{
	import "HTML";

	// caption
	string caption = _("ISO Summary");
	string html =  HTML::Heading(_("Package Source"));
	html = html + HTML::Para(ISO::sourceDir);

	html = html +  HTML::Heading(_("Packages"));
	html = html + HTML::Para(sformat("%1", size(Pkg::GetPackages(`selected, true))));

	html = html +  HTML::Heading(_("Missing Packages"));
	if (size(ISO::missing_packages) > 0 ) {
	    html = html + HTML::List(ISO::missing_packages);
	} else {
	    html = html + HTML::Para(_("None"));
	}

	term contents =
	    `RichText(html);

	string help_text = _("<p>Verify if the data in the summary box is correct then
press Next to continue.</p>
");

	Wizard::SetContentsButtons ( caption,
				     contents,
				     help_text,
				     Label::BackButton (),
				     Label::NextButton ());
	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();
	    }  until (ret == `next || ret == `back || ret == `abort);
	return ret;
    }

    /**
     * ISO creation Dialog
     *
     */
    global define isoDialog()
	``{

	import "Progress";

	// caption
	string caption = _("Custom CDs");

	string help = _("<p>Please wait while the data and packages are verified...
</p>
");
	help = help +  _("<p>If there is something missing, the process will be aborted.
Fix the problem and try again.</p>
");

	list progress_stages =
	    [
	     _("Set up Package Source"),
	     _("Verify Profile Consistency"),
	     _("Create Package List"),
	     _("Verify Package Availability")
	     ];

	list progress_descriptions =
	    [
	     _("Configuring package source..."),
	     _("Verifying control file consistency..."),
	     _("Creating package list..."),
	     _("Verifying package availability...")
	     ];

	Progress::New(
		      _("Verify Data for ISO Image"),
		      "",     // progress_title
		      size( progress_stages ),
		      progress_stages,
		      progress_descriptions,
		      help );


	boolean success = true;
	Progress::NextStage();
	success = ISO::initSource();


	Progress::NextStage();
	string error_msg = checkProfile();
	if (error_msg != "") {
	    Popup::Error(error_msg);
	    return `abort;
	}


	Progress::NextStage();
	success = setPackages();


	Progress::NextStage();
	error_msg = checkPackageAvail();
	if (error_msg != "")
	{
	    Popup::Error(error_msg);
	}

	Progress::Finish();

	UI::ChangeWidget(`id(`next), `Enabled, true);
	UI::ChangeWidget(`id(`back), `Enabled, true);
	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();



	    }  until (ret == `next || ret == `back || ret == `abort);

	return ret;
    }



    /**
     * Create ISO
     *
     */
    global define createISO() ``{

	import "Progress";


	string help = UI(_("<P>
Please wait while the directory structure for the new ISO file is created.
</P>
"));
	help = help + _("<p>Press <b>Next</b> to start creating the ISO file.</p>");



	list progress_stages =
	    [
	     _("Create skeleton with essential files"),
	     _("Save Control File in ISO Directory"),
	     _("Copy selected packages")
	     ];

	list progress_descriptions =
	    [

	     _("Creating skeleton with essential files"),
	     _("Saving control file in ISO directory..."),
	     _("Copying selected packages")
	     ];


	list selPacs = Pkg::GetPackages (`selected , false);

	y2milestone ("install %1", selPacs);


	Progress::New(
		      _("Creating ISO image"),
		      "",     // progress_title
		      size( progress_stages ) + size(selPacs) + 1,	// progress bar length
		      progress_stages,
		      progress_descriptions,
		      help );



	Progress::NextStage();
	ISO::createISOSkeleton();

	Progress::NextStage();

	string cpCmd = sformat("cp /usr/share/autoinstall/isolinux.cfg %1/skeleton/boot/loader", ISO::skeletonDir);
	SCR::Execute (.target.bash, cpCmd);
	cpCmd = sformat("cp /usr/share/autoinstall/message %1/skeleton/boot/loader", ISO::skeletonDir);
	SCR::Execute (.target.bash, cpCmd);
	cpCmd = sformat("cp /usr/share/autoinstall/options.msg %1/skeleton/boot/loader", ISO::skeletonDir);
	SCR::Execute (.target.bash, cpCmd);

	Progress::NextStep();

	if ( size(SCR::Read(.target.dir, AutoinstConfig::classDir) ) > 0 )
	{
	    y2milestone("class dir exists...");
	    SCR::Execute (.target.bash, sformat("cp -a %1 %2/skeleton/",   AutoinstConfig::classDir, ISO::skeletonDir ) );
	}
	string location = sformat("%1/skeleton/autoinst.xml", ISO::skeletonDir);
	Profile::Save(location);

	Progress::NextStage();

	integer i = 0;


	string datadir = ISO::productData["datadir"]:"./suse";
	y2milestone ("datadir %1", datadir);
	foreach(`pac, selPacs, ``{

	    list tok = splitstring( pac , " ");

	    string pacname = tok[0]:"error" + "-" + tok[1]:"1.0"  + "-" + tok[2]:"0" + "." + tok[3]:"noarch" + ".rpm";
	    string location = tok[3]:"noarch" + "/" + pacname;

	    string localpath =  ISO::sourceDir + "/" + datadir + "/" + location;
	    integer pacsize = SCR::Read(.target.size, localpath);
	    if (pacsize != -1)
	    {
		Progress::Title(sformat(_("Copying %1"),  pacname));
		Progress::NextStep();
		string dir = ISO::skeletonDir + "/skeleton/" + datadir + "/" + tok[3]:"noarch";

		if (size(SCR::Read(.target.dir, dir)) == nil )
		{
		    SCR::Execute(.target.mkdir , dir);
		}

		string cpCmd = sformat("cp %1 %2/skeleton/%3/%4", localpath, ISO::skeletonDir, datadir, location);

		y2debug("%1", cpCmd);

		any ret = SCR::Execute (.target.bash, cpCmd);
	    }


	});


	Progress::Title(_("ISO image directory ready"));
	Progress::Finish();

	UI::ChangeWidget(`id(`next), `Enabled, true);

	any ret  = nil;

	repeat
	    {
		ret = UI::UserInput();
		if (ret == `next)
		{
		    string mkisofscmd =	ISO::createISOCmd(ISO::isoFile );
		    y2milestone("command: %1",  mkisofscmd );

		    string du = lookup(SCR::Execute(.target.bash_output, sformat("du -s -b %1/skeleton | awk -F' ' ' { printf $1 }'", ISO::skeletonDir )), "stdout", "");
		    integer fsSize = tointeger(du);
		    y2milestone("size: %1" , fsSize);
		    SCR::Execute (.target.bash_background,  mkisofscmd);
		    isoSizeDialog(fsSize, ISO::isoFile);

		}

	    } until (ret == `next || ret == `back || ret == `abort);
	return ret;
    }




}
