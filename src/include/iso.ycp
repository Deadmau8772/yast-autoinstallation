/**
 * File:	include/autoinstall/iso.ycp
 * Package:	Autoinstallation Configuration System
 * Summary:	ISO creation
 * Authors:	Anas Nashif<nashif@suse.de>
 *
 * $Id$
 */

{
    textdomain "autoinst";

   
    /**
     * Compute packages needed for autoinstallation
     * @return list packages
     */

    global define list autoinstPackages(list packageList, string kernel )
	``{
	
	map configure = Profile::current["configure"]:$[];
	list packages = [];

	packages = union (packages, packageList);

	// In autoinst mode, a kernel might be external and not available
	// in common.pkd
	if (size(kernel)==0)
	{
	    packages =union (packages, ["k_deflt", "k_athlon", "k_smp"]);
	}

	if (haskey(configure, "nis")) {
		map nis = configure["nis"]:$[];
		if (nis["start_nis"]:false)
			packages = add(packages, "ypbind");
		if (nis["start_autofs"]:false)
			packages = add(packages, "autofs");
	}

	if (haskey(configure, "ldapclient")) {
		map ldapclient = configure["ldapclient"]:$[];
		if (ldapclient["start_ldapclient"]:false)
			packages = union(packages, ["pam_ldap","nss_ldap"]);
	}

	if (haskey(configure, "nfs_server"))
	{
	    boolean start_nfsserver = configure["nfs_server", "start_nfsserver"]:false;
	    if (start_nfsserver)
		packages = union(packages, ["yast2-nfs-server", "nfs-utils"]);
	}
	
	if (haskey(configure, "inetd")) {
		map inetd = configure["inetd"]:$[];
		if (inetd["start_inetd"]:false)
			packages = add(packages, "inetd");
	}

	if (haskey(configure, "nisplus")) {
		map nisplus = configure["nisplus"]:$[];
		if (nisplus["start_nisplus"]:false)
			packages = add(packages, "nis-utils");
	}
	if (haskey(configure, "mail")) {
		map mail = configure["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			packages = add(packages, "postfix");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			packages = add(packages, "sendmail");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-sendmail");
		}
	}
	y2milestone("package list needed during auto-installation: %1", packages);
	return packages;
    }


    global define string checkProfile() ``{
	import "Profile";

	map _prof = Profile::current;

	map _conf = _prof["install"]:$[];
	map _soft = _conf["software"]:$[];

	string base = _soft["base"]:"";
	list addons = _soft["addons"]:[];
	list packs  = _soft["packages"]:[];
	string kernel = _soft["kernel"]:"";


	string error_msg = "";
	
	if (base == "" && size(packs)<20) {
	    error_msg = _("Base selection not defined!");
	}
	else if (size(software) == 0) {
	    error_msg = _("Software resource not defined!");
	}
	return error_msg;
    }

    global define string checkPackageAvail() ``{
	 
	string descrDir 	= ISO::productData["descrdir"]:"suse/setup/descr";
	string dataDir 	= ISO::productData["datadir"]:"./suse";
	string sourceDir 	= ISO::sourceDir;
	string packDB 		= descrDir + "/packages";	 
	Progress::Title(sformat(_("Checking for package database: %1"), packDB));

	string error_msg = "";
	if (SCR::Execute(.target.size, sourceDir + "/" + packDB) == -1 ) {
	    error_msg = _("Package database not found.");
	}

	Progress::Title(_("Checking for package availability"));
	
	list selPacs = Pkg::GetPackages (`selected , false);
	list failed = [];
	foreach(`pac, selPacs, ``{
	    
	    list tok = splitstring( pac , " ");
	    
	    string pacname = tok[0]:"error" + "-" + tok[1]:"1.0"  + "-" + tok[2]:"0" + "." + tok[3]:"noarch" + ".rpm";
	    string location = tok[3]:"noarch" + "/" + pacname;
	    
	    string localpath =  ISO::sourceDir + "/" + dataDir + "/" + location;	
	    integer pacsize = SCR::Read(.target.size, localpath);
	    
	    if (pacsize == -1)
	    {	
		failed=add(failed, tok[0]:"Error");
	    }
	    
	  
	  
	});
	ISO::missing_packages = failed;
	if (size(failed) > 0 )
	{
	    error_msg = sformat(_("%1 Packages not available."), size(failed));
	}

	return error_msg;
    }
    

    /**
     * Set packages
     */
    
    global define boolean setPackages() ``{
	import "Profile";

	map _prof = Profile::current;

	map _conf = _prof["install"]:$[];
	map _soft = _conf["software"]:$[];

	string base = _soft["base"]:"";
	list addons = _soft["addons"]:[];
	list packs  = _soft["packages"]:[];
	string kernel = _soft["kernel"]:"";
	

	if (base!="")
	{
	    Pkg::SetSelection(base);
	}
	else
	{
	    Pkg::SetSelection("Minimal");
	}
	
	// Addons
	if (size(addons) > 0 )
	{
	    foreach(`s, addons, ``{
		Pkg::SetSelection(s);
	    });
	}

	Pkg::DoProvide(autoinstPackages(packs, kernel));
	Pkg::PkgSolve();
	
	return (Pkg::ActivateSelections());

    }
    
 
    /**
     * ISO size dialog
     *
     */
    global define isoSizeDialog(integer expectedSize, string filename)``{

	string iso_msg = _("Please wait while the ISO file is being created...");
	if (UI::HasSpecialWidget(`DownloadProgress)) {
	    UI::OpenDialog(
			   `VBox(
				 `Heading(iso_msg),
				 `DownloadProgress(ISO::isoFile, filename, expectedSize - 1000000)								
				 )
			   );	    
	    UI::UserInput();
	    UI::CloseDialog();
	} else {
	    showFeedback(iso_msg);
	    while (true) {
		integer expect = expectedSize - 1000000;
		integer isosize = SCR::Read(.target.size, ISO::isoFile);
		if (isosize > expect) {
		    break;
		}
		sleep (5);
	    }
	    clearFeedback();
	}

	return;
    }


    global define symbol isoSequence () ``{
	map sequence = $[
			 "ws_start" 	: "options",
			 "options"	: $[
					    `next	: "verify",					    
			 ],
			 "verify"	: $[
					    `next	: "summary",
					    `abort	: `ws_finish
			 ],	
			 "summary"	: $[
					    `next	: "create" 
					    ],
			 "create"	: $[
					    `next	: `ws_finish
					    ]
			 
	];
	// Translators: dialog caption
	string caption = _("Custom ISO image");
	term contents = `Label (_("Initializing ..."));

	Wizard::CreateDialog ();
	Wizard::SetContentsButtons ( caption,
				     contents,
				     "",
				     CancelButtonLabel (),
				     NextButtonLabel ());


	any ret = WizardSequencer (iso_dlg, sequence);

	UI::CloseDialog ();
	return ret;
    }



    /**
     * ISO Options
     */
    global define isoOptions()``{
	string caption = _("ISO Options");
	string help= _("Enter the desired name of the ISO image to be created and
select any of the listed options.");
	
	term contents =
	    `Top(
		 `VBox(
		       `HBox(
			     `TextEntry(`id(`file), _("Save ISO &file as:"), ISO::isoFile)		
			     )		      
		       )
		 );
	
	Wizard::SetContentsButtons ( caption,
				     contents,
				     help,
				     BackButtonLabel (),
				     NextButtonLabel ());
	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();
		if ( ret == `next) {
		    string f  = UI::QueryWidget(`id(`file), `Value);
		    if (   f == "" || f == nil)
		    {
			UI::ErrorPopup(invalidFileName());
			continue;
		    }
		    ISO::isoFile = f;
		}
		
	    }  until (ret == `next || ret == `back || ret == `abort);
	
	return ret;
    }

    
    /**
     * ISO Summary
     */

    global define isoSummary() ``{
	import "HTML";
	string caption = _("ISO Summary");	
	string html =  HTML::Heading(_("Package source"));
	html = html + HTML::Para(ISO::sourceDir);

	html = html +  HTML::Heading(_("Packages"));
	html = html + HTML::Para(sformat("%1", size(Pkg::GetPackages(`selected, true))));

	html = html +  HTML::Heading(_("Missing Packages"));
	if (size(ISO::missing_packages) > 0 ) {
	    html = html + HTML::List(ISO::missing_packages);
	} else {
	    html = html + HTML::Para(_("None"));
	}
	
	term contents =
	    `RichText(html);

	string help_text = _("<p>Please verify if the data in the summary box is correct and
press next to continue</p>");
	
	Wizard::SetContentsButtons ( caption,
				     contents,
				     help_text,
				     BackButtonLabel (),
				     NextButtonLabel ());
	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();
	    }  until (ret == `next || ret == `back || ret == `abort);
	return ret;
    }
    
    /**
     * ISO creation Dialog
     *
     */
    global define isoDialog()
	``{
		
	import "Progress";
	
	string caption = _("Custom CDs");

	string help = _("<p>Please wait while the data and packages are being verified
</p>");
	help = help +  _("<p>In case there is something missing, the process will be aborted.
Please fix the problem and try again.</p>
");

	list progress_stages =
	    [
	     _("Setup package source"),	     
	     _("Verify profile consistency"),
	     _("Create package list"),
	     _("Verify package availablity")
	     ];

	list progress_descriptions =
	    [
	     _("Configuring package source..."),
	     _("Verifying control file consistency..."),
	     _("Creating package list..."),	     
	     _("Verifying package availablity...")	   
	     ];
	
	Progress::New(
		      _("Verify data for ISO image"),
		      "",     // progress_title
		      size( progress_stages ),
		      progress_stages,
		      progress_descriptions,
		      help );
	

	boolean success = true;
	Progress::NextStage();
	success = ISO::initSource();

	
	Progress::NextStage();	
	string error_msg = checkProfile();
	if (error_msg != "") {
	    UI::ErrorPopup(error_msg);
	    return `abort;
	}
	

	Progress::NextStage();
	success = setPackages();
	
	
	Progress::NextStage();
	error_msg = checkPackageAvail();	
	if (error_msg != "")
	{
	    UI::ErrorPopup(error_msg);	    
	}
	
	Progress::Finish();
	
	UI::ChangeWidget(`id(`next), `Enabled, true);
	UI::ChangeWidget(`id(`back), `Enabled, true);
	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();

		

	    }  until (ret == `next || ret == `back || ret == `abort);
	
	return ret;
    }


    
    /**
     * Create ISO
     *
     */
    global define createISO() ``{

	import "Progress";
	
	
	string help = UI(_("<P>
Please wait while the directory structure for the new ISO file is being created.
</P>
"));
	help = help + _("<p>Pressing <b>Next</b> will start creating the ISO file.</p>");


	    
	list progress_stages =
	    [
	     _("Create skeleton with essential files"),
	     _("Save Control File in ISO directory"),
	     _("Copy selected packages")
	     ];

	list progress_descriptions =
	    [
	     
	     _("Creating skeleton with essential files"),
	     _("Saving control file in ISO direcotry"),
	     _("Copying selected packages")	   
	     ];

	
	list selPacs = Pkg::GetPackages (`selected , false);
		
	y2milestone ("install %1", selPacs);

	
	Progress::New(
		      _("Creating ISO image"),
		      "",     // progress_title
		      size( progress_stages ) + size(selPacs) + 1,	// progress bar length
		      progress_stages,
		      progress_descriptions,
		      help );
	

		
	Progress::NextStage();
	ISO::createISOSkeleton();

	Progress::NextStage();
	
	string cpCmd = sformat("cp /usr/share/autoinstall/isolinux.cfg %1/skeleton/boot/loader", ISO::skeletonDir);
	SCR::Execute (.target.bash, cpCmd);
	
	Progress::NextStep();
	
	string location = sformat("%1/skeleton/autoinst.xml", ISO::skeletonDir);
	Profile::Save(location);
	
	Progress::NextStage();	
	
	integer i = 0;
	
	
	string datadir = ISO::productData["datadir"]:"./suse";
	y2milestone ("datadir %1", datadir);	
	foreach(`pac, selPacs, ``{
	    
	    list tok = splitstring( pac , " ");
	    
	    string pacname = tok[0]:"error" + "-" + tok[1]:"1.0"  + "-" + tok[2]:"0" + "." + tok[3]:"noarch" + ".rpm";
	    string location = tok[3]:"noarch" + "/" + pacname;
	    
	    string localpath =  ISO::sourceDir + "/" + datadir + "/" + location;
	    y2milestone("local path: %1", localpath);
	    integer pacsize = SCR::Read(.target.size, localpath);
	    if (pacsize!=-1)
	    {
		Progress::Title(sformat(_("Copying %1"),  pacname));
		Progress::NextStep();
		string dir = ISO::skeletonDir + "/skeleton/" + datadir + "/" + tok[3]:"noarch";
		
		if (size(SCR::Read(.target.dir, dir)) == nil )
		{
		    SCR::Execute(.target.mkdir , dir);
		}
		
		string cpCmd = sformat("cp %1 %2/skeleton/%3/%4", localpath, ISO::skeletonDir, datadir, location);
		y2milestone("%1", cpCmd);
		any ret = SCR::Execute (.target.bash, cpCmd);			
	    }
	  
	  
	});
	

	Progress::Title(_("ISO image directory ready"));
	Progress::Finish();
	
	UI::ChangeWidget(`id(`next), `Enabled, true);	

	any ret  = nil;

	repeat
	    {
		ret = UI::UserInput();	
		if (ret == `next)
		{
		    string mkisofscmd =	ISO::createISOCmd(ISO::isoFile );
		    y2milestone("command: %1",  mkisofscmd );
		    
		    string du = lookup(SCR::Execute(.target.bash_output, sformat("du -s -b %1/skeleton | awk -F' ' ' { printf $1 }'", ISO::skeletonDir )), "stdout", "");
		    integer fsSize = tointeger(du);
		    y2milestone("size: %1" , fsSize);
		    SCR::Execute (.target.bash_background,  mkisofscmd);
		    isoSizeDialog(fsSize, ISO::isoFile);

		}
	
	    } until (ret == `next || ret == `back || ret == `abort);
	return ret;
    }



    
}
