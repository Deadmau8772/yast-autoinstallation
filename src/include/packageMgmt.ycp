/**
 * File:	include/autoinstall/packageMgmt.ycp
 * Package:	Autoinstallation Configuration System
 * Summary:	Package Management
 * Authors:	Anas Nashif<nashif@suse.de>
 *
 * $Id$
 */

{
    textdomain "autoinst";

   
    /**
     * Compute packages needed for autoinstallation
     * @return list packages
     */

    global define list autoinstPackages(list packageList, string kernel )
	``{
	
	map configure = AIConfig::Profile["configure"]:$[];
	list packages = [];

	packages = union (packages, packageList);

	// In autoinst mode, a kernel might be external and not available
	// in common.pkd
	if (size(kernel)==0)
	{
	    packages =add (packages, "k_deflt");
	}

	if (haskey(configure, "nis")) {
		map nis = configure["nis"]:$[];
		if (nis["start_nis"]:false)
			packages = add(packages, "ypbind");
		if (nis["start_autofs"]:false)
			packages = add(packages, "autofs");
	}

	if (haskey(configure, "ldapclient")) {
		map ldapclient = configure["ldapclient"]:$[];
		if (ldapclient["start_ldapclient"]:false)
			packages = union(packages, ["pam_ldap","nss_ldap"]);
	}


	if (haskey(configure, "inetd")) {
		map inetd = configure["inetd"]:$[];
		if (inetd["start_inetd"]:false)
			packages = add(packages, "inetd");
	}

	if (haskey(configure, "nisplus")) {
		map nisplus = configure["nisplus"]:$[];
		if (nisplus["start_nisplus"]:false)
			packages = add(packages, "nis-utils");
	}
	if (haskey(configure, "mail")) {
		map mail = configure["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			packages = add(packages, "postfix");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			packages = add(packages, "sendmail");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-sendmail");
		}
	}
	y2milestone("package list needed during auto-installation: %1", packages);
	return packages;
    }

    global define void setPackages() ``{
	import "AIConfig";

	map _prof = AIConfig::Profile;

	map _conf = _prof["install"]:$[];
	map _soft = _conf["software"]:$[];

	string base = _soft["base"]:"";
	list addons = _soft["addons"]:[];
	list packs  = _soft["packages"]:[];
	string kernel = _soft["kernel"]:"";
	
	if (!AIConfig::PkdInitialized)
	{
	    string base_url = "dir://" + AIServer::PackageRep;
	    AIConfig::theSource = Pkg::SourceInit (base_url);
	}
	else
	{
	    y2milestone("Source already active");
	}
	// Base selection
	if (base!="")
	{
	    Pkg::SetSelection(base);
	}
	
	// Addons
	if (size(addons) > 0 )
	{
	    foreach(`s, addons, ``{
		Pkg::SetSelection(s);
	    });
	}

	Pkg::DoProvide(autoinstPackages(packs, kernel));
	Pkg::ActivateSelections();
	return ;
	
    }
    
 
    /**
     * ISO size dialog
     *
     */
    global define isoSizeDialog(integer expectedSize, string filename)``{
	
	UI::OpenDialog(
		       `VBox(
			     `Heading(_("Please wait while the ISO file is created.")),
			     `DownloadProgress(AIServer::isoFile, filename, expectedSize - 1000000),
			     `HSpacing(50), // force width
			     `PushButton(`opt(`default), CloseButtonLabel())
			     )
		       );
	UI::UserInput();
	UI::CloseDialog();
	return;
    }

    
    /**
     * ISO creation Dialog
     *
     */
    global define isoDialog()``{
	
	AIServer::nojoliet = true;
	
	term contents = `Top(
			     `VBox(
				   `VSquash(
					    `HBox(
						  `TextEntry(`id(`susedir), _("&SuSE Package Directory:"), AIServer::PackageRep),
						  `VBox(
							`VSpacing(),
							`Bottom(`PushButton(`id(`opensusedir), _("Select &Directory")))
							)
						  )
					    ),
				   `VSquash(
					    `TextEntry(`id(`dest), _("&Destination"), "")
					    )				   
				   )
			     );
	
	string caption = _("Create Custom CD");
	string help = _("<P>Enter the location of your copied CDs in
the <em>SuSE Package Directory</em>
field. This directory must contain the <b>suse</b> subdirectory, which contains
the RPMS of one or all copied CDs.</p>
");

	help = help + _("<p>In the <em>Destination</em>, enter the name of the ISO file to create, such as
<b>/tmp/suse.iso</b></p>
");

	help = help + _("<p>Pressing <b>Next</b> will create the directory structure
needed to create the ISO image.</p>
");

	
  
	Wizard::SetContentsButtons (caption,
				    contents,
				    help,
				    BackButtonLabel (),
				    NextButtonLabel ());

	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();

		if (ret == `next)
		{
		    
		    AIServer::sourceDir = UI::QueryWidget(`id(`susedir), `Value);
		    string f = UI::QueryWidget(`id(`dest), `Value);
		   
		    if (   f == "" || f == nil)
		    {
			UI::ErrorPopup(invalidFileName());
			continue;
		    }
		    AIServer::isoFile = f;
		}

	    }  until (ret == `next || ret == `back || ret == `abort);    
	return ret;
    }



    global define createISO() ``{

	import "Progress";


	setPackages();
	
	string help = UI(_("<P>
Please wait while the directory structure for the new ISO file is created.
</P>
"));
	help = help + _("<p>Press <b>Next</b> to create the ISO file.</p>");


	    
	list progress_stages =
	    [
	     _("Create skeleton with essential files"),
	     _("Saving Control File"),
	     _("Copy selected packages")
	     ];

	list progress_descriptions =
	    [
	     _("Creating skeleton with essential files"),
	     _("Saving control file"),
	     _("Copying selected packages")	   
	     ];

	
	list ins_del_count = Pkg::PkgPrepareOrder();
	y2milestone ("delete %1, install %2", ins_del_count[0]:-1, ins_del_count[1]:-1);

	
	Progress::New(
		      _("Creating ISO image"),
		      "",     // progress_title
		      size( progress_stages ) + ins_del_count[1]:-1 + 1,	// progress bar length
		      progress_stages,
		      progress_descriptions,
		      help );

	
	Progress::NextStage();
	AIServer::createISOSkeleton();

	Progress::NextStage();
	
	string cpCmd = sformat("cp /usr/share/autoinstall/isolinux.cfg %1/skeleton/suse/images/boot/", AIServer::skelDir);
	SCR::Execute (.target.bash, cpCmd);
	
	Progress::NextStep();
	
	string location = sformat("%1/skeleton/autoinst.xml", AIServer::skelDir);
	AIConfig::SaveProfile(location);
	
	Progress::NextStage();	
	
	integer i = 0;
	




	map product = Pkg::SourceProductData (AIConfig::theSource);
	string datadir = product["datadir"]:"suse";
	y2milestone ("datadir %1", datadir);
	string pkgname = "";
	pkgname = Pkg::PkgNextInstall();	
	while ((pkgname != nil)
	       && (pkgname != ""))
	{
	    
	    string location = Pkg::PkgLocation (pkgname);	    
	    string localpath = Pkg::SourceProvide (AIConfig::theSource, datadir + "/" + location);	    
	    y2milestone("local path %1", localpath);
	    integer pacsize = SCR::Read(.target.size, localpath);
	    if (pacsize!=-1)
	    {
		Progress::Title(sformat(_("Copying %1"),  pkgname));
		Progress::NextStep();
		string cpCmd = sformat("cp %1 %2/skeleton/suse/%3", localpath, AIServer::skelDir,  location);
		any ret = SCR::Execute (.target.bash, cpCmd);			
	    }

	    pkgname = Pkg::PkgNextInstall();
	}
	

	Progress::Title(_("ISO image directory ready"));
	Progress::Finish();
	UI::ChangeWidget(`id(`next), `Enabled, true);	

	any ret  = nil;

	repeat
	    {
		ret = UI::UserInput();	
		if (ret == `next)
		{
		    string mkisofscmd =	AIServer::createISOCmd(AIServer::isoFile );
		    y2milestone("command: %1",  mkisofscmd );
		    
		    string du = lookup(SCR::Execute(.target.bash_output, sformat("du -s -b %1/skeleton | awk -F' ' ' { printf $1 }'", AIServer::skelDir )), "stdout", "");
		    integer fsSize = tointeger(du);
		    y2milestone("size: %1" , fsSize);
		    SCR::Execute (.target.bash_background,  mkisofscmd);
		    isoSizeDialog(fsSize, AIServer::isoFile);

		}
	
	    } until (ret == `next || ret == `back || ret == `abort);
	return ret;
    }



    
}
