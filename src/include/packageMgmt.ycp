/**
 * File:	include/autoinstall/packageMgmt.ycp
 * Package:	Autoinstallation Configuration System
 * Summary:	Package Management
 * Authors:	Anas Nashif<nashif@suse.de>
 *
 * $Id$
 */

{
    textdomain "autoinst";

    /**
     * Create selection table for widget
     * @param list current selection
     * @return list selections as widget list
     */
    global define list CreateSelTable(list selected) ``{
	
	list Selections = maplist(`s, Pkg::GetSelections(`all) , ``{
		any data = Pkg::SelectionData(s);
		if (is(data , map)) {
		    return ([s, data["summary"]:"", data["category"]:"base"]);
		}
		else
		{
		    return ([]);
		}
	    });
		
	
	list ui_sel = maplist(list sel, Selections, ``{
	    return (`item(`id(select(sel,0,"None")), contains(selected,select(sel,0,"None")) ? "s" : "", select(sel,0,"None"), select(sel,1,"None"), select(sel,2,"None")));
	});
	return ui_sel;
    }
    
    /**
     * Add a selection to the stack of selections
     *
     */
    global define addSelection(string selection)
	``{
	if (contains(AIServer::Selections,selection))
	{
	    return (filter(`s, AIServer::Selections,``(s!=selection)));
	}
	else
	{
	    return(add(AIServer::Selections,selection));
	}
    }




    /**
     * Compute packages needed for autoinstallation
     * @return list(string)
     */

    global define list autoinstPackages(list packageList, string kernel )
	``{
	
	map configure = AIConfig::Profile["configure"]:$[];
	list packages = [];

	packages = union (packages, packageList);

	// In autoinst mode, a kernel might be external and not available
	// in common.pkd
	if (size(kernel)==0)
	{
	    packages =add (packages, "k_deflt");
	}

	if (haskey(configure, "nis")) {
		map nis = configure["nis"]:$[];
		if (nis["start_nis"]:false)
			packages = add(packages, "ypbind");
		if (nis["start_autofs"]:false)
			packages = add(packages, "autofs");
	}

	if (haskey(configure, "ldapclient")) {
		map ldapclient = configure["ldapclient"]:$[];
		if (ldapclient["start_ldapclient"]:false)
			packages = union(packages, ["pam_ldap","nss_ldap"]);
	}


	if (haskey(configure, "inetd")) {
		map inetd = configure["inetd"]:$[];
		if (inetd["start_inetd"]:false)
			packages = add(packages, "inetd");
	}

	if (haskey(configure, "nisplus")) {
		map nisplus = configure["nisplus"]:$[];
		if (nisplus["start_nisplus"]:false)
			packages = add(packages, "nis-utils");
	}
	if (haskey(configure, "mail")) {
		map mail = configure["mail"]:$[];
		if (mail["mta"]:`other == `postfix)
		{
			packages = add(packages, "postfix");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-postfix");
		}
		else if (mail["mta"]:`other == `sendmail)
		{
			packages = add(packages, "sendmail");
			if (mail["use_amavis"]:false)
				packages = add(packages, "amavis-sendmail");
		}
	}
	y2milestone("package list needed during auto-installation: %1", packages);
	return packages;
    }    
    /**
     * Selection Manipulation and Management
     *
     */
    global define SelectionInfo(boolean consistency)
	``{
	
	list current_sel = AIServer::Selections;
	y2milestone("current sel: %1", current_sel );

	list packages = [];
	if (size(current_sel) > 1) 
	{
	    integer sel = 1;	
	    SCR::Execute(.package.selectSelInstall, select( current_sel, 0 , "" ), true );
	    while (sel < size(current_sel) - 1)
	    {
		SCR::Execute(.package.selectSelInstall, select( current_sel,sel,"" ),false );
		sel = sel + 1;
	    }
	    SCR::Execute(.package.selectSelInstall, select( current_sel,size(current_sel)-1,"" ),false );
	    packages = SCR::Read (.package.selPackages);
	} 
	else if (size(current_sel) == 1)
	{
	    SCR::Execute(.package.selectSelInstall, select( current_sel, 0, "" ), true );
	    packages = SCR::Read (.package.selPackages);
	}
	else
	{	    
	    packages = [];
	}
	
	
	

	list allPacs = toset(union( packages, AIServer::morePackages));
	y2milestone("Packages: %1", allPacs);

	AIServer::totalPacs = size(allPacs );
	
	SCR::Execute(.package.setInstallSelection, allPacs , true);
	
	map dep = SCR::Read(.package.selDependencies);	
	map pacdep = SCR::Read(.package.dependencies);
	// SCR::Execute(.package.setInstallSelection, union(allPacs,pacdep["ADD"]:[]) , true);
	
	y2milestone("depend %1", dep);
	
	y2milestone("pack depend %1", pacdep);
	
	list neededCDs = SCR::Read (.package.neededCDs);
	
	y2milestone("needed CDs: %1", neededCDs );
	
	integer CdSourceSize = 0;
	integer SourceSize = 0;
	integer cdnum = 1;
	integer InstalledSize = 0;
	boolean anyCD = false;
	
	string summary = "";
	summary = Summary::AddHeader(summary, _("Needed CDs"));
	summary = Summary::OpenList(summary);
	
	integer i = 1;
	foreach(`cd, neededCDs, ``{
	    if (cd != 0) {
		anyCD = true;
		list cdlist = SCR::Read (.package.installSetCD, i);
		foreach (`p, cdlist, ``{
		    string pacPath = sformat("%1/suse/%2", AIServer::PackageRep ,select(p,0,""));
		    integer pacsize = SCR::Read(.target.size, pacPath);
		    if (pacsize!=-1) {
			CdSourceSize = CdSourceSize + pacsize;			
		    }
		    
		});
		string entry = sformat("<p>CD%1 will install <b>%2 Mb</b> (%3 Kb) of software.<br>Size of sources is <b>%4 Mb</b> (%5 Kb)</p>",i, cd/1000, cd, CdSourceSize/ 1000000,  CdSourceSize/ 1000);
		summary = Summary::AddListItem(summary, entry);
	    }
	    SourceSize = SourceSize + CdSourceSize;
	    CdSourceSize = 0;
	    InstalledSize = InstalledSize + cd;
	    i = i + 1;
	});	
	
	summary = Summary::CloseList(summary);

	if (!anyCD)
	    summary = Summary::AddLine(summary,_("None"));

	
	summary = Summary::AddHeader(summary, _("Total installed size"));
	summary = Summary::AddLine(summary, sformat(_("%1 Mb"), InstalledSize / 1000));
	summary = Summary::AddHeader(summary, _("Total package size"));
	summary = Summary::AddLine(summary, sformat(_("%1 Mb"), SourceSize / ( 1000 * 1000)));
	
	summary = Summary::AddHeader(summary, _("Packages"));
	summary = Summary::AddLine(summary, sformat(_("%1 packages will be installed"), size(allPacs)));
	
	summary = Summary::AddHeader(summary, _("Consistency Check"));
	if (!consistency)
	    summary = Summary::AddLine(summary, _("Not done yet"));
	else
	{
	    cdnum = 1;
	    integer found = 0;
	    
	    foreach(`cd, neededCDs, ``{		
		list cdlist = SCR::Read (.package.installSetCD, cdnum);
		y2milestone("cdlist %1: %2", cdnum, cdlist);
		foreach (`p, cdlist, ``{
		    string pacPath = sformat("%1/suse/%2", AIServer::PackageRep ,select(p,0,""));
		    // y2milestone("path %1", pacPath);
		    if (SCR::Read(.target.size, pacPath)==-1)
		    {
			found = found +1;
		    }
		    
		});
		cdnum = cdnum + 1;
	    });

	    if (found == 0)
		summary = Summary::AddLine(summary,_("All packages are available"));
	    else
		summary = Summary::AddLine(summary,sformat(_("%1 packages missing."), found));
	}
	    
	
	
	

	//y2milestone("list %1", SCR::Read (.package.installSetCD, 1));
	return summary;
	
    }
    

    /**
     * Package Management
     *
     */
    global define packageManagement() ``{
	import "Packages";
	import "Installation";
	import "Mode";
	import "AIConfig";

	map _prof = AIConfig::Profile;
	
	map _conf = _prof["install"]:$[];
	map _soft = _conf["software"]:$[];

	string base = _soft["base"]:"";
	list addons = _soft["addons"]:[];
	list packs  = _soft["packages"]:[];
	string kernel = _soft["kernel"]:"";

	AIServer::Selections = add(addons, base);
	AIServer::morePackages = autoinstPackages(packs, kernel);

	
	y2milestone("Selections %1", AIServer::Selections);
	Installation::destdir = "/mnt";
	InstMedia::source_medium = true;
	Installation::sourcedir = AIServer::PackageRep;
	if (!AIServer::PkdInitialized)
	{
	    showFeedback(_("Please wait while the package database is initialized..."));
	    Packages::Init(false);
	    AIServer::PkdInitialized=true;
	    clearFeedback();
	}


	term contents =
	    `VBox(
		  `VWeight(50, `Table( `id(`table), `opt(`notify, `keepSorting), `header(_("Status"), _("Name"), _("Description"), _("Type")),
				       CreateSelTable(AIServer::Selections)
				       )
			   ),
		  `VSpacing(1),
		  `VWeight(50, `RichText(`id(`summary), SelectionInfo(false))
			   ),
		  `HBox(
			`PushButton(`id(`consistency), _("Consistenc&y Check")),
			`PushButton(`id(`reset), _("Reset Selecti&ons"))
			)				    
		  );

	string help = _("<P>
This dialog shows the package selection made and gives an idea of the
expected size of the ISO file to create.</P>
");

	help = help + _("<p>You can overwrite the package settings entered
in the control file by selecting some new package groups.</p>
");

	help = help + _("YaST2 automatically adds packages not included in
you selection but needed to perform the installation.</p>
");

	help = help + _("Use the <b>Consistency Check</b> to make sure all packages
are available.</p>
");

	
	Wizard::SetContents(_("Package Repository"),
			    contents, help , true, true);
	
	any ret = "";
	repeat {
	    ret = UI::UserInput();
	    string sel = "";
	    if (ret == `table)
	    {
		sel = UI::QueryWidget(`id(`table), `CurrentItem);
		AIServer::Selections=addSelection( sel);
		
		UI::ChangeWidget(`id(`table), `Items, CreateSelTable(toset(AIServer::Selections)));
		UI::ChangeWidget(`id(`table), `CurrentItem, sel);
		UI::ChangeWidget(`id(`summary), `Value, SelectionInfo(false));
	    }
	    else if ( ret == `consistency)
	    {
		UI::ChangeWidget(`id(`summary), `Value, SelectionInfo(true));
	    }
	    else if ( ret == `reset)
	    {
		AIServer::Selections=[];
		UI::ChangeWidget(`id(`table), `Items, CreateSelTable(toset(AIServer::Selections)));
		UI::ChangeWidget(`id(`table), `CurrentItem, sel);
		UI::ChangeWidget(`id(`summary), `Value, SelectionInfo(false));
	    }
	    
	    y2milestone("ret: %1", ret);
	} until (ret == `next ||  ret == `back || (ret == `abort && UI::ReallyAbortPopup (AIConfig::changed)));
	return ret;
    }

    /**
     * ISO size dialog
     *
     */
    global define isoSizeDialog(integer expectedSize, string filename)``{
	
	UI::OpenDialog(
		       `VBox(
			     `Heading(_("Please wait while the ISO file is created.")),
			     `DownloadProgress(AIServer::isoFile, filename, expectedSize - 1000000),
			     `HSpacing(50), // force width
			     `PushButton(`opt(`default), CloseButtonLabel())
			     )
		       );
	UI::UserInput();
	UI::CloseDialog();
	return;
    }

    
    /**
     * ISO creation Dialog
     *
     */
    global define isoDialog()``{
	
	AIServer::nojoliet = true;
	
	term contents = `Top(
			     `VBox(
				   `VSquash(
					    `HBox(
						  `TextEntry(`id(`susedir), _("&SuSE Package Directory:"), AIServer::PackageRep),
						  `VBox(
							`VSpacing(),
							`Bottom(`PushButton(`id(`opensusedir), _("Select &Directory")))
							)
						  )
					    ),
				   `VSquash(
					    `TextEntry(`id(`dest), _("&Destination"), "")
					    )				   
				   )
			     );
	
	string caption = _("Create Custom CD");
	string help = _("<P>Enter the location of your copied CDs in
the <em>SuSE Package Directory</em>
field. This directory must contain the <b>suse</b> subdirectory, which contains
the RPMS of one or all copied CDs.</p>
");

	help = help + _("<p>In the <em>Destination</em>, enter the name of the ISO file to create, such as
<b>/tmp/suse.iso</b></p>
");

	help = help + _("<p>Pressing <b>Next</b> will create the directory structure
needed to create the ISO image.</p>
");

	
  
	Wizard::SetContentsButtons (caption,
				    contents,
				    help,
				    BackButtonLabel (),
				    NextButtonLabel ());

	any ret = nil;
	repeat
	    {
		ret = UI::UserInput();

		if (ret == `next)
		{
		    
		    AIServer::sourceDir = UI::QueryWidget(`id(`susedir), `Value);
		    string f = UI::QueryWidget(`id(`dest), `Value);
		   
		    if (   f == "" || f == nil)
		    {
			UI::ErrorPopup(invalidFileName());
			continue;
		    }
		    AIServer::isoFile = f;
		}

	    }  until (ret == `next || ret == `back || ret == `abort);    
	return ret;
    }



    global define createISO() ``{

	import "Progress";

	string help = UI(_("<P>
Please wait while the directory structure for the new ISO file is created.
</P>
"));
	help = help + _("<p>Press <b>Next</b> to create the ISO file.</p>");


	    
	list progress_stages =
	    [
	     _("Create skeleton with essential files"),
	     _("Saving Control File"),
	     _("Copy selected packages")
	     ];

	list progress_descriptions =
	    [
	     _("Creating skeleton with essential files"),
	     _("Saving control file"),
	     _("Copying selected packages")	   
	     ];



	
	Progress::New(
		      _("Creating ISO image"),
		      "",     // progress_title
		      size( progress_stages ) + AIServer::totalPacs + 1,	// progress bar length
		      progress_stages,
		      progress_descriptions,
		      help );

	
	Progress::NextStage();
	AIServer::createISOSkeleton();

	Progress::NextStage();
	
	string cpCmd = sformat("cp /usr/share/autoinstall/isolinux.cfg %1/skeleton/suse/images/boot/", AIServer::skelDir);
	SCR::Execute (.target.bash, cpCmd);
	
	Progress::NextStep();
	
	string location = sformat("%1/skeleton/autoinst.xml", AIServer::skelDir);
	AIConfig::SaveProfile(location);
	
	Progress::NextStage();	
	
	integer i = 0;
	list neededCDs = SCR::Read (.package.neededCDs);
	foreach(`cd, neededCDs, ``{
	    if (cd != 0) {		
		list cdlist = SCR::Read (.package.installSetCD, i);
		foreach (`p, cdlist, ``{
		    string pacPath = sformat("%1/suse/%2", AIServer::sourceDir ,select( p, 0, ""));
		    integer pacsize = SCR::Read(.target.size, pacPath);
		    if (pacsize!=-1)
		    {
			Progress::Title(sformat(_("Copying %1"),  select( p, 0, "")));
			Progress::NextStep();
			string cpCmd = sformat("cp %1 %2/skeleton/suse/%3", pacPath, AIServer::skelDir,  select( p, 0, ""));
			any ret = SCR::Execute (.target.bash, cpCmd);
			
		    }
		    
		});
		
	    }	  
	    i = i + 1;
	});		
	Progress::Title(_("ISO image directory ready"));
	Progress::Finish();
	UI::ChangeWidget(`id(`next), `Enabled, true);	

	any ret  = nil;

	repeat
	    {
		ret = UI::UserInput();	
		if (ret == `next)
		{
		    string mkisofscmd =	AIServer::createISOCmd(AIServer::isoFile );
		    y2milestone("command: %1",  mkisofscmd );
		    
		    string du = lookup(SCR::Execute(.target.bash_output, sformat("du -s -b %1/skeleton | awk -F' ' ' { printf $1 }'", AIServer::skelDir )), "stdout", "");
		    integer fsSize = tointeger(du);
		    y2milestone("size: %1" , fsSize);
		    SCR::Execute (.target.bash_background,  mkisofscmd);
		    isoSizeDialog(fsSize, AIServer::isoFile);

		}
	
	    } until (ret == `next || ret == `back || ret == `abort);
	return ret;
    }



    
}
